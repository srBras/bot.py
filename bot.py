import os
import json
import time
import random
import asyncio
import requests
import importlib
import importlib.util
import os
from typing import List, Dict, Any
from datetime import datetime, timedelta
import pytz

import discord
from discord.ext import commands, tasks
from discord.ui import View, Button
from dotenv import load_dotenv
import mercadopago
import codigo2bot
# ----------------- CONFIGURA√á√ïES -----------------
load_dotenv("arquivo.env")
DISCORD_TOKEN = os.getenv("DISCORD_TOKEN")
ML_TOKEN = os.getenv("ML_TOKEN")
ML_PUBLIC_KEY = os.getenv("ML_PUBLIC_KEY")

# Inicializar SDK do Mercado Pago
sdk = mercadopago.SDK(ML_TOKEN)

DB_FILE = "planos_ativos.json"
POST_DB = "posts.json"
PAYMENTS_DB = "pagamentos.json"

intents = discord.Intents.default()
intents.message_content = True
intents.guilds = True
intents.members = True
bot = commands.Bot(command_prefix="!", intents=intents, help_command=None)

# ----------------- PLANOS ATUALIZADOS CONFORME SOLICITADO -----------------
PLANOS = [
    {"id_plano": 1, "descricao": "Vendedor Vermelho üî¥", "tipo": "vendedor", "dias_post": 1, "preco": 25.00},
    {"id_plano": 2, "descricao": "Vendedor Verde üü¢", "tipo": "vendedor", "dias_post": 1, "alternado": True, "preco": 15.90},
    {"id_plano": 3, "descricao": "Vendedor Azul üîµ", "tipo": "vendedor", "dias_post": 2, "preco": 7.90},
    {"id_plano": 4, "descricao": "Destacar Vermelho üî¥", "tipo": "destacar", "tags": "ilimitado", "preco": 75.00},
    {"id_plano": 5, "descricao": "Destacar Verde üü¢", "tipo": "destacar", "tags": 2, "posts_necessarios": 10, "preco": 27.80},
    {"id_plano": 6, "descricao": "Destacar Azul üîµ", "tipo": "destacar", "tags": 1, "posts_necessarios": 10, "preco": 17.80},
    {"id_plano": 7, "descricao": "Comprador Vermelho üî¥", "tipo": "comprador", "dias_post": 1, "preco": 24.90},
    {"id_plano": 8, "descricao": "Comprador Verde üü¢", "tipo": "comprador", "dias_post": 2, "posts_por_periodo": 2, "preco": 12.00},
    {"id_plano": 9, "descricao": "Comprador Azul üîµ", "tipo": "comprador", "dias_post": 2, "preco": 9.50},
]

# Configura√ß√µes dos canais
CHANNEL_CONFIG = {
    "rede": "üõírede",
    "recomendacao": "üåürecomenda√ß√£o-do-caveira",
    "destaques": "üíØdestaques",
    "forum_assinaturas": "assinarüåü",
    "categoria_assinaturas": "üìÉüåüAssinaturas"
}

# ================== UTILIT√ÅRIOS JSON ==================
def load_json(path: str, default):
    try:
        with open(path, "r", encoding="utf-8") as f:
            return json.load(f)
    except FileNotFoundError:
        return default
    except json.JSONDecodeError:
        print(f"Erro ao ler {path}, usando valores padr√£o")
        return default

def save_json(path: str, data):
    try:
        with open(path, "w", encoding="utf-8") as f:
            json.dump(data, f, indent=4, ensure_ascii=False)
    except Exception as e:
        print(f"Erro ao salvar {path}: {e}")

def load_planos_db():
    return load_json(DB_FILE, [])

def save_planos_db(data):
    save_json(DB_FILE, data)

def load_payments_db():
    return load_json(PAYMENTS_DB, {})

def save_payments_db(data):
    save_json(PAYMENTS_DB, data)

def load_posts_db():
    return load_json(POST_DB, {})

def save_posts_db(data):
    save_json(POST_DB, data)

# ================== SISTEMA DE F√ìRUM PRIVADO ==================
async def obter_ou_criar_thread_privada(user: discord.Member, guild: discord.Guild):
    """Obt√©m ou cria uma thread privada no f√≥rum de assinaturas para o usu√°rio"""
    try:
        categoria = discord.utils.get(guild.categories, name=CHANNEL_CONFIG["categoria_assinaturas"])
        if not categoria:
            print(f"Categoria {CHANNEL_CONFIG['categoria_assinaturas']} n√£o encontrada")
            return None
        
        forum_channel = discord.utils.get(categoria.channels, name=CHANNEL_CONFIG["forum_assinaturas"])
        if not forum_channel:
            print(f"F√≥rum {CHANNEL_CONFIG['forum_assinaturas']} n√£o encontrado na categoria")
            return None
        
        if not isinstance(forum_channel, discord.ForumChannel):
            print(f"Canal {CHANNEL_CONFIG['forum_assinaturas']} n√£o √© um canal de f√≥rum")
            return None
        
        for thread in forum_channel.threads:
            if thread.name == f"Assinatura - {user.display_name}" or thread.owner_id == user.id:
                return thread
        
        try:
            embed = discord.Embed(
                title=f"üåü Assinatura Privada - {user.display_name}",
                description="Este √© seu espa√ßo privado de assinatura. Apenas voc√™ pode ver e interagir aqui.",
                color=discord.Color.gold()
            )
            embed.add_field(
                name="üìã Como usar:",
                value="‚Ä¢ Use `!status` para ver seus planos\n‚Ä¢ Use `!planos` para comprar novos planos\n‚Ä¢ Este chat √© totalmente privado",
                inline=False
            )
            embed.set_footer(text="Sistema de Assinaturas Privadas")
            
            thread = await forum_channel.create_thread(
                name=f"Assinatura - {user.display_name}",
                content="",
                embed=embed,
                auto_archive_duration=10080,
                slowmode_delay=0
            )
            
            overwrites = {
                guild.default_role: discord.PermissionOverwrite(read_messages=False, send_messages=False),
                user: discord.PermissionOverwrite(read_messages=True, send_messages=True),
                guild.me: discord.PermissionOverwrite(read_messages=True, send_messages=True)
            }
            
            await thread.thread.edit(overwrites=overwrites)
            await thread.thread.add_user(user)
            
            print(f"Thread privada criada para {user.display_name}")
            return thread.thread
            
        except discord.Forbidden:
            print(f"Sem permiss√£o para criar thread no f√≥rum")
            return None
        except Exception as e:
            print(f"Erro ao criar thread: {e}")
            return None
    
    except Exception as e:
        print(f"Erro no sistema de f√≥rum privado: {e}")
        return None

async def garantir_forum_configurado(guild: discord.Guild):
    """Garante que o f√≥rum e categoria est√£o configurados corretamente"""
    try:
        categoria = discord.utils.get(guild.categories, name=CHANNEL_CONFIG["categoria_assinaturas"])
        if not categoria:
            try:
                categoria = await guild.create_category(CHANNEL_CONFIG["categoria_assinaturas"])
                print(f"Categoria {CHANNEL_CONFIG['categoria_assinaturas']} criada")
            except discord.Forbidden:
                print("Sem permiss√£o para criar categoria")
                return False
        
        forum_channel = discord.utils.get(categoria.channels, name=CHANNEL_CONFIG["forum_assinaturas"])
        if not forum_channel:
            try:
                overwrites = {
                    guild.default_role: discord.PermissionOverwrite(
                        read_messages=True, 
                        send_messages=False,
                        create_public_threads=False,
                        create_private_threads=False
                    ),
                    guild.me: discord.PermissionOverwrite(
                        read_messages=True,
                        send_messages=True,
                        create_public_threads=True,
                        create_private_threads=True,
                        manage_threads=True
                    )
                }
                
                forum_channel = await categoria.create_forum(
                    CHANNEL_CONFIG["forum_assinaturas"],
                    topic="F√≥rum de assinaturas privadas - cada usu√°rio tem seu espa√ßo individual",
                    overwrites=overwrites,
                    slowmode_delay=60
                )
                print(f"F√≥rum {CHANNEL_CONFIG['forum_assinaturas']} criado")
            except discord.Forbidden:
                print("Sem permiss√£o para criar f√≥rum")
                return False
            except Exception as e:
                print(f"Erro ao criar f√≥rum: {e}")
                return False
        
        return True
    
    except Exception as e:
        print(f"Erro ao configurar f√≥rum: {e}")
        return False

def pode_postar(user_id: int, tipo_plano: str):
    """Verifica se o usu√°rio pode postar baseado no plano dele - VERS√ÉO ATUALIZADA"""
    db = load_planos_db()
    posts_db = load_posts_db()
    agora = int(time.time())
    
    # Verificar se tem plano ativo
    plano_ativo = None
    for plano in db:
        if (plano["user_id"] == user_id and 
            plano["tipo"] == tipo_plano and 
            plano.get("pago", False) and
            plano.get("data_fim", 0) > agora):
            plano_ativo = plano
            break
    
    if not plano_ativo:
        return False, "Voc√™ n√£o possui um plano ativo do tipo necess√°rio."
    
    # Buscar dados do plano
    plano_info = next((p for p in PLANOS if p["id_plano"] == plano_ativo["id_plano"]), None)
    if not plano_info:
        return False, "Erro: plano n√£o encontrado."
    
    user_posts = posts_db.get(str(user_id), {})
    ultimo_post = user_posts.get(f"ultimo_post_{tipo_plano}", 0)
    
    # VENDEDOR VERDE: Sistema alternado (hoje n√£o, amanh√£ sim)
    if plano_info["id_plano"] == 2:  # Vendedor Verde
        if ultimo_post == 0:  # Primeiro post
            return True, plano_ativo
            
        dias_desde_ultimo = (agora - ultimo_post) // 86400
        if dias_desde_ultimo == 0:  # Mesmo dia do √∫ltimo post
            return False, "Voc√™ pode postar novamente amanh√£ (sistema alternado)."
        elif dias_desde_ultimo >= 1:  # 1+ dias depois - pode postar
            return True, plano_ativo
    
    # COMPRADOR VERDE: 2 posts a cada 2 dias
    elif plano_info["id_plano"] == 8:  # Comprador Verde
        posts_por_periodo = plano_info.get("posts_por_periodo", 2)
        periodo = plano_info.get("dias_post", 2) * 86400  # 2 dias em segundos
        
        posts_no_periodo = user_posts.get(f"posts_periodo_{tipo_plano}", {"inicio": 0, "count": 0})
        
        # Se passou o per√≠odo, resetar contador
        if agora - posts_no_periodo["inicio"] >= periodo:
            posts_no_periodo = {"inicio": agora, "count": 0}
            user_posts[f"posts_periodo_{tipo_plano}"] = posts_no_periodo
            save_posts_db(posts_db)
        
        # Verificar se ainda pode postar no per√≠odo atual
        if posts_no_periodo["count"] >= posts_por_periodo:
            tempo_restante = periodo - (agora - posts_no_periodo["inicio"])
            horas_restantes = tempo_restante // 3600
            return False, f"Voc√™ j√° fez {posts_por_periodo} posts neste per√≠odo. Aguarde {horas_restantes} horas."
        
        return True, plano_ativo
    
    # OUTROS PLANOS: Sistema normal por dias
    else:
        dias_necessarios = plano_info.get("dias_post", 1)
        tempo_espera = dias_necessarios * 86400  # dias em segundos
        
        if agora - ultimo_post < tempo_espera:
            horas_restantes = (tempo_espera - (agora - ultimo_post)) // 3600
            return False, f"Voc√™ pode postar novamente em {horas_restantes} horas."
        
        return True, plano_ativo

def calcular_taxa_cancelamento(data_inicio: int, eh_pagamento_unico: bool = False):
    """Calcula taxa de cancelamento baseada no tempo de uso"""
    agora = int(time.time())
    dias_desde_compra = (agora - data_inicio) // 86400
    
    if eh_pagamento_unico:
        return 1.0  # Pagamento √∫nico sempre 100% de taxa
    
    if dias_desde_compra < 60:  # Menos de 2 meses
        return 1.0  # 100%
    elif dias_desde_compra < 180:  # 2-6 meses  
        return 0.35  # 35%
    elif dias_desde_compra < 180:  # Mais de 6 meses
        return 0.15  # 15%
    else:
        return 0.0  # Sem taxa ap√≥s muito tempo
def pode_usar_destaque(user_id: int):
    """Verifica se o usu√°rio pode usar a tag de destaque - VERS√ÉO ATUALIZADA"""
    db = load_planos_db()
    posts_db = load_posts_db()
    agora = int(time.time())
    
    # Verificar se tem plano ativo de destacar
    plano_destacar = None
    for plano in db:
        if (plano["user_id"] == user_id and 
            plano["tipo"] == "destacar" and 
            plano.get("pago", False) and
            plano.get("data_fim", 0) > agora):
            plano_destacar = plano
            break
    
    if not plano_destacar:
        return False, "Voc√™ precisa de um plano de destaque para usar esta tag."
    
    # Buscar dados do plano
    plano_info = next((p for p in PLANOS if p["id_plano"] == plano_destacar["id_plano"]), None)
    if not plano_info:
        return False, "Erro: plano n√£o encontrado."
    
    # PLANO VERMELHO: ILIMITADO
    if plano_info["id_plano"] == 4:  # Destacar Vermelho
        return True, plano_destacar
    
    user_posts = posts_db.get(str(user_id), {})
    
    # Para planos Verde e Azul de destaque, verificar posts na rede
    if "posts_necessarios" in plano_info:
        posts_rede = user_posts.get("posts_rede", 0)
        destaques_usados = user_posts.get("destaques_usados", 0)
        
        # Calcular quantos destaques pode usar
        destaques_disponiveis = (posts_rede // plano_info["posts_necessarios"]) * plano_info["tags"]
        
        if destaques_usados >= destaques_disponiveis:
            posts_faltantes = plano_info["posts_necessarios"] - (posts_rede % plano_info["posts_necessarios"])
            return False, f"Voc√™ precisa fazer mais {posts_faltantes} posts na üõírede para usar destaque novamente."
    
    return True, plano_destacar

def registrar_post(user_id: int, canal_tipo: str, tem_destaque: bool = False):
    """Registra um post do usu√°rio - VERS√ÉO ATUALIZADA"""
    posts_db = load_posts_db()
    user_posts = posts_db.get(str(user_id), {})
    agora = int(time.time())
    
    # Registrar √∫ltimo post por tipo
    if canal_tipo == "vendedor":
        user_posts["ultimo_post_vendedor"] = agora
        user_posts["posts_rede"] = user_posts.get("posts_rede", 0) + 1
    elif canal_tipo == "comprador":
        user_posts["ultimo_post_comprador"] = agora
        
        # Para comprador verde, atualizar contador do per√≠odo
        db = load_planos_db()
        for plano in db:
            if (plano["user_id"] == user_id and 
                plano["tipo"] == "comprador" and 
                plano.get("pago", False) and
                plano.get("data_fim", 0) > agora):
                
                plano_info = next((p for p in PLANOS if p["id_plano"] == plano["id_plano"]), None)
                if plano_info and plano_info["id_plano"] == 8:  # Comprador Verde
                    posts_no_periodo = user_posts.get("posts_periodo_comprador", {"inicio": 0, "count": 0})
                    posts_no_periodo["count"] += 1
                    user_posts["posts_periodo_comprador"] = posts_no_periodo
                break
    
    # Registrar uso de destaque
    if tem_destaque:
        user_posts["destaques_usados"] = user_posts.get("destaques_usados", 0) + 1
    
    posts_db[str(user_id)] = user_posts
    save_posts_db(posts_db)

async def mover_para_destaques(message: discord.Message):
    """Move uma mensagem com tag de destaque para o canal de destaques"""
    try:
        guild = message.guild
        canal_destaques = discord.utils.get(guild.channels, name=CHANNEL_CONFIG["destaques"])
        
        if not canal_destaques:
            print(f"Canal {CHANNEL_CONFIG['destaques']} n√£o encontrado")
            return
        
        embed = discord.Embed(
            title="üíØ Post em Destaque",
            description=message.content,
            color=discord.Color.gold()
        )
        embed.set_author(name=message.author.display_name, icon_url=message.author.avatar.url if message.author.avatar else None)
        embed.set_footer(text=f"Original em #{message.channel.name}")
        embed.timestamp = message.created_at
        
        if message.attachments:
            embed.set_image(url=message.attachments[0].url)
        
        await canal_destaques.send(embed=embed)
        print(f"Post de {message.author.display_name} movido para destaques")
        
    except Exception as e:
        print(f"Erro ao mover para destaques: {e}")

# ================== MERCADO PAGO ==================
def criar_assinatura_recorrente(plano: dict, user_id: int, username: str):
    """Cria assinatura recorrente mensal (s√≥ cart√£o)"""
    try:
        referencia = f"sub_{plano['id_plano']}_user_{user_id}_{int(time.time())}"
        
        subscription_data = {
            "reason": f"Assinatura {plano['descricao']}",
            "auto_recurring": {
                "frequency": 1,
                "frequency_type": "months",
                "transaction_amount": plano["preco"],
                "currency_id": "BRL"
            },
            "payer_email": f"user{user_id}@discord.bot",
            "card_token_id": "CARD_TOKEN",  # Obtido do frontend
            "status": "authorized",
            "external_reference": referencia
        }
        
        response = sdk.subscription().create(subscription_data)
        
        if response["status"] == 201:
            return response["response"]
        else:
            print(f"Erro ao criar assinatura: {response}")
            return None
            
    except Exception as e:
        print(f"Erro na assinatura recorrente: {e}")
        return None

def cancelar_assinatura_mp(subscription_id: str):
    """Cancela assinatura no Mercado Pago"""
    try:
        response = sdk.subscription().update(subscription_id, {"status": "cancelled"})
        return response["status"] == 200
    except Exception as e:
        print(f"Erro ao cancelar assinatura MP: {e}")
        return False
def gerar_chave_pix_aleatoria():
    import uuid
    return str(uuid.uuid4())

def criar_preferencia_pagamento(plano: dict, user_id: int, username: str):
    try:
        tz_brasil = pytz.timezone('America/Sao_Paulo')
        agora = datetime.now(tz_brasil)
        
        referencia = f"plano_{plano['id_plano']}_user_{user_id}_{int(time.time())}"
        nome_usuario = username[:50] if username else "Usuario Discord"
        
        preference_data = {
            "items": [
                {
                    "title": f"Plano {plano['descricao']}",
                    "quantity": 1,
                    "unit_price": plano["preco"],
                    "currency_id": "BRL",
                    "description": f"Plano {plano['tipo']} - Discord Bot"
                }
            ],
            "payer": {
                "name": nome_usuario,
                "surname": "Discord User"
            },
            "payment_methods": {
                "excluded_payment_methods": [],
                "excluded_payment_types": [],
                "installments": 12
            },
            "back_urls": {
                "success": "https://www.cleitodiscord.com/success",
                "failure": "https://www.cleitodiscord.com/failure", 
                "pending": "https://www.cleitodiscord.com/pending"
            },
            "auto_return": "approved",
            "external_reference": referencia,
            "statement_descriptor": "DISCORD_BOT",
            "expires": True,
            "expiration_date_from": agora.isoformat(),
            "expiration_date_to": (agora + timedelta(hours=24)).isoformat()
        }
        
        preference_response = sdk.preference().create(preference_data)
        
        if preference_response["status"] == 201:
            return preference_response["response"]
        else:
            print(f"Erro ao criar prefer√™ncia: {preference_response}")
            return None
    except Exception as e:
        print(f"Erro ao criar prefer√™ncia de pagamento: {e}")
        return None

def verificar_pagamento_por_referencia(external_reference):
    try:
        filters = {"external_reference": external_reference}
        search_response = sdk.payment().search(filters)
        
        if search_response["status"] == 200:
            results = search_response["response"]["results"]
            if results:
                return results[0]
        elif search_response["status"] == 429:
            print("Rate limit atingido - aguardando...")
            time.sleep(5)
            return None
        else:
            print(f"Erro na busca de pagamento: {search_response}")
        return None
    except Exception as e:
        print(f"Erro ao buscar pagamento: {e}")
        return None

def salvar_preferencia_pendente(preference_data, user_id, plano):
    try:
        payments_db = load_payments_db()
        
        payment_record = {
            "preference_id": preference_data["id"],
            "user_id": user_id,
            "plano": plano,
            "amount": plano["preco"],
            "status": "pending",
            "created_date": preference_data["date_created"],
            "checkout_link": preference_data["init_point"],
            "external_reference": preference_data.get("external_reference")
        }
        
        payments_db[str(preference_data["id"])] = payment_record
        save_payments_db(payments_db)
        return payment_record
    except Exception as e:
        print(f"Erro ao salvar prefer√™ncia pendente: {e}")
        return None

def ativar_plano_apos_pagamento(user_id: int, plano: dict, modalidade: str = "mensal", subscription_id: str = None):
    try:
        db = load_planos_db()
        timestamp = int(time.time())
        duracao = 30 * 86400  # 30 dias
        
        plano_registro = {
            "user_id": user_id,
            "id_plano": plano["id_plano"],
            "descricao": plano["descricao"],
            "tipo": plano["tipo"],
            "pago": True,
            "modalidade": modalidade,
            "data_inicio": timestamp,
            "data_fim": timestamp + duracao,
            "subscription_id": subscription_id,  # Para assinaturas recorrentes
            "cancelado": False
        }
        
        db.append(plano_registro)
        save_planos_db(db)
        return plano_registro
    except Exception as e:
        print(f"Erro ao ativar plano: {e}")
        return None

# ================== ROLES DISCORD ==================
async def ensure_role(guild: discord.Guild, name: str):
    role = discord.utils.get(guild.roles, name=name)
    if not role:
        try:
            role = await guild.create_role(name=name, color=discord.Color.blue())
            print(f"Cargo '{name}' criado no servidor {guild.name}")
        except discord.Forbidden:
            print(f"Sem permiss√£o para criar cargo: {name}")
            return None
        except Exception as e:
            print(f"Erro ao criar cargo {name}: {e}")
            return None
    return role

async def assign_role_to_member(member: discord.Member, tipo: str):
    try:
        role_name = tipo.capitalize()
        role = await ensure_role(member.guild, role_name)
        if role and role not in member.roles:
            await member.add_roles(role)
            print(f"Cargo '{role_name}' atribu√≠do a {member.display_name}")
            return True
        return True
    except discord.Forbidden:
        print(f"Sem permiss√£o para adicionar cargo a {member.display_name}")
        return False
    except Exception as e:
        print(f"Erro ao atribuir cargo: {e}")
        return False

# ================== VIEWS ==================
class StatusPlanoView(View):
    def __init__(self, user_id, planos_ativos):
        super().__init__(timeout=None)  # Permanente
        self.user_id = user_id
        self.planos_ativos = planos_ativos
        self.expandido = False

    @discord.ui.button(label="üëÄ Ver Mais", style=discord.ButtonStyle.secondary)
    async def ver_mais(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.user_id:
            await interaction.response.send_message("‚ùå N√£o √© seu painel.", ephemeral=True)
            return
        
        self.expandido = True
        button.label = "üìÑ Ver Menos"
        button.emoji = "üìÑ"
        
        embed = await self.gerar_embed_expandido()
        await interaction.response.edit_message(embed=embed, view=self)

    async def gerar_embed_expandido(self):
        """Gera embed com informa√ß√µes detalhadas"""
        db = load_planos_db()
        agora = int(time.time())
        
        embed = discord.Embed(
            title=f"üìä Hist√≥rico Completo - {interaction.user.display_name}",
            color=discord.Color.blue()
        )
        
        # Planos ativos
        if self.planos_ativos:
            texto_ativo = ""
            for plano in self.planos_ativos:
                dias_restantes = (plano.get("data_fim", 0) - agora) // 86400
                modalidade = plano.get("modalidade", "mensal")
                data_inicio = datetime.fromtimestamp(plano.get("data_inicio", 0)).strftime("%d/%m/%Y")
                texto_ativo += f"üü¢ **{plano['descricao']}** ({modalidade})\n"
                texto_ativo += f"   üìÖ Iniciado: {data_inicio}\n"
                texto_ativo += f"   ‚è∞ Restam: {dias_restantes} dias\n\n"
            
            embed.add_field(name="‚úÖ Planos Ativos", value=texto_ativo, inline=False)
        
        # Hist√≥rico de cancelamentos
        cancelamentos = []
        for plano in db:
            if (plano["user_id"] == self.user_id and 
                plano.get("cancelado", False)):
                cancelamentos.append(plano)
        
        if cancelamentos:
            texto_cancelado = ""
            for plano in cancelamentos[-5:]:  # √öltimos 5
                data_cancel = datetime.fromtimestamp(plano.get("data_cancelamento", 0)).strftime("%d/%m/%Y")
                taxa = plano.get("taxa_cancelamento", 0)
                modalidade = plano.get("modalidade", "mensal")
                texto_cancelado += f"üî¥ **{plano['descricao']}** ({modalidade})\n"
                texto_cancelado += f"   üìÖ Cancelado: {data_cancel}\n"
                texto_cancelado += f"   üí∞ Taxa: {int(taxa*100)}%\n\n"
            
            embed.add_field(name="‚ùå Cancelamentos (√∫ltimos 5)", value=texto_cancelado, inline=False)
        
        return embed

    @discord.ui.button(label="üóëÔ∏è Cancelar Plano", style=discord.ButtonStyle.danger)
    async def cancelar_plano(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.user_id:
            await interaction.response.send_message("‚ùå N√£o √© seu painel.", ephemeral=True)
            return
        
        if not self.planos_ativos:
            await interaction.response.send_message("‚ùå Nenhum plano ativo para cancelar.", ephemeral=True)
            return
        
        view = CancelarPlanoView(self.planos_ativos)
        embed = discord.Embed(
            title="üóëÔ∏è Cancelar Plano",
            description="Escolha qual plano cancelar:",
            color=discord.Color.orange()
        )
        await interaction.response.send_message(embed=embed, view=view, ephemeral=True)

    @discord.ui.button(label="üõí Comprar Assinaturas", style=discord.ButtonStyle.success)
    async def comprar_assinaturas(self, interaction: discord.Interaction, button: discord.ui.Button):
        # Redirecionar para comando !planos
        embed = discord.Embed(
            title="üõí Comprar Assinaturas",
            description="Use o comando `!planos` para ver todas as op√ß√µes dispon√≠veis.",
            color=discord.Color.green()
        )
        await interaction.response.send_message(embed=embed, ephemeral=True)
class EscolherModalidadeView(View):
    def __init__(self, plano):
        super().__init__(timeout=300)
        self.plano = plano

    @discord.ui.button(label="üí∞ Mensal", style=discord.ButtonStyle.green)
    async def modalidade_mensal(self, interaction: discord.Interaction, button: discord.ui.Button):
        embed = discord.Embed(
            title="üí∞ Assinatura Mensal",
            description=f"**Plano:** {self.plano['descricao']}\n**Pre√ßo:** R$ {self.plano['preco']:.2f}/m√™s",
            color=discord.Color.green()
        )
        embed.add_field(name="‚úÖ Vantagens", value="‚Ä¢ Cobran√ßa autom√°tica todo m√™s\n‚Ä¢ Cancelamento ap√≥s 2 meses sem taxa", inline=False)
        
        view = EscolherPagamentoView(self.plano, "mensal")
        await interaction.response.send_message(embed=embed, view=view, ephemeral=True)

    @discord.ui.button(label="üíé Pagar 1 Vez (+50%)", style=discord.ButtonStyle.blurple)
    async def modalidade_unica(self, interaction: discord.Interaction, button: discord.ui.Button):
        preco_unico = self.plano['preco'] * 1.5
        embed = discord.Embed(
            title="üíé Pagamento √önico",
            description=f"**Plano:** {self.plano['descricao']}\n**Pre√ßo:** R$ {preco_unico:.2f} (√∫nica vez)",
            color=discord.Color.purple()
        )
        embed.add_field(
            name="‚ö†Ô∏è Pol√≠tica de Cancelamento",
            value="‚Ä¢ Antes de 2 meses: 100% de taxa\n‚Ä¢ 2-6 meses: 35% de taxa\n‚Ä¢ Ap√≥s 6 meses: 15% de taxa",
            inline=False
        )
        
        view = EscolherPagamentoView(self.plano, "unico")
        await interaction.response.send_message(embed=embed, view=view, ephemeral=True)
class PagamentoViewCompleta(View):
    def __init__(self, plano):
        super().__init__(timeout=1800)
        self.plano = plano

    @discord.ui.button(label="üí≥ PIX/Cart√£o/D√©bito", style=discord.ButtonStyle.green, emoji="üí∞")
    async def abrir_checkout(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.defer(ephemeral=True)
        
        try:
            preferencia = criar_preferencia_pagamento(self.plano, interaction.user.id, interaction.user.display_name)
            
            if not preferencia:
                await interaction.followup.send("‚ùå Erro ao criar link de pagamento. Tente novamente em alguns minutos.", ephemeral=True)
                return
            
            payment_record = salvar_preferencia_pendente(preferencia, interaction.user.id, self.plano)
            
            if not payment_record:
                await interaction.followup.send("‚ùå Erro interno. Tente novamente.", ephemeral=True)
                return
            
            embed = discord.Embed(
                title="üí≥ Pagamento Criado!",
                description=f"**Plano:** {self.plano['descricao']}\n**Valor:** R$ {self.plano['preco']:.2f}",
                color=discord.Color.green()
            )
            
            embed.add_field(
                name="üí∞ Formas de Pagamento Dispon√≠veis:",
                value="‚Ä¢ PIX (aprova√ß√£o instant√¢nea)\n‚Ä¢ Cart√£o de Cr√©dito (at√© 12x)\n‚Ä¢ Cart√£o de D√©bito",
                inline=False
            )
            
            embed.add_field(
                name="üîó Link para Pagamento:",
                value=f"[**CLIQUE AQUI PARA PAGAR**]({preferencia['init_point']})",
                inline=False
            )
            
            embed.add_field(name="‚è∞ Validade", value="30 minutos", inline=True)
            embed.add_field(name="üîç Status", value="Aguardando pagamento", inline=True)
            
            embed.add_field(
                name="üìã Como pagar:",
                value="1. Clique no link acima\n2. Escolha: PIX, Cart√£o ou D√©bito\n3. Complete o pagamento\n4. Volte aqui e clique 'Verificar Pagamento'",
                inline=False
            )
            
            embed.set_footer(text=f"ID: {preferencia['id']} - Plano ativa ap√≥s confirma√ß√£o")
            
            verificar_view = VerificarPagamentoViewCompleta(preferencia["external_reference"], interaction.user.id, self.plano)
            
            await interaction.followup.send(embed=embed, view=verificar_view, ephemeral=True)
            
        except Exception as e:
            print(f"Erro no checkout: {e}")
            await interaction.followup.send("‚ùå Erro interno. Tente novamente mais tarde.", ephemeral=True)

class VerificarPagamentoViewCompleta(View):
    def __init__(self, external_reference, user_id, plano):
        super().__init__(timeout=1800)
        self.external_reference = external_reference
        self.user_id = user_id
        self.plano = plano

    @discord.ui.button(label="üîÑ Verificar Pagamento", style=discord.ButtonStyle.secondary)
    async def verificar_pagamento_btn(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.defer(ephemeral=True)
        
        try:
            pagamento = verificar_pagamento_por_referencia(self.external_reference)
            
            if not pagamento:
                await interaction.followup.send("‚è≥ Nenhum pagamento encontrado ainda. Se voc√™ acabou de pagar, aguarde alguns minutos.", ephemeral=True)
                return
            
            if pagamento["status"] == "approved":
                plano_ativado = ativar_plano_apos_pagamento(self.user_id, self.plano)
                
                if not plano_ativado:
                    await interaction.followup.send("‚ùå Erro ao ativar plano. Contate o suporte.", ephemeral=True)
                    return
                
                guild_member = interaction.guild.get_member(self.user_id)
                if guild_member:
                    await assign_role_to_member(guild_member, self.plano["tipo"])
                
                embed = discord.Embed(
                    title="‚úÖ PAGAMENTO APROVADO!",
                    description=f"Seu plano **{self.plano['descricao']}** foi ativado com sucesso!",
                    color=discord.Color.green()
                )
                embed.add_field(name="üìÖ Validade", value="30 dias", inline=True)
                embed.add_field(name="üí∞ Valor Pago", value=f"R$ {self.plano['preco']:.2f}", inline=True)
                embed.add_field(name="üéØ Tipo", value=self.plano['tipo'].capitalize(), inline=True)
                
                for item in self.children:
                    item.disabled = True
                
                await interaction.followup.send(embed=embed, view=self)
                
                payments_db = load_payments_db()
                for payment_id, payment_data in payments_db.items():
                    if payment_data.get("external_reference") == self.external_reference:
                        payment_data["status"] = "approved"
                        save_payments_db(payments_db)
                        break
                
            elif pagamento["status"] == "pending":
                await interaction.followup.send("‚è≥ Pagamento ainda processando. Aguarde alguns minutos e tente novamente.", ephemeral=True)
                
            elif pagamento["status"] == "rejected":
                embed = discord.Embed(
                    title="‚ùå Pagamento Rejeitado",
                    description="Seu pagamento foi rejeitado. Tente novamente ou use outro m√©todo.",
                    color=discord.Color.red()
                )
                await interaction.followup.send(embed=embed, ephemeral=True)
                
            else:
                await interaction.followup.send(f"Status: {pagamento['status']}. Continue aguardando ou tente novamente.", ephemeral=True)
        
        except Exception as e:
            print(f"Erro ao verificar pagamento: {e}")
            await interaction.followup.send("‚ùå Erro ao verificar pagamento. Tente novamente.", ephemeral=True)

class ComprarViewCompleta(View):
    def __init__(self, plano):
        super().__init__(timeout=300)
        self.plano = plano

    @discord.ui.button(label="üí∞ Comprar Plano", style=discord.ButtonStyle.green)
    async def comprar_plano(self, interaction: discord.Interaction, button: discord.ui.Button):
        user_id = interaction.user.id
        db = load_planos_db()
        agora = int(time.time())
        
        # Verificar plano ativo do mesmo tipo
        for plano_ativo in db:
            if (plano_ativo["user_id"] == user_id and 
                plano_ativo["tipo"] == self.plano["tipo"] and 
                plano_ativo.get("pago", False) and
                plano_ativo.get("data_fim", 0) > agora and
                not plano_ativo.get("cancelado", False)):
                await interaction.response.send_message(
                    f"‚ùå Voc√™ j√° possui um plano **{self.plano['tipo']}** ativo!", 
                    ephemeral=True
                )
                return
        
        # Mostrar op√ß√µes de modalidade
        embed = discord.Embed(
            title="üõí Escolha a Modalidade",
            description=f"**Plano:** {self.plano['descricao']}",
            color=discord.Color.blue()
        )
        embed.add_field(
            name="üí∞ Mensal (Recorrente)",
            value=f"R$ {self.plano['preco']:.2f}/m√™s\n‚úÖ Renova√ß√£o autom√°tica\n‚úÖ Cancelamento flex√≠vel",
            inline=True
        )
        embed.add_field(
            name="üíé √önico (+50%)",
            value=f"R$ {self.plano['preco'] * 1.5:.2f}\n‚ö†Ô∏è V√°lido 1 m√™s\n‚ö†Ô∏è Taxa de cancelamento",
            inline=True
        )
        
        view = EscolherModalidadeView(self.plano)
        await interaction.response.send_message(embed=embed, view=view, ephemeral=True)

    @discord.ui.button(label="üí∞ Comprar Plano", style=discord.ButtonStyle.green)
    async def comprar_plano(self, interaction: discord.Interaction, button: discord.ui.Button):
        user_id = interaction.user.id
        
        try:
            db = load_planos_db()
            agora = int(time.time())
            
            for plano_ativo in db:
                if (plano_ativo["user_id"] == user_id and 
                    plano_ativo["tipo"] == self.plano["tipo"] and 
                    plano_ativo.get("pago", False) and
                    plano_ativo.get("data_fim", 0) > agora):
                    await interaction.response.send_message(
                        f"‚ùå Voc√™ j√° possui um plano ativo do tipo **{self.plano['tipo']}**!", 
                        ephemeral=True
                    )
                    return
            
            embed = discord.Embed(
                title="üí≥ Finalizar Compra",
                description=f"**Plano:** {self.plano['descricao']}\n**üí∞ Valor:** R$ {self.plano['preco']:.2f}",
                color=discord.Color.blue()
            )
            
            info = f"**Tipo:** {self.plano['tipo'].capitalize()}\n"
            
            if self.plano["id_plano"] == 2:  # Vendedor Verde
                info += "üìÖ **Postagem:** Alternada (hoje n√£o, amanh√£ sim)\n"
            elif self.plano["id_plano"] == 8:  # Comprador Verde
                info += "üìÖ **Postagem:** 2 posts a cada 2 dias\n"
            elif "dias_post" in self.plano:
                if self.plano["dias_post"] == 1:
                    info += "üìÖ **Postagem:** Di√°ria\n"
                else:
                    info += f"üìÖ **Postagem:** A cada {self.plano['dias_post']} dias\n"
            
            if "tags" in self.plano:
                if self.plano["tags"] == "ilimitado":
                    info += "üè∑Ô∏è **Destaques:** Ilimitados\n"
                elif "posts_necessarios" in self.plano:
                    info += f"üè∑Ô∏è **Destaques:** {self.plano['tags']} a cada {self.plano['posts_necessarios']} posts\n"
                else:
                    info += f"üè∑Ô∏è **Tags dispon√≠veis:** {self.plano['tags']}\n"
            
            embed.add_field(name="‚ÑπÔ∏è Detalhes", value=info, inline=False)
            embed.add_field(name="‚è∞ Dura√ß√£o", value="30 dias", inline=True)
            embed.add_field(name="üí≥ Formas de Pagamento", value="PIX, Cart√£o Cr√©dito/D√©bito", inline=True)
            
            embed.set_footer(text="‚ö†Ô∏è Plano s√≥ √© ativado ap√≥s confirma√ß√£o do pagamento!")
            
            pagamento_view = PagamentoViewCompleta(self.plano)
            await interaction.response.send_message(embed=embed, view=pagamento_view, ephemeral=True)
        
        except Exception as e:
            print(f"Erro na compra: {e}")
            await interaction.response.send_message("‚ùå Erro interno. Tente novamente.", ephemeral=True)

class SelecionarPlanoView(View):
    def __init__(self):
        super().__init__(timeout=300)
        
        options = []
        for plano in PLANOS:
            emoji = "üî¥" if "Vermelho" in plano["descricao"] else "üü¢" if "Verde" in plano["descricao"] else "üîµ"
            
            # Descri√ß√£o personalizada para cada plano
            desc = f"Tipo: {plano['tipo'].capitalize()}"
            if plano["id_plano"] == 2:  # Vendedor Verde
                desc += " - Alternado"
            elif plano["id_plano"] == 4:  # Destacar Vermelho  
                desc += " - Ilimitado"
            elif plano["id_plano"] == 8:  # Comprador Verde
                desc += " - 2 posts/2 dias"
            
            options.append(discord.SelectOption(
                label=f"{plano['descricao']} - R$ {plano['preco']:.2f}",
                value=str(plano["id_plano"]),
                emoji=emoji,
                description=desc
            ))
        
        self.select = discord.ui.Select(
            placeholder="Escolha um plano...",
            options=options[:25],
            min_values=1,
            max_values=1
        )
        self.select.callback = self.select_callback
        self.add_item(self.select)
    
    async def select_callback(self, interaction: discord.Interaction):
        selected_id = int(self.select.values[0])
        plano = next((p for p in PLANOS if p["id_plano"] == selected_id), None)
        
        if plano:
            embed = discord.Embed(
                title=f"üí∞ {plano['descricao']}",
                description=f"**Pre√ßo:** R$ {plano['preco']:.2f}\n**Tipo:** {plano['tipo'].capitalize()}",
                color=discord.Color.green()
            )
            
            # Descri√ß√µes espec√≠ficas para cada plano
            if plano["id_plano"] == 2:  # Vendedor Verde
                embed.add_field(name="üìÖ Postagem", value="Alternada (hoje n√£o, amanh√£ sim)", inline=True)
            elif plano["id_plano"] == 8:  # Comprador Verde
                embed.add_field(name="üìÖ Postagem", value="2 posts a cada 2 dias", inline=True)
            elif "dias_post" in plano:
                if plano["dias_post"] == 1:
                    embed.add_field(name="üìÖ Postagem", value="Di√°ria", inline=True)
                else:
                    embed.add_field(name="üìÖ Postagem", value=f"A cada {plano['dias_post']} dias", inline=True)
            
            if "tags" in plano:
                if plano["tags"] == "ilimitado":
                    embed.add_field(name="üè∑Ô∏è Destaques", value="Ilimitados", inline=True)
                elif "posts_necessarios" in plano:
                    embed.add_field(name="üè∑Ô∏è Destaques", value=f"{plano['tags']} a cada {plano['posts_necessarios']} posts", inline=True)
                else:
                    embed.add_field(name="üè∑Ô∏è Tags", value=str(plano["tags"]), inline=True)
            
            embed.add_field(name="‚è∞ Dura√ß√£o", value="30 dias", inline=True)
            embed.set_footer(text="‚ö†Ô∏è Plano s√≥ √© ativado ap√≥s confirma√ß√£o do pagamento!")
            
            view = ComprarViewCompleta(plano)
            await interaction.response.send_message(embed=embed, view=view, ephemeral=True)

# ================== MONITORAMENTO DE MENSAGENS ==================
@bot.event
async def on_message(message):
    """Monitora mensagens para controlar posts e detectar tags de destaque"""
    if message.author.bot:
        return
    
    await bot.process_commands(message)
    
    # Verificar se √© um canal de postagem
    canal_nome = message.channel.name
    user_id = message.author.id
    
    # Post na rede (vendedores)
    if canal_nome == CHANNEL_CONFIG["rede"]:
        pode, resultado = pode_postar(user_id, "vendedor")
        if not pode:
            await message.delete()
            await message.channel.send(
                f"‚ùå {message.author.mention} {resultado}",
                delete_after=10
            )
            return
        
        # Verificar se tem tag de destaque
        tem_destaque = "üíØDestaques" in message.content
        
        if tem_destaque:
            pode_destacar, resultado_destaque = pode_usar_destaque(user_id)
            if not pode_destacar:
                # Remover apenas a tag, n√£o deletar a mensagem
                content_sem_tag = message.content.replace("üíØDestaques", "").strip()
                await message.edit(content=content_sem_tag)
                await message.channel.send(
                    f"‚ö†Ô∏è {message.author.mention} {resultado_destaque} A tag foi removida do seu post.",
                    delete_after=15
                )
                tem_destaque = False
        
        # Registrar o post
        registrar_post(user_id, "vendedor", tem_destaque)
        
        # Mover para destaques se necess√°rio
        if tem_destaque:
            await mover_para_destaques(message)
    
    # Post na recomenda√ß√£o (compradores)
    elif canal_nome == CHANNEL_CONFIG["recomendacao"]:
        pode, resultado = pode_postar(user_id, "comprador")
        if not pode:
            await message.delete()
            await message.channel.send(
                f"‚ùå {message.author.mention} {resultado}",
                delete_after=10
            )
            return
        
        # Compradores n√£o podem usar tag de destaque
        if "üíØDestaques" in message.content:
            content_sem_tag = message.content.replace("üíØDestaques", "").strip()
            await message.edit(content=content_sem_tag)
            await message.channel.send(
                f"‚ö†Ô∏è {message.author.mention} A tag de destaque n√£o √© permitida neste canal.",
                delete_after=10
            )
        
        # Registrar o post
        registrar_post(user_id, "comprador", False)

# ================== VERIFICA√á√ÉO AUTOM√ÅTICA DE PAGAMENTOS ==================
@tasks.loop(minutes=5)
async def verificar_pagamentos_automatico():
    """Verifica pagamentos pendentes automaticamente a cada 5 minutos"""
    await bot.wait_until_ready()
    
    try:
        payments_db = load_payments_db()
        if not payments_db:
            return
        
        for payment_id, payment_data in payments_db.items():
            if payment_data["status"] == "pending":
                external_ref = payment_data.get("external_reference")
                if external_ref:
                    pagamento_atual = verificar_pagamento_por_referencia(external_ref)
                    
                    if pagamento_atual and pagamento_atual["status"] == "approved":
                        user_id = payment_data["user_id"]
                        plano = payment_data["plano"]
                        
                        plano_ativado = ativar_plano_apos_pagamento(user_id, plano)
                        
                        if plano_ativado:
                            user = bot.get_user(user_id)
                            if user:
                                for guild in bot.guilds:
                                    member = guild.get_member(user_id)
                                    if member:
                                        await assign_role_to_member(member, plano["tipo"])
                                        
                                        try:
                                            embed = discord.Embed(
                                                title="‚úÖ PAGAMENTO CONFIRMADO AUTOMATICAMENTE!",
                                                description=f"Seu plano **{plano['descricao']}** foi ativado!",
                                                color=discord.Color.green()
                                            )
                                            embed.add_field(name="üìÖ Validade", value="30 dias", inline=True)
                                            embed.add_field(name="üí∞ Valor", value=f"R$ {plano['preco']:.2f}", inline=True)
                                            
                                            await user.send(embed=embed)
                                        except discord.Forbidden:
                                            print(f"N√£o foi poss√≠vel enviar DM para {user.display_name}")
                                        except Exception as e:
                                            print(f"Erro ao notificar usu√°rio: {e}")
                                        break
                            
                            payments_db[payment_id]["status"] = "approved"
                            save_payments_db(payments_db)
                            
                            print(f"‚úÖ Plano {plano['descricao']} ativado automaticamente para usu√°rio {user_id}")
    
    except Exception as e:
        print(f"Erro na verifica√ß√£o autom√°tica: {e}")

# ================== COMANDOS ==================
@bot.command(name="planos")
async def mostrar_planos(ctx):
    """Mostra todos os planos dispon√≠veis"""
    try:
        embed = discord.Embed(
            title="üíº Planos Dispon√≠veis",
            description="‚ö†Ô∏è **IMPORTANTE:** Planos s√≥ s√£o ativados ap√≥s confirma√ß√£o do pagamento!\n\nüõí Use o menu abaixo para escolher:",
            color=discord.Color.blue()
        )
        
        vendedor_info = ""
        comprador_info = ""
        destacar_info = ""
        
        for plano in PLANOS:
            preco = f"R$ {plano['preco']:.2f}"
            if plano["tipo"] == "vendedor":
                if plano["id_plano"] == 2:  # Verde
                    vendedor_info += f"‚Ä¢ {plano['descricao']}: {preco} (alternado - hoje n√£o, amanh√£ sim)\n"
                elif plano["dias_post"] == 1:
                    vendedor_info += f"‚Ä¢ {plano['descricao']}: {preco} (di√°rio)\n"
                else:
                    vendedor_info += f"‚Ä¢ {plano['descricao']}: {preco} (a cada {plano['dias_post']} dias)\n"
            elif plano["tipo"] == "comprador":
                if plano["id_plano"] == 8:  # Verde
                    comprador_info += f"‚Ä¢ {plano['descricao']}: {preco} (2 posts a cada 2 dias)\n"
                elif plano["dias_post"] == 1:
                    comprador_info += f"‚Ä¢ {plano['descricao']}: {preco} (di√°rio)\n"
                else:
                    comprador_info += f"‚Ä¢ {plano['descricao']}: {preco} (a cada {plano['dias_post']} dias)\n"
            elif plano["tipo"] == "destacar":
                if plano["tags"] == "ilimitado":
                    destacar_info += f"‚Ä¢ {plano['descricao']}: {preco} (destaques ilimitados)\n"
                elif "posts_necessarios" in plano:
                    destacar_info += f"‚Ä¢ {plano['descricao']}: {preco} ({plano['tags']} destaque(s) a cada {plano['posts_necessarios']} posts)\n"
                else:
                    destacar_info += f"‚Ä¢ {plano['descricao']}: {preco} ({plano['tags']} destaque(s))\n"
        
        if vendedor_info:
            embed.add_field(name="üõçÔ∏è Planos Vendedor", value=vendedor_info, inline=True)
        if comprador_info:
            embed.add_field(name="üõí Planos Comprador", value=comprador_info, inline=True)
        if destacar_info:
            embed.add_field(name="‚≠ê Planos Destacar", value=destacar_info, inline=True)
        
        embed.add_field(
            name="üìã Informa√ß√µes dos Canais",
            value=f"‚Ä¢ **Vendedores:** Postem na {CHANNEL_CONFIG['rede']}\n‚Ä¢ **Compradores:** Postem na {CHANNEL_CONFIG['recomendacao']}\n‚Ä¢ **Destaques:** Posts com üíØDestaques v√£o para {CHANNEL_CONFIG['destaques']}",
            inline=False
        )
        
        embed.add_field(
            name="üí≥ Formas de Pagamento",
            value="‚Ä¢ PIX (aprova√ß√£o instant√¢nea)\n‚Ä¢ Cart√£o de Cr√©dito (at√© 12x)\n‚Ä¢ Cart√£o de D√©bito",
            inline=False
        )
        
        view = SelecionarPlanoView()
        await ctx.send(embed=embed, view=view)
        
    except Exception as e:
        print(f"Erro ao mostrar planos: {e}")
        await ctx.send("‚ùå Erro ao carregar planos. Tente novamente.")

@bot.command(name="plano")
async def plano_individual(ctx, id_plano: int = None):
    """Comprar plano espec√≠fico por ID: !plano 1, !plano 2, etc"""
    if id_plano is None:
        embed = discord.Embed(
            title="‚ùì Como usar",
            description="Use: `!plano <n√∫mero>`\n\n**Exemplos:**\n‚Ä¢ `!plano 1` - Vendedor Vermelho\n‚Ä¢ `!plano 2` - Vendedor Verde\n‚Ä¢ `!plano 3` - Vendedor Azul",
            color=discord.Color.orange()
        )
        embed.add_field(
            name="üìã Lista de IDs",
            value="\n".join([f"`{p['id_plano']}` - {p['descricao']}" for p in PLANOS[:5]]) + f"\n\n*Use `!planos` para ver todos*",
            inline=False
        )
        await ctx.send(embed=embed)
        return
    
    plano = next((p for p in PLANOS if p["id_plano"] == id_plano), None)
    if not plano:
        await ctx.send(f"‚ùå Plano {id_plano} n√£o encontrado. Use `!planos` para ver todos os planos dispon√≠veis.")
        return
    
    try:
        embed = discord.Embed(
            title=f"Plano {id_plano}: {plano['descricao']}",
            description=f"**Pre√ßo:** R$ {plano['preco']:.2f}\n**Tipo:** {plano['tipo'].capitalize()}",
            color=discord.Color.blue()
        )
        
        # Descri√ß√µes espec√≠ficas para cada plano
        if plano["id_plano"] == 2:  # Vendedor Verde
            embed.add_field(name="üìÖ Postagem", value="Alternada (hoje n√£o, amanh√£ sim)", inline=True)
        elif plano["id_plano"] == 8:  # Comprador Verde
            embed.add_field(name="üìÖ Postagem", value="2 posts a cada 2 dias", inline=True)
        elif "dias_post" in plano:
            if plano["dias_post"] == 1:
                embed.add_field(name="üìÖ Postagem", value="Di√°ria", inline=True)
            else:
                embed.add_field(name="üìÖ Postagem", value=f"A cada {plano['dias_post']} dias", inline=True)
        
        if "tags" in plano:
            if plano["tags"] == "ilimitado":
                embed.add_field(name="üè∑Ô∏è Destaques", value="Ilimitados", inline=True)
            elif "posts_necessarios" in plano:
                embed.add_field(name="üè∑Ô∏è Destaques", value=f"{plano['tags']} a cada {plano['posts_necessarios']} posts", inline=True)
            else:
                embed.add_field(name="üè∑Ô∏è Tags", value=str(plano["tags"]), inline=True)
        
        embed.add_field(name="‚è∞ Dura√ß√£o", value="30 dias", inline=True)
        embed.set_footer(text="‚ö†Ô∏è Plano s√≥ √© ativado ap√≥s confirma√ß√£o do pagamento!")
        
        view = ComprarViewCompleta(plano)
        await ctx.send(embed=embed, view=view)
        
    except Exception as e:
        print(f"Erro ao mostrar plano individual: {e}")
        await ctx.send("‚ùå Erro interno. Tente novamente.")

@bot.command(name="status")
async def status_usuario(ctx):
    """Mostra status dos planos do usu√°rio"""
    try:
        user_id = ctx.author.id
        db = load_planos_db()
        posts_db = load_posts_db()
        
        embed = discord.Embed(
            title=f"üìä Meus Planos - {ctx.author.display_name}",
            color=discord.Color.blue()
        )
        
        agora = int(time.time())
        planos_encontrados = False
        planos_ativos = []
        planos_expirados = []
        
        for plano in db:
            if plano["user_id"] == user_id and plano.get("pago", False):
                planos_encontrados = True
                fim = plano.get("data_fim", agora)
                
                if agora > fim:
                    planos_expirados.append(plano)
                else:
                    planos_ativos.append(plano)
        
        if planos_ativos:
            ativo_text = ""
            for plano in planos_ativos:
                fim = plano.get("data_fim", agora)
                dias_restantes = (fim - agora) // 86400
                ativo_text += f"‚Ä¢ **{plano['descricao']}**\n  üìÖ {dias_restantes} dias restantes\n  üéØ Tipo: {plano['tipo'].capitalize()}\n\n"
            
            embed.add_field(
                name="‚úÖ Planos Ativos",
                value=ativo_text,
                inline=False
            )
        
        # Mostrar estat√≠sticas de posts para planos de destaque
        user_posts = posts_db.get(str(user_id), {})
        if any(p["tipo"] == "destacar" for p in planos_ativos):
            posts_rede = user_posts.get("posts_rede", 0)
            destaques_usados = user_posts.get("destaques_usados", 0)
            
            embed.add_field(
                name="üìä Estat√≠sticas de Destaque",
                value=f"‚Ä¢ Posts na rede: {posts_rede}\n‚Ä¢ Destaques usados: {destaques_usados}",
                inline=True
            )
        
        # Mostrar estat√≠sticas de posts para comprador verde
        if any(p["id_plano"] == 8 for p in planos_ativos):  # Comprador Verde
            posts_periodo = user_posts.get("posts_periodo_comprador", {"count": 0})
            embed.add_field(
                name="üìä Posts no Per√≠odo Atual",
                value=f"‚Ä¢ Posts usados: {posts_periodo.get('count', 0)}/2",
                inline=True
            )
        
        if planos_expirados:
            expirado_text = ""
            for plano in planos_expirados[-3:]:
                expirado_text += f"‚Ä¢ {plano['descricao']}\n"
            
            embed.add_field(
                name="‚ùå Planos Expirados (√∫ltimos 3)",
                value=expirado_text,
                inline=False
            )
        
        if not planos_encontrados:
            embed.description = "Nenhum plano ativo encontrado.\n\nüõçÔ∏è Use `!planos` para ver as op√ß√µes dispon√≠veis!"
            embed.color = discord.Color.orange()
        
        embed.add_field(
            name="üìã Comandos √öteis",
            value="‚Ä¢ `!planos` - Ver todos os planos\n‚Ä¢ `!plano <id>` - Comprar plano espec√≠fico\n‚Ä¢ `!ajuda` - Todos os comandos",
            inline=False
        )
        
        await ctx.send(embed=embed)
        
    except Exception as e:
        print(f"Erro ao mostrar status: {e}")
        await ctx.send("‚ùå Erro ao verificar status. Tente novamente.")

@bot.command(name="ajuda", aliases=["help"])
async def ajuda(ctx):
    """Comandos dispon√≠veis"""
    embed = discord.Embed(
        title="ü§ñ Central de Ajuda - Discord Bot",
        description="Sistema completo de planos com pagamentos reais via Mercado Pago",
        color=discord.Color.green()
    )
    
    embed.add_field(
        name="üõçÔ∏è Comandos de Compra",
        value="‚Ä¢ `!planos` - Ver todos os planos dispon√≠veis\n‚Ä¢ `!plano <id>` - Comprar plano espec√≠fico (ex: `!plano 1`)\n‚Ä¢ `!status` - Ver seus planos ativos",
        inline=False
    )
    
    embed.add_field(
        name="üåü Sistema Privado",
        value="‚Ä¢ `!assinatura` - Acessar seu espa√ßo privado de assinatura\n‚Ä¢ `!assinar` - Alias para o comando acima\n‚Ä¢ `!privado` - Outro alias para privacidade",
        inline=False
    )
    
    embed.add_field(
        name="üìã Tipos de Planos ATUALIZADOS",
        value=f"‚Ä¢ **Vendedor** - Para postar na {CHANNEL_CONFIG['rede']}\n  - Verde: Alternado (hoje n√£o, amanh√£ sim)\n  - Vermelho: Di√°rio\n  - Azul: A cada 2 dias\n‚Ä¢ **Comprador** - Para postar na {CHANNEL_CONFIG['recomendacao']}\n  - Verde: 2 posts a cada 2 dias\n  - Vermelho: Di√°rio\n  - Azul: A cada 2 dias\n‚Ä¢ **Destacar** - Para usar a tag üíØDestaques\n  - Vermelho: Ilimitado\n  - Verde/Azul: Baseado em posts",
        inline=False
    )
    
    embed.add_field(
        name="üè∑Ô∏è Sistema de Destaques",
        value=f"‚Ä¢ Tag **üíØDestaques** s√≥ funciona na {CHANNEL_CONFIG['rede']}\n‚Ä¢ Posts destacados aparecem automaticamente no {CHANNEL_CONFIG['destaques']}\n‚Ä¢ **Vermelho:** Ilimitado\n‚Ä¢ **Verde:** 2 destaques a cada 10 posts\n‚Ä¢ **Azul:** 1 destaque a cada 10 posts",
        inline=False
    )
    
    embed.add_field(
        name="üîí Privacidade Garantida",
        value=f"‚Ä¢ Use `!assinatura` para acessar seu espa√ßo privado\n‚Ä¢ Localizado na categoria **{CHANNEL_CONFIG['categoria_assinaturas']}**\n‚Ä¢ Apenas voc√™ pode ver suas conversas\n‚Ä¢ Todos os comandos funcionam no espa√ßo privado",
        inline=False
    )
    
    embed.add_field(
        name="üí≥ Formas de Pagamento",
        value="‚Ä¢ **PIX** - Aprova√ß√£o instant√¢nea\n‚Ä¢ **Cart√£o de Cr√©dito** - At√© 12x sem juros\n‚Ä¢ **Cart√£o de D√©bito** - Aprova√ß√£o r√°pida",
        inline=True
    )
    
    embed.add_field(
        name="‚ö° Processo de Compra",
        value="1. Use `!assinatura` para privacidade\n2. Escolha o plano com `!planos`\n3. Efetue o pagamento\n4. Aguarde confirma√ß√£o autom√°tica\n5. Plano ativado!",
        inline=True
    )
    
    embed.add_field(
        name="‚è∞ Informa√ß√µes Importantes",
        value="‚Ä¢ **Dura√ß√£o:** Todos os planos duram 30 dias\n‚Ä¢ **Ativa√ß√£o:** Autom√°tica ap√≥s pagamento confirmado\n‚Ä¢ **Verifica√ß√£o:** Sistema verifica pagamentos a cada 5 minutos\n‚Ä¢ **Cooldown:** Respeitado automaticamente conforme plano",
        inline=False
    )
    
    embed.set_footer(text="üí° Dica: Use !assinatura para come√ßar com privacidade!")
    
    await ctx.send(embed=embed)

@bot.command(name="limpar", aliases=["clear"])
@commands.has_permissions(manage_messages=True)
async def limpar_planos_expirados(ctx, confirmar: str = None):
    """Remove planos expirados do banco de dados (apenas administradores)"""
    if confirmar != "SIM":
        embed = discord.Embed(
            title="‚ö†Ô∏è Confirma√ß√£o Necess√°ria",
            description="Este comando ir√° remover TODOS os planos expirados do banco de dados.\n\nPara confirmar, use: `!limpar SIM`",
            color=discord.Color.orange()
        )
        await ctx.send(embed=embed)
        return
    
    try:
        db = load_planos_db()
        agora = int(time.time())
        
        planos_ativos = []
        removidos = 0
        
        for plano in db:
            fim = plano.get("data_fim", 0)
            if fim > agora:
                planos_ativos.append(plano)
            else:
                removidos += 1
        
        save_planos_db(planos_ativos)
        
        embed = discord.Embed(
            title="üßπ Limpeza Conclu√≠da",
            description=f"**{removidos}** planos expirados foram removidos.\n**{len(planos_ativos)}** planos ativos mantidos.",
            color=discord.Color.green()
        )
        
        await ctx.send(embed=embed)
        
    except Exception as e:
        print(f"Erro na limpeza: {e}")
        await ctx.send("‚ùå Erro ao limpar banco de dados.")

@bot.command(name="assinatura", aliases=["assinar", "privado"])
async def acessar_assinatura_privada(ctx):
    """Cria ou acessa seu espa√ßo privado de assinatura"""
    try:
        # Configurar f√≥rum se necess√°rio
        forum_configurado = await garantir_forum_configurado(ctx.guild)
        if not forum_configurado:
            await ctx.send("‚ùå Erro ao configurar sistema de f√≥rum. Contate um administrador.", delete_after=10)
            return
        
        # Obter ou criar thread privada
        thread_privada = await obter_ou_criar_thread_privada(ctx.author, ctx.guild)
        
        if not thread_privada:
            await ctx.send("‚ùå Erro ao criar/acessar seu espa√ßo privado. Tente novamente.", delete_after=10)
            return
        
        # Resposta p√∫blica tempor√°ria
        embed = discord.Embed(
            title="‚úÖ Espa√ßo Privado Criado!",
            description=f"Seu espa√ßo privado de assinatura foi criado!\n\nüîó **Acesse:** {thread_privada.mention}",
            color=discord.Color.green()
        )
        embed.add_field(
            name="üîí Privacidade",
            value="‚Ä¢ Apenas voc√™ pode ver e interagir\n‚Ä¢ Comandos do bot funcionam normalmente\n‚Ä¢ Totalmente confidencial",
            inline=False
        )
        embed.set_footer(text="Esta mensagem ser√° deletada em 15 segundos")
        
        await ctx.send(embed=embed, delete_after=15)
        
        # Deletar comando do usu√°rio por privacidade
        try:
            await ctx.message.delete()
        except discord.NotFound:
            pass
        
        # Mensagem de boas-vindas na thread privada
        if thread_privada.message_count <= 1:  # Se √© nova thread
            welcome_embed = discord.Embed(
                title="üéâ Bem-vindo ao seu espa√ßo privado!",
                description="Este √© seu ambiente privado para gerenciar assinaturas e planos.",
                color=discord.Color.blue()
            )
            welcome_embed.add_field(
                name="üõçÔ∏è Comandos Dispon√≠veis:",
                value="‚Ä¢ `!planos` - Ver planos dispon√≠veis\n‚Ä¢ `!status` - Seus planos ativos\n‚Ä¢ `!plano <id>` - Comprar plano espec√≠fico",
                inline=False
            )
            welcome_embed.add_field(
                name="üîí Privacidade Garantida:",
                value="‚Ä¢ Ningu√©m mais pode ver este chat\n‚Ä¢ Seus dados est√£o seguros\n‚Ä¢ Pagamentos processados com seguran√ßa",
                inline=False
            )
            
            await thread_privada.send(embed=welcome_embed)
        
    except Exception as e:
        print(f"Erro no comando assinatura: {e}")
        await ctx.send("‚ùå Erro interno. Tente novamente.", delete_after=5)

@bot.command(name="stats")
@commands.has_permissions(administrator=True)
async def estatisticas_bot(ctx):
    """Mostra estat√≠sticas do bot (apenas administradores)"""
    try:
        db = load_planos_db()
        payments_db = load_payments_db()
        posts_db = load_posts_db()
        agora = int(time.time())
        
        planos_ativos = 0
        planos_expirados = 0
        total_arrecadado = 0
        pagamentos_pendentes = 0
        
        for plano in db:
            fim = plano.get("data_fim", 0)
            if fim > agora:
                planos_ativos += 1
            else:
                planos_expirados += 1
        
        for payment_data in payments_db.values():
            if payment_data["status"] == "approved":
                total_arrecadado += payment_data.get("amount", 0)
            elif payment_data["status"] == "pending":
                pagamentos_pendentes += 1
        
        tipos = {"vendedor": 0, "comprador": 0, "destacar": 0}
        for plano in db:
            if plano.get("data_fim", 0) > agora:
                tipo = plano.get("tipo", "")
                if tipo in tipos:
                    tipos[tipo] += 1
        
        total_posts_rede = sum(user_data.get("posts_rede", 0) for user_data in posts_db.values())
        total_destaques = sum(user_data.get("destaques_usados", 0) for user_data in posts_db.values())
        
        embed = discord.Embed(
            title="üìä Estat√≠sticas do Bot",
            color=discord.Color.blue()
        )
        
        embed.add_field(
            name="üìà Planos",
            value=f"**Ativos:** {planos_ativos}\n**Expirados:** {planos_expirados}\n**Total:** {planos_ativos + planos_expirados}",
            inline=True
        )
        
        embed.add_field(
            name="üí∞ Financeiro",
            value=f"**Arrecadado:** R$ {total_arrecadado:.2f}\n**Pendentes:** {pagamentos_pendentes}",
            inline=True
        )
        
        embed.add_field(
            name="üéØ Por Tipo (Ativos)",
            value=f"**Vendedor:** {tipos['vendedor']}\n**Comprador:** {tipos['comprador']}\n**Destacar:** {tipos['destacar']}",
            inline=True
        )
        
        embed.add_field(
            name="üìä Atividade",
            value=f"**Posts na rede:** {total_posts_rede}\n**Destaques usados:** {total_destaques}",
            inline=True
        )
        
        embed.add_field(
            name="ü§ñ Bot Info",
            value=f"**Servidores:** {len(bot.guilds)}\n**Usu√°rios:** {len(set(bot.get_all_members()))}",
            inline=True
        )
        
        embed.set_footer(text=f"√öltima verifica√ß√£o: {datetime.now().strftime('%d/%m/%Y %H:%M')}")
        
        await ctx.send(embed=embed)
        
    except Exception as e:
        print(f"Erro nas estat√≠sticas: {e}")
        await ctx.send("‚ùå Erro ao gerar estat√≠sticas.")

# ================== EVENTOS ==================
@bot.event
async def on_ready():
    print(f"ü§ñ {bot.user} est√° online!")
    print(f"üìä Conectado a {len(bot.guilds)} servidor(s)")
    print(f"üë• Alcan√ßando {len(set(bot.get_all_members()))} usu√°rios √∫nicos")
    print(f"üí≥ Mercado Pago integrado - Sistema de cobran√ßa REAL ativo")
    print(f"‚ö†Ô∏è  Planos s√≥ s√£o ativados ap√≥s confirma√ß√£o de pagamento!")
    print(f"üè∑Ô∏è  Sistema de destaques integrado com canais: {CHANNEL_CONFIG}")
    print("üîÑ PLANOS ATUALIZADOS:")
    print("   ‚Ä¢ Vendedor Verde: Alternado (hoje n√£o, amanh√£ sim)")
    print("   ‚Ä¢ Comprador Verde: 2 posts a cada 2 dias")
    print("   ‚Ä¢ Destacar Vermelho: Ilimitado")
    
    if not verificar_pagamentos_automatico.is_running():
        verificar_pagamentos_automatico.start()
        print("üîÑ Verifica√ß√£o autom√°tica de pagamentos iniciada (a cada 5 minutos)")

@bot.event
async def on_command_error(ctx, error):
    """Tratamento de erros dos comandos"""
    if isinstance(error, commands.CommandNotFound):
        embed = discord.Embed(
            title="‚ùì Comando n√£o encontrado",
            description=f"O comando `{ctx.message.content}` n√£o existe.\n\nUse `!ajuda` para ver todos os comandos dispon√≠veis.",
            color=discord.Color.orange()
        )
        await ctx.send(embed=embed, delete_after=10)
    
    elif isinstance(error, commands.MissingPermissions):
        await ctx.send("‚ùå Voc√™ n√£o tem permiss√£o para usar este comando.", delete_after=5)
    
    elif isinstance(error, commands.BadArgument):
        await ctx.send("‚ùå Argumento inv√°lido. Verifique o comando e tente novamente.", delete_after=5)
    
    else:
        print(f"Erro no comando {ctx.command}: {error}")
        await ctx.send("‚ùå Erro interno. Tente novamente mais tarde.", delete_after=5)

@bot.event
async def on_guild_join(guild):
    """Quando o bot entra em um servidor novo"""
    print(f"‚ûï Bot adicionado ao servidor: {guild.name} (ID: {guild.id})")
    
    # Configurar f√≥rum automaticamente
    await garantir_forum_configurado(guild)
    
    for channel in guild.text_channels:
        if channel.permissions_for(guild.me).send_messages:
            embed = discord.Embed(
                title="üéâ Obrigado por me adicionar!",
                description="Sou um bot de **venda de planos** com pagamentos reais via Mercado Pago!",
                color=discord.Color.green()
            )
            
            embed.add_field(
                name="üöÄ Como come√ßar",
                value="‚Ä¢ `!ajuda` - Ver todos os comandos\n‚Ä¢ `!assinatura` - Acessar espa√ßo privado\n‚Ä¢ `!planos` - Ver planos dispon√≠veis\n‚Ä¢ `!status` - Verificar seus planos",
                inline=False
            )
            
            embed.add_field(
                name="üîí Sistema Privado",
                value="‚Ä¢ Use `!assinatura` para ter privacidade total\n‚Ä¢ Cada usu√°rio tem seu espa√ßo individual\n‚Ä¢ Ningu√©m pode ver suas conversas ou compras",
                inline=False
            )
            
            embed.add_field(
                name="üí≥ Sobre os Pagamentos",
                value="‚Ä¢ Pagamentos **100% reais** via Mercado Pago\n‚Ä¢ PIX, Cart√£o de Cr√©dito e D√©bito\n‚Ä¢ Ativa√ß√£o autom√°tica ap√≥s confirma√ß√£o",
                inline=False
            )
            
            embed.add_field(
                name="üè∑Ô∏è Configura√ß√£o dos Canais",
                value=f"‚Ä¢ Crie o canal **{CHANNEL_CONFIG['rede']}** para vendedores\n‚Ä¢ Crie o canal **{CHANNEL_CONFIG['recomendacao']}** para compradores\n‚Ä¢ Crie o canal **{CHANNEL_CONFIG['destaques']}** para posts destacados\n‚Ä¢ Categoria **{CHANNEL_CONFIG['categoria_assinaturas']}** criada automaticamente",
                inline=False
            )
            
            embed.add_field(
                name="üÜï PLANOS ATUALIZADOS",
                value="‚Ä¢ **Vendedor Verde:** Alternado (hoje n√£o, amanh√£ sim)\n‚Ä¢ **Comprador Verde:** 2 posts a cada 2 dias\n‚Ä¢ **Destacar Vermelho:** Destaques ilimitados",
                inline=False
            )
            
            embed.set_footer(text="Digite !assinatura para come√ßar com total privacidade!")
            
            try:
                await channel.send(embed=embed)
                break
            except discord.Forbidden:
                continue

@bot.event
async def on_member_join(member):
    """Quando um usu√°rio entra no servidor"""
    try:
        db = load_planos_db()
        agora = int(time.time())
        
        for plano in db:
            if (plano["user_id"] == member.id and 
                plano.get("pago", False) and 
                plano.get("data_fim", 0) > agora):
                
                await assign_role_to_member(member, plano["tipo"])
                print(f"Cargo {plano['tipo']} reatribu√≠do para {member.display_name}")
                
    except Exception as e:
        print(f"Erro ao reatribuir cargos para {member.display_name}: {e}")

# ================== INICIALIZA√á√ÉO ==================
if __name__ == "__main__":
    print("üöÄ Iniciando Discord Bot...")
    print("üí≥ Sistema de cobran√ßa REAL ativo via Mercado Pago")
    print("‚ö†Ô∏è  IMPORTANTE: Planos s√≥ s√£o ativados ap√≥s confirma√ß√£o de pagamento!")
    print("üîÑ Verifica√ß√£o autom√°tica de pagamentos a cada 5 minutos")
    print(f"üè∑Ô∏è Canais configurados: {CHANNEL_CONFIG}")
    print("üÜï ATUALIZA√á√ïES DOS PLANOS:")
    print("   ‚Ä¢ Vendedor Verde: Sistema alternado")
    print("   ‚Ä¢ Comprador Verde: 2 posts a cada 2 dias")
    print("   ‚Ä¢ Destacar Vermelho: Destaques ilimitados")
    print("=" * 60)
    
    if not DISCORD_TOKEN:
        print("‚ùå DISCORD_TOKEN n√£o encontrado no arquivo .env!")
        exit(1)
    
    if not ML_TOKEN:
        print("‚ùå ML_TOKEN n√£o encontrado no arquivo .env!")
        exit(1)
    
    if ML_TOKEN.startswith("APP_USR"):
        print("üö® ATEN√á√ÉO: Usando tokens de PRODU√á√ÉO - Cobran√ßas ser√£o REAIS!")
    elif ML_TOKEN.startswith("TEST"):
        print("üß™ Usando tokens de TESTE - Ambiente de desenvolvimento")
    else:
        print("‚ö†Ô∏è  Token do Mercado Pago n√£o identificado")
    
    try:
        bot.run(DISCORD_TOKEN)
    except discord.LoginFailure:
        print("‚ùå TOKEN do Discord inv√°lido! Verifique o arquivo .env")
    except discord.HTTPException as e:
        print(f"‚ùå Erro HTTP: {e}")
    except KeyboardInterrupt:
        print("\nüëã Bot encerrado pelo usu√°rio")
    except Exception as e:
        print(f"‚ùå Erro inesperado ao iniciar bot: {e}")
    finally:
        print("üî¥ Bot desconectado")
        # ================== MONITORAMENTO DE MENSAGENS ==================
@bot.event
async def on_message(message):
    """Monitora mensagens para controlar posts e detectar tags de destaque"""
    if message.author.bot:
        return
    
    await bot.process_commands(message)
    
    # Verificar se √© um canal de postagem
    canal_nome = message.channel.name
    user_id = message.author.id
    
    # Post na rede (vendedores)
    if canal_nome == CHANNEL_CONFIG["rede"]:
        pode, resultado = pode_postar(user_id, "vendedor")
        if not pode:
            await message.delete()
            await message.channel.send(
                f"‚ùå {message.author.mention} {resultado}",
                delete_after=10
            )
            return
        
        # Verificar se tem tag de destaque
        tem_destaque = "üíØDestaques" in message.content
        
        if tem_destaque:
            pode_destacar, resultado_destaque = pode_usar_destaque(user_id)
            if not pode_destacar:
                content_sem_tag = message.content.replace("üíØDestaques", "").strip()
                await message.edit(content=content_sem_tag)
                await message.channel.send(
                    f"‚ö†Ô∏è {message.author.mention} {resultado_destaque} A tag foi removida do seu post.",
                    delete_after=15
                )
                tem_destaque = False
        
        # Registrar o post
        registrar_post(user_id, "vendedor", tem_destaque)
        
        # Mover para destaques se necess√°rio
        if tem_destaque:
            await mover_para_destaques(message)
    
    # Post na recomenda√ß√£o (compradores)
    elif canal_nome == CHANNEL_CONFIG["recomendacao"]:
        pode, resultado = pode_postar(user_id, "comprador")
        if not pode:
            await message.delete()
            await message.channel.send(
                f"‚ùå {message.author.mention} {resultado}",
                delete_after=10
            )
            return
        
        # Compradores n√£o podem usar tag de destaque
        if "üíØDestaques" in message.content:
            content_sem_tag = message.content.replace("üíØDestaques", "").strip()
            await message.edit(content=content_sem_tag)
            await message.channel.send(
                f"‚ö†Ô∏è {message.author.mention} A tag de destaque n√£o √© permitida neste canal.",
                delete_after=10
            )
        
        # Registrar o post
        registrar_post(user_id, "comprador", False)

# ================== VERIFICA√á√ÉO AUTOM√ÅTICA DE PAGAMENTOS ==================
@tasks.loop(minutes=5)
async def verificar_pagamentos_automatico():
    """Verifica pagamentos pendentes automaticamente a cada 5 minutos"""
    await bot.wait_until_ready()
    
    try:
        # Verificar pagamentos de cart√£o
        payments_db = load_payments_db()
        if payments_db:
            for payment_id, payment_data in payments_db.items():
                if payment_data["status"] == "pending":
                    external_ref = payment_data.get("external_reference")
                    if external_ref:
                        pagamento_atual = verificar_pagamento_por_referencia(external_ref)
                        
                        if pagamento_atual and pagamento_atual["status"] == "approved":
                            user_id = payment_data["user_id"]
                            plano = payment_data["plano"]
                            modalidade = external_ref.split("_")[-1] if "_" in external_ref else "mensal"
                            
                            plano_ativado = ativar_plano_apos_pagamento(user_id, plano, modalidade)
                            
                            if plano_ativado:
                                user = bot.get_user(user_id)
                                if user:
                                    for guild in bot.guilds:
                                        member = guild.get_member(user_id)
                                        if member:
                                            await assign_role_to_member(member, plano["tipo"])
                                            
                                            try:
                                                embed = discord.Embed(
                                                    title="‚úÖ PAGAMENTO CONFIRMADO AUTOMATICAMENTE!",
                                                    description=f"Seu plano **{plano['descricao']}** foi ativado!",
                                                    color=discord.Color.green()
                                                )
                                                embed.add_field(name="üìÖ Validade", value="30 dias", inline=True)
                                                embed.add_field(name="üéØ Modalidade", value=modalidade.capitalize(), inline=True)
                                                
                                                await user.send(embed=embed)
                                            except discord.Forbidden:
                                                print(f"N√£o foi poss√≠vel enviar DM para {user.display_name}")
                                            except Exception as e:
                                                print(f"Erro ao notificar usu√°rio: {e}")
                                            break
                                
                                payments_db[payment_id]["status"] = "approved"
                                save_payments_db(payments_db)
                                
                                print(f"‚úÖ Plano {plano['descricao']} ativado automaticamente para usu√°rio {user_id}")
        
        # Verificar pagamentos PIX
        pix_db = load_pix_db()
        if pix_db:
            for payment_id, pix_data in pix_db.items():
                if pix_data["status"] == "pending":
                    pagamento_pix = verificar_pagamento_pix(payment_id)
                    
                    if pagamento_pix and pagamento_pix["status"] == "approved":
                        user_id = pix_data["user_id"]
                        plano = pix_data["plano"]
                        modalidade = pix_data["modalidade"]
                        
                        plano_ativado = ativar_plano_apos_pagamento(user_id, plano, modalidade)
                        
                        if plano_ativado:
                            user = bot.get_user(user_id)
                            if user:
                                for guild in bot.guilds:
                                    member = guild.get_member(user_id)
                                    if member:
                                        await assign_role_to_member(member, plano["tipo"])
                                        
                                        try:
                                            embed = discord.Embed(
                                                title="‚úÖ PIX CONFIRMADO AUTOMATICAMENTE!",
                                                description=f"Seu plano **{plano['descricao']}** foi ativado!",
                                                color=discord.Color.green()
                                            )
                                            embed.add_field(name="üìÖ Validade", value="30 dias", inline=True)
                                            embed.add_field(name="üéØ Modalidade", value=modalidade.capitalize(), inline=True)
                                            embed.add_field(name="üí∞ Valor", value=f"R$ {pix_data['amount']:.2f}", inline=True)
                                            
                                            await user.send(embed=embed)
                                        except discord.Forbidden:
                                            print(f"N√£o foi poss√≠vel enviar DM para {user.display_name}")
                                        except Exception as e:
                                            print(f"Erro ao notificar usu√°rio: {e}")
                                        break
                            
                            pix_db[payment_id]["status"] = "approved"
                            save_pix_db(pix_db)
                            
                            print(f"‚úÖ Plano PIX {plano['descricao']} ativado automaticamente para usu√°rio {user_id}")
    
    except Exception as e:
        print(f"Erro na verifica√ß√£o autom√°tica: {e}")

# ================== COMANDOS ==================
@bot.command(name="planos")
async def mostrar_planos(ctx):
    """Mostra todos os planos dispon√≠veis"""
    try:
        embed = discord.Embed(
            title="üíº Planos Dispon√≠veis",
            description="üõçÔ∏è Escolha entre **Mensal** ou **Pagamento √önico (+50%)**\n\nüõí Use o menu abaixo para escolher:",
            color=discord.Color.blue()
        )
        
        vendedor_info = ""
        comprador_info = ""
        destacar_info = ""
        
        for plano in PLANOS:
            preco = f"R$ {plano['preco']:.2f}"
            preco_unico = f"R$ {plano['preco'] * 1.5:.2f}"
            
            if plano["tipo"] == "vendedor":
                if plano["id_plano"] == 2:
                    vendedor_info += f"‚Ä¢ {plano['descricao']}: {preco} | {preco_unico} (alternado)\n"
                elif plano["dias_post"] == 1:
                    vendedor_info += f"‚Ä¢ {plano['descricao']}: {preco} | {preco_unico} (di√°rio)\n"
                else:
                    vendedor_info += f"‚Ä¢ {plano['descricao']}: {preco} | {preco_unico} (a cada {plano['dias_post']} dias)\n"
            elif plano["tipo"] == "comprador":
                if plano["id_plano"] == 8:
                    comprador_info += f"‚Ä¢ {plano['descricao']}: {preco} | {preco_unico} (2 posts/2 dias)\n"
                elif plano["dias_post"] == 1:
                    comprador_info += f"‚Ä¢ {plano['descricao']}: {preco} | {preco_unico} (di√°rio)\n"
                else:
                    comprador_info += f"‚Ä¢ {plano['descricao']}: {preco} | {preco_unico} (a cada {plano['dias_post']} dias)\n"
            elif plano["tipo"] == "destacar":
                if plano["tags"] == "ilimitado":
                    destacar_info += f"‚Ä¢ {plano['descricao']}: {preco} | {preco_unico} (ilimitado)\n"
                elif "posts_necessarios" in plano:
                    destacar_info += f"‚Ä¢ {plano['descricao']}: {preco} | {preco_unico} ({plano['tags']} a cada {plano['posts_necessarios']} posts)\n"
        
        if vendedor_info:
            embed.add_field(name="üõçÔ∏è Vendedor (Mensal | √önico)", value=vendedor_info, inline=True)
        if comprador_info:
            embed.add_field(name="üõí Comprador (Mensal | √önico)", value=comprador_info, inline=True)
        if destacar_info:
            embed.add_field(name="‚≠ê Destacar (Mensal | √önico)", value=destacar_info, inline=True)
        
        embed.add_field(
            name="üíé Pagamento √önico",
            value="‚Ä¢ 50% a mais no valor\n‚Ä¢ V√°lido por 1 m√™s\n‚Ä¢ Taxa de cancelamento antes de 2 meses: 100%",
            inline=False
        )
        
        embed.add_field(
            name="üí≥ Formas de Pagamento",
            value="‚Ä¢ **PIX** - Confirma√ß√£o r√°pida\n‚Ä¢ **Cart√£o** - Cr√©dito/D√©bito (at√© 12x)",
            inline=False
        )
        
        view = SelecionarPlanoView()
        await ctx.send(embed=embed, view=view)
        
    except Exception as e:
        print(f"Erro ao mostrar planos: {e}")
        await ctx.send("‚ùå Erro ao carregar planos. Tente novamente.")

@bot.command(name="plano")
async def plano_individual(ctx, id_plano: int = None):
    """Comprar plano espec√≠fico por ID"""
    if id_plano is None:
        embed = discord.Embed(
            title="‚ùì Como usar",
            description="Use: `!plano <n√∫mero>`\n\n**Exemplos:**\n‚Ä¢ `!plano 1` - Vendedor Vermelho\n‚Ä¢ `!plano 2` - Vendedor Verde",
            color=discord.Color.orange()
        )
        embed.add_field(
            name="üìã Lista de IDs",
            value="\n".join([f"`{p['id_plano']}` - {p['descricao']}" for p in PLANOS[:5]]) + "\n\n*Use `!planos` para ver todos*",
            inline=False
        )
        await ctx.send(embed=embed)
        return
    
    plano = next((p for p in PLANOS if p["id_plano"] == id_plano), None)
    if not plano:
        await ctx.send(f"‚ùå Plano {id_plano} n√£o encontrado. Use `!planos` para ver todos os planos dispon√≠veis.")
        return
    
    try:
        embed = discord.Embed(
            title=f"Plano {id_plano}: {plano['descricao']}",
            description=f"**Mensal:** R$ {plano['preco']:.2f}\n**√önico:** R$ {plano['preco'] * 1.5:.2f} (+50%)\n**Tipo:** {plano['tipo'].capitalize()}",
            color=discord.Color.blue()
        )
        
        if plano["id_plano"] == 2:
            embed.add_field(name="üìÖ Postagem", value="Alternada (hoje n√£o, amanh√£ sim)", inline=True)
        elif plano["id_plano"] == 8:
            embed.add_field(name="üìÖ Postagem", value="2 posts a cada 2 dias", inline=True)
        elif "dias_post" in plano:
            if plano["dias_post"] == 1:
                embed.add_field(name="üìÖ Postagem", value="Di√°ria", inline=True)
            else:
                embed.add_field(name="üìÖ Postagem", value=f"A cada {plano['dias_post']} dias", inline=True)
        
        if "tags" in plano:
            if plano["tags"] == "ilimitado":
                embed.add_field(name="üè∑Ô∏è Destaques", value="Ilimitados", inline=True)
            elif "posts_necessarios" in plano:
                embed.add_field(name="üè∑Ô∏è Destaques", value=f"{plano['tags']} a cada {plano['posts_necessarios']} posts", inline=True)
        
        embed.add_field(name="‚è∞ Dura√ß√£o", value="30 dias", inline=True)
        
        view = ComprarViewCompleta(plano)
        await ctx.send(embed=embed, view=view)
        
    except Exception as e:
        print(f"Erro ao mostrar plano individual: {e}")
        await ctx.send("‚ùå Erro interno. Tente novamente.")

@bot.command(name="status")
async def status_usuario(ctx):
    """Mostra status dos planos do usu√°rio"""
    try:
        user_id = ctx.author.id
        db = load_planos_db()
        posts_db = load_posts_db()
        
        embed = discord.Embed(
            title=f"üìä Meus Planos - {ctx.author.display_name}",
            color=discord.Color.blue()
        )
        
        agora = int(time.time())
        planos_encontrados = False
        planos_ativos = []
        planos_expirados = []
        
        for plano in db:
            if plano["user_id"] == user_id and plano.get("pago", False):
                planos_encontrados = True
                fim = plano.get("data_fim", agora)
                
                if agora > fim:
                    planos_expirados.append(plano)
                else:
                    planos_ativos.append(plano)
        
        if planos_ativos:
            ativo_text = ""
            for plano in planos_ativos:
                fim = plano.get("data_fim", agora)
                dias_restantes = (fim - agora) // 86400
                modalidade = plano.get("modalidade", "mensal")
                ativo_text += f"‚Ä¢ **{plano['descricao']}** ({modalidade})\n  üìÖ {dias_restantes} dias restantes\n  üéØ Tipo: {plano['tipo'].capitalize()}\n\n"
            
            embed.add_field(
                name="‚úÖ Planos Ativos",
                value=ativo_text,
                inline=False
            )
            
            # Bot√£o para cancelar planos
            view = View(timeout=300)
            cancelar_btn = discord.ui.Button(label="üóëÔ∏è Cancelar Plano", style=discord.ButtonStyle.danger)
            
            async def cancelar_callback(interaction):
                if interaction.user.id != user_id:
                    await interaction.response.send_message("‚ùå Voc√™ n√£o pode usar este bot√£o.", ephemeral=True)
                    return
                
                agora = int(time.time())
                planos_cancelaveis = [p for p in planos_ativos if p.get("data_fim", 0) > agora]
                
                if not planos_cancelaveis:
                    await interaction.response.send_message("‚ùå Nenhum plano ativo para cancelar.", ephemeral=True)
                    return
                
                view_cancelar = CancelarPlanoView(planos_cancelaveis)
                embed_cancelar = discord.Embed(
                    title="üóëÔ∏è Cancelar Plano",
                    description="Escolha o plano que deseja cancelar:",
                    color=discord.Color.orange()
                )
                embed_cancelar.add_field(
                    name="‚ö†Ô∏è Pol√≠tica de Cancelamento:",
                    value="‚Ä¢ Antes de 2 meses: Taxa de 100%\n‚Ä¢ Ap√≥s 2 meses: Sem taxa\n‚Ä¢ Pagamento √∫nico: Sempre taxa de 100%",
                    inline=False
                )
                
                await interaction.response.send_message(embed=embed_cancelar, view=view_cancelar, ephemeral=True)
            
            cancelar_btn.callback = cancelar_callback
            view.add_item(cancelar_btn)
            
            embed.set_footer(text="Use o bot√£o abaixo para cancelar um plano")
        else:
            view = None
        
        # Estat√≠sticas de posts
        user_posts = posts_db.get(str(user_id), {})
        if any(p["tipo"] == "destacar" for p in planos_ativos):
            posts_rede = user_posts.get("posts_rede", 0)
            destaques_usados = user_posts.get("destaques_usados", 0)
            
            embed.add_field(
                name="üìä Estat√≠sticas de Destaque",
                value=f"‚Ä¢ Posts na rede: {posts_rede}\n‚Ä¢ Destaques usados: {destaques_usados}",
                inline=True
            )
        
        if any(p["id_plano"] == 8 for p in planos_ativos):
            posts_periodo = user_posts.get("posts_periodo_comprador", {"count": 0})
            embed.add_field(
                name="üìä Posts no Per√≠odo Atual",
                value=f"‚Ä¢ Posts usados: {posts_periodo.get('count', 0)}/2",
                inline=True
            )
        
        if planos_expirados:
            expirado_text = ""
            for plano in planos_expirados[-3:]:
                modalidade = plano.get("modalidade", "mensal")
                expirado_text += f"‚Ä¢ {plano['descricao']} ({modalidade})\n"
            
            embed.add_field(
                name="‚ùå Planos Expirados (√∫ltimos 3)",
                value=expirado_text,
                inline=False
            )
        
        if not planos_encontrados:
            embed.description = "Nenhum plano ativo encontrado.\n\nüõçÔ∏è Use `!planos` para ver as op√ß√µes dispon√≠veis!"
            embed.color = discord.Color.orange()
        
        embed.add_field(
            name="üìã Comandos √öteis",
            value="‚Ä¢ `!planos` - Ver todos os planos\n‚Ä¢ `!plano <id>` - Comprar plano espec√≠fico\n‚Ä¢ `!ajuda` - Todos os comandos",
            inline=False
        )
        
        await ctx.send(embed=embed, view=view)
        
    except Exception as e:
        print(f"Erro ao mostrar status: {e}")
        await ctx.send("‚ùå Erro ao verificar status. Tente novamente.")

@bot.command(name="ajuda", aliases=["help"])
async def ajuda(ctx):
    """Comandos dispon√≠veis"""
    embed = discord.Embed(
        title="ü§ñ Central de Ajuda - Sistema de Assinaturas",
        description="Sistema completo com PIX, Cart√£o e Cancelamentos",
        color=discord.Color.green()
    )
    
    embed.add_field(
        name="üõçÔ∏è Comandos de Compra",
        value="‚Ä¢ `!planos` - Ver todos os planos\n‚Ä¢ `!plano <id>` - Comprar plano espec√≠fico\n‚Ä¢ `!status` - Ver/cancelar seus planos",
        inline=False
    )
    
    embed.add_field(
        name="üåü Sistema Privado",
        value="‚Ä¢ `!assinatura` - Espa√ßo privado de assinatura\n‚Ä¢ `!assinar` - Alias para privacidade\n‚Ä¢ `!privado` - Outro alias",
        inline=False
    )
    
    embed.add_field(
        name="üí∞ Modalidades de Pagamento",
        value="‚Ä¢ **Mensal**: Pre√ßo normal, cancelamento flex√≠vel\n‚Ä¢ **√önico**: +50% do valor, v√°lido 1 m√™s, taxa cancelamento\n‚Ä¢ **PIX**: Confirma√ß√£o r√°pida\n‚Ä¢ **Cart√£o**: Cr√©dito/D√©bito at√© 12x",
        inline=False
    )
    
    embed.add_field(
        name="üóëÔ∏è Sistema de Cancelamento",
        value="‚Ä¢ Use `!status` e clique em 'Cancelar Plano'\n‚Ä¢ Antes de 2 meses: Taxa de 100%\n‚Ä¢ Ap√≥s 2 meses: Sem taxa\n‚Ä¢ Pagamento √∫nico: Sempre 100% de taxa",
        inline=False
    )
    
    embed.add_field(
        name="üìã Tipos de Planos",
        value="‚Ä¢ **Vendedor Verde**: Alternado (hoje n√£o, amanh√£ sim)\n‚Ä¢ **Comprador Verde**: 2 posts a cada 2 dias\n‚Ä¢ **Destacar Vermelho**: Destaques ilimitados",
        inline=False
    )
    
    embed.set_footer(text="üí° Use !assinatura para total privacidade!")
    
    await ctx.send(embed=embed)

@bot.command(name="limpar", aliases=["clear"])
@commands.has_permissions(manage_messages=True)
async def limpar_planos_expirados(ctx, confirmar: str = None):
    """Remove planos expirados do banco de dados"""
    if confirmar != "SIM":
        embed = discord.Embed(
            title="‚ö†Ô∏è Confirma√ß√£o Necess√°ria",
            description="Este comando ir√° remover TODOS os planos expirados.\n\nPara confirmar: `!limpar SIM`",
            color=discord.Color.orange()
        )
        await ctx.send(embed=embed)
        return
    
    try:
        db = load_planos_db()
        agora = int(time.time())
        
        planos_ativos = []
        removidos = 0
        
        for plano in db:
            fim = plano.get("data_fim", 0)
            if fim > agora:
                planos_ativos.append(plano)
            else:
                removidos += 1
        
        save_planos_db(planos_ativos)
        
        embed = discord.Embed(
            title="üßπ Limpeza Conclu√≠da",
            description=f"**{removidos}** planos expirados removidos.\n**{len(planos_ativos)}** planos ativos mantidos.",
            color=discord.Color.green()
        )
        
        await ctx.send(embed=embed)
        
    except Exception as e:
        print(f"Erro na limpeza: {e}")
        await ctx.send("‚ùå Erro ao limpar banco de dados.")

@bot.command(name="assinatura", aliases=["assinar", "privado"])
async def acessar_assinatura_privada(ctx):
    """Cria ou acessa seu espa√ßo privado de assinatura"""
    try:
        forum_configurado = await garantir_forum_configurado(ctx.guild)
        if not forum_configurado:
            await ctx.send("‚ùå Erro ao configurar sistema de f√≥rum. Contate um administrador.", delete_after=10)
            return
        
        thread_privada = await obter_ou_criar_thread_privada(ctx.author, ctx.guild)
        
        if not thread_privada:
            await ctx.send("‚ùå Erro ao criar/acessar seu espa√ßo privado. Tente novamente.", delete_after=10)
            return
        
        embed = discord.Embed(
            title="‚úÖ Espa√ßo Privado Criado!",
            description=f"Acesse: {thread_privada.mention}",
            color=discord.Color.green()
        )
        embed.add_field(
            name="üîí Privacidade Total",
            value="‚Ä¢ Apenas voc√™ pode ver\n‚Ä¢ PIX e Cart√£o dispon√≠veis\n‚Ä¢ Cancelamento via !status",
            inline=False
        )
        embed.set_footer(text="Mensagem deletada em 15s")
        
        await ctx.send(embed=embed, delete_after=15)
        
        try:
            await ctx.message.delete()
        except discord.NotFound:
            pass
        
        if thread_privada.message_count <= 1:
            welcome_embed = discord.Embed(
                title="üéâ Seu Espa√ßo Privado!",
                description="Ambiente privado para gerenciar assinaturas.",
                color=discord.Color.blue()
            )
            welcome_embed.add_field(
                name="üõçÔ∏è Comandos:",
                value="‚Ä¢ `!planos` - Ver planos\n‚Ä¢ `!status` - Gerenciar/cancelar\n‚Ä¢ `!plano <id>` - Comprar espec√≠fico",
                inline=False
            )
            welcome_embed.add_field(
                name="üí≥ Pagamentos:",
                value="‚Ä¢ PIX - Confirma√ß√£o r√°pida\n‚Ä¢ Cart√£o - At√© 12x sem juros\n‚Ä¢ Modalidade √∫nica ou mensal",
                inline=False
            )
            
            await thread_privada.send(embed=welcome_embed)
        
    except Exception as e:
        print(f"Erro no comando assinatura: {e}")
        await ctx.send("‚ùå Erro interno. Tente novamente.", delete_after=5)

@bot.command(name="stats")
@commands.has_permissions(administrator=True)
async def estatisticas_bot(ctx):
    """Estat√≠sticas do bot"""
    try:
        db = load_planos_db()
        payments_db = load_payments_db()
        pix_db = load_pix_db()
        posts_db = load_posts_db()
        agora = int(time.time())
        
        planos_ativos = 0
        planos_expirados = 0
        total_arrecadado_cartao = 0
        total_arrecadado_pix = 0
        pagamentos_pendentes = 0
        
        for plano in db:
            fim = plano.get("data_fim", 0)
            if fim > agora:
                planos_ativos += 1
            else:
                planos_expirados += 1
        
        for payment_data in payments_db.values():
            if payment_data["status"] == "approved":
                total_arrecadado_cartao += payment_data.get("amount", 0)
            elif payment_data["status"] == "pending":
                pagamentos_pendentes += 1
        
        for pix_data in pix_db.values():
            if pix_data["status"] == "approved":
                total_arrecadado_pix += pix_data.get("amount", 0)
        
        tipos = {"vendedor": 0, "comprador": 0, "destacar": 0}
        modalidades = {"mensal": 0, "unico": 0}
        
        for plano in db:
            if plano.get("data_fim", 0) > agora:
                tipo = plano.get("tipo", "")
                modalidade = plano.get("modalidade", "mensal")
                if tipo in tipos:
                    tipos[tipo] += 1
                if modalidade in modalidades:
                    modalidades[modalidade] += 1
        
        total_posts_rede = sum(user_data.get("posts_rede", 0) for user_data in posts_db.values())
        total_destaques = sum(user_data.get("destaques_usados", 0) for user_data in posts_db.values())
        
        embed = discord.Embed(
            title="üìä Estat√≠sticas do Sistema",
            color=discord.Color.blue()
        )
        
        embed.add_field(
            name="üìà Planos",
            value=f"**Ativos:** {planos_ativos}\n**Expirados:** {planos_expirados}",
            inline=True
        )
        
        total_arrecadado = total_arrecadado_cartao + total_arrecadado_pix
        embed.add_field(
            name="üí∞ Financeiro",
            value=f"**Total:** R$ {total_arrecadado:.2f}\n**Cart√£o:** R$ {total_arrecadado_cartao:.2f}\n**PIX:** R$ {total_arrecadado_pix:.2f}\n**Pendentes:** {pagamentos_pendentes}",
            inline=True
        )
        
        embed.add_field(
            name="üéØ Por Tipo",
            value=f"**Vendedor:** {tipos['vendedor']}\n**Comprador:** {tipos['comprador']}\n**Destacar:** {tipos['destacar']}",
            inline=True
        )
        
        embed.add_field(
            name="üíé Modalidades",
            value=f"**Mensal:** {modalidades['mensal']}\n**√önico:** {modalidades['unico']}",
            inline=True
        )
        
        embed.add_field(
            name="üìä Atividade",
            value=f"**Posts rede:** {total_posts_rede}\n**Destaques:** {total_destaques}",
            inline=True
        )
        
        embed.add_field(
            name="ü§ñ Bot",
            value=f"**Servidores:** {len(bot.guilds)}\n**Usu√°rios:** {len(set(bot.get_all_members()))}",
            inline=True
        )
        
        embed.set_footer(text=f"√öltima verifica√ß√£o: {datetime.now().strftime('%d/%m/%Y %H:%M')}")
        
        await ctx.send(embed=embed)
        
    except Exception as e:
        print(f"Erro nas estat√≠sticas: {e}")
        await ctx.send("‚ùå Erro ao gerar estat√≠sticas.")

# ================== EVENTOS ==================
@bot.event
async def on_ready():
    print(f"ü§ñ {bot.user} est√° online!")
    print(f"üìä Conectado a {len(bot.guilds)} servidor(s)")
    print(f"üë• Alcan√ßando {len(set(bot.get_all_members()))} usu√°rios √∫nicos")
    print(f"üí≥ Sistema COMPLETO ativo:")
    print("   ‚Ä¢ Pagamentos PIX e Cart√£o")
    print("   ‚Ä¢ Modalidades: Mensal e √önica (+50%)")
    print("   ‚Ä¢ Sistema de cancelamento com taxas")
    print("   ‚Ä¢ Verifica√ß√£o autom√°tica a cada 5min")
    print(f"üè∑Ô∏è Canais: {CHANNEL_CONFIG}")
    print("üîÑ FUNCIONALIDADES PRINCIPAIS:")
    print("   ‚Ä¢ PIX: Pagamento r√°pido via c√≥digo")
    print("   ‚Ä¢ Cart√£o: At√© 12x sem juros")  
    print("   ‚Ä¢ Cancelamento: Taxa 100% antes de 2 meses")
    print("   ‚Ä¢ Cargos: Vendedor/Comprador/Destacar")
    
    if not verificar_pagamentos_automatico.is_running():
        verificar_pagamentos_automatico.start()
        print("üîÑ Verifica√ß√£o autom√°tica iniciada")

@bot.event
async def on_command_error(ctx, error):
    """Tratamento de erros"""
    if isinstance(error, commands.CommandNotFound):
        embed = discord.Embed(
            title="‚ùì Comando n√£o encontrado",
            description=f"Use `!ajuda` para ver comandos dispon√≠veis.",
            color=discord.Color.orange()
        )
        await ctx.send(embed=embed, delete_after=10)
    
    elif isinstance(error, commands.MissingPermissions):
        await ctx.send("‚ùå Sem permiss√£o.", delete_after=5)
    
    elif isinstance(error, commands.BadArgument):
        await ctx.send("‚ùå Argumento inv√°lido.", delete_after=5)
    
    else:
        print(f"Erro no comando {ctx.command}: {error}")
        await ctx.send("‚ùå Erro interno. Tente novamente.", delete_after=5)

@bot.event
async def on_guild_join(guild):
    """Quando o bot entra em um servidor novo"""
    print(f"‚ûï Bot adicionado ao servidor: {guild.name} (ID: {guild.id})")
    
    # Configurar f√≥rum automaticamente
    await garantir_forum_configurado(guild)
    
    for channel in guild.text_channels:
        if channel.permissions_for(guild.me).send_messages:
            embed = discord.Embed(
                title="üéâ Sistema de Assinaturas Ativado!",
                description="Bot com pagamentos reais via PIX e Cart√£o!",
                color=discord.Color.green()
            )
            
            embed.add_field(
                name="üöÄ Come√ßar",
                value="‚Ä¢ `!ajuda` - Todos os comandos\n‚Ä¢ `!assinatura` - Espa√ßo privado\n‚Ä¢ `!planos` - Ver planos dispon√≠veis",
                inline=False
            )
            
            embed.add_field(
                name="üí∞ Novidades",
                value="‚Ä¢ **PIX**: Pagamento instant√¢neo\n‚Ä¢ **Modalidade √önica**: +50% do valor, 1 m√™s\n‚Ä¢ **Cancelamento**: Com sistema de taxas",
                inline=False
            )
            
            embed.add_field(
                name="üè∑Ô∏è Configure os Canais",
                value=f"‚Ä¢ `{CHANNEL_CONFIG['rede']}` - Para vendedores\n‚Ä¢ `{CHANNEL_CONFIG['recomendacao']}` - Para compradores\n‚Ä¢ `{CHANNEL_CONFIG['destaques']}` - Posts destacados",
                inline=False
            )
            
            embed.add_field(
                name="‚ö° Sistema Autom√°tico",
                value="‚Ä¢ Verifica√ß√£o de pagamentos a cada 5min\n‚Ä¢ Cargos atribu√≠dos automaticamente\n‚Ä¢ Controle de posts por plano",
                inline=False
            )
            
            embed.set_footer(text="Digite !assinatura para come√ßar com privacidade total!")
            
            try:
                await channel.send(embed=embed)
                break
            except discord.Forbidden:
                continue

@bot.event
async def on_member_join(member):
    """Quando um usu√°rio entra no servidor - reatribuir cargos"""
    try:
        db = load_planos_db()
        agora = int(time.time())
        
        for plano in db:
            if (plano["user_id"] == member.id and 
                plano.get("pago", False) and 
                plano.get("data_fim", 0) > agora):
                
                await assign_role_to_member(member, plano["tipo"])
                print(f"Cargo {plano['tipo']} reatribu√≠do para {member.display_name}")
                
    except Exception as e:
        print(f"Erro ao reatribuir cargos para {member.display_name}: {e}")

# ================== INICIALIZA√á√ÉO ==================
if __name__ == "__main__":
    print("üöÄ Iniciando Sistema de Assinaturas Discord...")
    print("=" * 60)
    print("üí≥ PAGAMENTOS REAIS VIA MERCADO PAGO")
    print("üì± PIX - Pagamento instant√¢neo")
    print("üí≥ CART√ÉO - Cr√©dito/D√©bito at√© 12x")
    print("üíé MODALIDADE √öNICA - +50% do valor, v√°lido 1 m√™s")
    print("üóëÔ∏è SISTEMA DE CANCELAMENTO - Taxa 100% antes de 2 meses")
    print("ü§ñ VERIFICA√á√ÉO AUTOM√ÅTICA - A cada 5 minutos")
    print("üéØ CARGOS AUTOM√ÅTICOS - Vendedor/Comprador/Destacar")
    print("=" * 60)
    print(f"üè∑Ô∏è Canais configurados: {CHANNEL_CONFIG}")
    print("üÜï ATUALIZA√á√ïES DOS PLANOS:")
    print("   ‚Ä¢ Vendedor Verde: Sistema alternado (hoje n√£o, amanh√£ sim)")
    print("   ‚Ä¢ Comprador Verde: 2 posts a cada 2 dias")
    print("   ‚Ä¢ Destacar Vermelho: Destaques ilimitados")
    print("=" * 60)
    
    if not DISCORD_TOKEN:
        print("‚ùå DISCORD_TOKEN n√£o encontrado no arquivo .env!")
        exit(1)
    
    if not ML_TOKEN:
        print("‚ùå ML_TOKEN n√£o encontrado no arquivo .env!")
        exit(1)
    
    if ML_TOKEN.startswith("APP_USR"):
        print("üö® ATEN√á√ÉO: TOKENS DE PRODU√á√ÉO - COBRAN√áAS REAIS!")
        print("üí∞ PIX e Cart√µes ser√£o cobrados de verdade!")
    elif ML_TOKEN.startswith("TEST"):
        print("üß™ TOKENS DE TESTE - Ambiente de desenvolvimento")
        print("üîß Pagamentos simulados para testes")
    else:
        print("‚ö†Ô∏è Token do Mercado Pago n√£o identificado")
    
    print("=" * 60)
    print("üîÑ RECURSOS IMPLEMENTADOS:")
    print("‚úÖ PIX com c√≥digo QR")
    print("‚úÖ Cart√£o at√© 12x sem juros")
    print("‚úÖ Modalidade √∫nica (+50%)")
    print("‚úÖ Sistema de cancelamento")
    print("‚úÖ Verifica√ß√£o autom√°tica")
    print("‚úÖ Cargos autom√°ticos")
    print("‚úÖ Controle de posts")
    print("‚úÖ Sistema de destaques")
    print("‚úÖ Espa√ßo privado por usu√°rio")
    print("=" * 60)
    
    try:
        bot.run(DISCORD_TOKEN)
    except discord.LoginFailure:
        print("‚ùå TOKEN do Discord inv√°lido! Verifique o arquivo .env")
    except discord.HTTPException as e:
        print(f"‚ùå Erro HTTP: {e}")
    except KeyboardInterrupt:
        print("\nüëã Bot encerrado pelo usu√°rio")
    except Exception as e:
        print(f"‚ùå Erro inesperado: {e}")
    finally:
        print("üî¥ Bot desconectado")
import os
import json
import time
import random
import asyncio
import requests
from typing import List, Dict, Any
from datetime import datetime, timedelta
import pytz

import discord
from discord.ext import commands, tasks
from discord.ui import View, Button
from dotenv import load_dotenv
import mercadopago

# ----------------- CONFIGURA√á√ïES -----------------
load_dotenv("arquivo.env")
DISCORD_TOKEN = os.getenv("DISCORD_TOKEN")
ML_TOKEN = os.getenv("ML_TOKEN")
ML_PUBLIC_KEY = os.getenv("ML_PUBLIC_KEY")

# Inicializar SDK do Mercado Pago
sdk = mercadopago.SDK(ML_TOKEN)

DB_FILE = "planos_ativos.json"
POST_DB = "posts.json"
PAYMENTS_DB = "pagamentos.json"
PIX_DB = "pix_payments.json"

intents = discord.Intents.default()
intents.message_content = True
intents.guilds = True
intents.members = True
bot = commands.Bot(command_prefix="!", intents=intents, help_command=None)

# ----------------- PLANOS ATUALIZADOS COM MODALIDADES -----------------
PLANOS = [
    {"id_plano": 1, "descricao": "Vendedor Vermelho üî¥", "tipo": "vendedor", "dias_post": 1, "preco": 25.00},
    {"id_plano": 2, "descricao": "Vendedor Verde üü¢", "tipo": "vendedor", "dias_post": 1, "alternado": True, "preco": 15.90},
    {"id_plano": 3, "descricao": "Vendedor Azul üîµ", "tipo": "vendedor", "dias_post": 2, "preco": 7.90},
    {"id_plano": 4, "descricao": "Destacar Vermelho üî¥", "tipo": "destacar", "tags": "ilimitado", "preco": 75.00},
    {"id_plano": 5, "descricao": "Destacar Verde üü¢", "tipo": "destacar", "tags": 2, "posts_necessarios": 10, "preco": 27.80},
    {"id_plano": 6, "descricao": "Destacar Azul üîµ", "tipo": "destacar", "tags": 1, "posts_necessarios": 10, "preco": 17.80},
    {"id_plano": 7, "descricao": "Comprador Vermelho üî¥", "tipo": "comprador", "dias_post": 1, "preco": 24.90},
    {"id_plano": 8, "descricao": "Comprador Verde üü¢", "tipo": "comprador", "dias_post": 2, "posts_por_periodo": 2, "preco": 12.00},
    {"id_plano": 9, "descricao": "Comprador Azul üîµ", "tipo": "comprador", "dias_post": 2, "preco": 9.50},
]

# Configura√ß√µes dos canais
CHANNEL_CONFIG = {
    "rede": "üõírede",
    "recomendacao": "üåürecomenda√ß√£o-do-caveira",
    "destaques": "üíØdestaques",
    "forum_assinaturas": "assinarüåü",
    "categoria_assinaturas": "üìÉüåüAssinaturas"
}

# ================== UTILIT√ÅRIOS JSON ==================
def load_json(path: str, default):
    try:
        with open(path, "r", encoding="utf-8") as f:
            return json.load(f)
    except FileNotFoundError:
        return default
    except json.JSONDecodeError:
        print(f"Erro ao ler {path}, usando valores padr√£o")
        return default

def save_json(path: str, data):
    try:
        with open(path, "w", encoding="utf-8") as f:
            json.dump(data, f, indent=4, ensure_ascii=False)
    except Exception as e:
        print(f"Erro ao salvar {path}: {e}")

def load_planos_db():
    return load_json(DB_FILE, [])

def save_planos_db(data):
    save_json(DB_FILE, data)

def load_payments_db():
    return load_json(PAYMENTS_DB, {})

def save_payments_db(data):
    save_json(PAYMENTS_DB, data)

def load_posts_db():
    return load_json(POST_DB, {})

def save_posts_db(data):
    save_json(POST_DB, data)

def load_pix_db():
    return load_json(PIX_DB, {})

def save_pix_db(data):
    save_json(PIX_DB, data)

# ================== SISTEMA DE F√ìRUM PRIVADO ==================
async def obter_ou_criar_thread_privada(user: discord.Member, guild: discord.Guild):
    """Obt√©m ou cria uma thread privada no f√≥rum de assinaturas para o usu√°rio"""
    try:
        categoria = discord.utils.get(guild.categories, name=CHANNEL_CONFIG["categoria_assinaturas"])
        if not categoria:
            print(f"Categoria {CHANNEL_CONFIG['categoria_assinaturas']} n√£o encontrada")
            return None
        
        forum_channel = discord.utils.get(categoria.channels, name=CHANNEL_CONFIG["forum_assinaturas"])
        if not forum_channel:
            print(f"F√≥rum {CHANNEL_CONFIG['forum_assinaturas']} n√£o encontrado na categoria")
            return None
        
        if not isinstance(forum_channel, discord.ForumChannel):
            print(f"Canal {CHANNEL_CONFIG['forum_assinaturas']} n√£o √© um canal de f√≥rum")
            return None
        
        for thread in forum_channel.threads:
            if thread.name == f"Assinatura - {user.display_name}" or thread.owner_id == user.id:
                return thread
        
        try:
            embed = discord.Embed(
                title=f"üåü Assinatura Privada - {user.display_name}",
                description="Este √© seu espa√ßo privado de assinatura. Apenas voc√™ pode ver e interagir aqui.",
                color=discord.Color.gold()
            )
            embed.add_field(
                name="üìã Como usar:",
                value="‚Ä¢ Use `!status` para ver seus planos\n‚Ä¢ Use `!planos` para comprar novos planos\n‚Ä¢ Este chat √© totalmente privado",
                inline=False
            )
            embed.set_footer(text="Sistema de Assinaturas Privadas")
            
            thread = await forum_channel.create_thread(
                name=f"Assinatura - {user.display_name}",
                content="",
                embed=embed,
                auto_archive_duration=10080,
                slowmode_delay=0
            )
            
            overwrites = {
                guild.default_role: discord.PermissionOverwrite(read_messages=False, send_messages=False),
                user: discord.PermissionOverwrite(read_messages=True, send_messages=True),
                guild.me: discord.PermissionOverwrite(read_messages=True, send_messages=True)
            }
            
            await thread.thread.edit(overwrites=overwrites)
            await thread.thread.add_user(user)
            
            print(f"Thread privada criada para {user.display_name}")
            return thread.thread
            
        except discord.Forbidden:
            print(f"Sem permiss√£o para criar thread no f√≥rum")
            return None
        except Exception as e:
            print(f"Erro ao criar thread: {e}")
            return None
    
    except Exception as e:
        print(f"Erro no sistema de f√≥rum privado: {e}")
        return None

async def garantir_forum_configurado(guild: discord.Guild):
    """Garante que o f√≥rum e categoria est√£o configurados corretamente"""
    try:
        categoria = discord.utils.get(guild.categories, name=CHANNEL_CONFIG["categoria_assinaturas"])
        if not categoria:
            try:
                categoria = await guild.create_category(CHANNEL_CONFIG["categoria_assinaturas"])
                print(f"Categoria {CHANNEL_CONFIG['categoria_assinaturas']} criada")
            except discord.Forbidden:
                print("Sem permiss√£o para criar categoria")
                return False
        
        forum_channel = discord.utils.get(categoria.channels, name=CHANNEL_CONFIG["forum_assinaturas"])
        if not forum_channel:
            try:
                overwrites = {
                    guild.default_role: discord.PermissionOverwrite(
                        read_messages=True, 
                        send_messages=False,
                        create_public_threads=False,
                        create_private_threads=False
                    ),
                    guild.me: discord.PermissionOverwrite(
                        read_messages=True,
                        send_messages=True,
                        create_public_threads=True,
                        create_private_threads=True,
                        manage_threads=True
                    )
                }
                
                forum_channel = await categoria.create_forum(
                    CHANNEL_CONFIG["forum_assinaturas"],
                    topic="F√≥rum de assinaturas privadas - cada usu√°rio tem seu espa√ßo individual",
                    overwrites=overwrites,
                    slowmode_delay=60
                )
                print(f"F√≥rum {CHANNEL_CONFIG['forum_assinaturas']} criado")
            except discord.Forbidden:
                print("Sem permiss√£o para criar f√≥rum")
                return False
            except Exception as e:
                print(f"Erro ao criar f√≥rum: {e}")
                return False
        
        return True
    
    except Exception as e:
        print(f"Erro ao configurar f√≥rum: {e}")
        return False

# ================== SISTEMA DE CANCELAMENTO ==================
def calcular_taxa_cancelamento(data_inicio: int, eh_pagamento_unico: bool = False):
    """Calcula a taxa de cancelamento baseada no tempo desde a compra"""
    agora = int(time.time())
    dias_desde_compra = (agora - data_inicio) // 86400
    
    if dias_desde_compra < 60:  # Menos de 2 meses
        if eh_pagamento_unico:
            return 1.0  # 100% de taxa para pagamento √∫nico
        else:
            return 1.0  # 100% de taxa para cancelamento antes de 2 meses
    else:
        return 0.0  # Sem taxa ap√≥s 2 meses

def pode_cancelar_plano(user_id: int, id_plano: int):
    """Verifica se o usu√°rio pode cancelar um plano espec√≠fico"""
    db = load_planos_db()
    agora = int(time.time())
    
    for plano in db:
        if (plano["user_id"] == user_id and 
            plano["id_plano"] == id_plano and 
            plano.get("pago", False) and
            plano.get("data_fim", 0) > agora):
            
            return True, plano
    
    return False, None

# ================== SISTEMA PIX ==================
def gerar_chave_pix():
    """Gera uma chave PIX √∫nica para o pagamento"""
    import uuid
    return str(uuid.uuid4())

def criar_pagamento_pix(plano: dict, user_id: int, username: str, modalidade: str = "mensal"):
    """Cria um pagamento PIX atrav√©s do Mercado Pago"""
    try:
        tz_brasil = pytz.timezone('America/Sao_Paulo')
        agora = datetime.now(tz_brasil)
        
        # Calcular pre√ßo baseado na modalidade
        preco_final = plano["preco"]
        if modalidade == "unico":
            preco_final = plano["preco"] * 1.5  # 50% a mais
        
        referencia_pix = f"pix_{plano['id_plano']}_user_{user_id}_{int(time.time())}"
        nome_usuario = username[:50] if username else "Usuario Discord"
        
        payment_data = {
            "transaction_amount": preco_final,
            "description": f"Plano {plano['descricao']} - {modalidade.capitalize()}",
            "payment_method_id": "pix",
            "payer": {
                "email": f"user{user_id}@discord.bot",
                "first_name": nome_usuario,
                "last_name": "Discord",
                "identification": {
                    "type": "CPF",
                    "number": "00000000000"  # CPF fict√≠cio para teste
                }
            },
            "external_reference": referencia_pix,
            "notification_url": "https://webhook.site/unique-id",  # Substitua por sua URL de webhook
            "date_of_expiration": (agora + timedelta(minutes=30)).isoformat()
        }
        
        payment_response = sdk.payment().create(payment_data)
        
        if payment_response["status"] == 201:
            payment_info = payment_response["response"]
            
            # Salvar informa√ß√µes do PIX
            pix_db = load_pix_db()
            pix_record = {
                "payment_id": payment_info["id"],
                "user_id": user_id,
                "plano": plano,
                "modalidade": modalidade,
                "amount": preco_final,
                "status": "pending",
                "created_date": payment_info["date_created"],
                "external_reference": referencia_pix,
                "qr_code": payment_info["point_of_interaction"]["transaction_data"]["qr_code"],
                "qr_code_base64": payment_info["point_of_interaction"]["transaction_data"]["qr_code_base64"],
                "ticket_url": payment_info["point_of_interaction"]["transaction_data"]["ticket_url"]
            }
            
            pix_db[str(payment_info["id"])] = pix_record
            save_pix_db(pix_db)
            
            return payment_info, pix_record
        else:
            print(f"Erro ao criar pagamento PIX: {payment_response}")
            return None, None
            
    except Exception as e:
        print(f"Erro ao criar pagamento PIX: {e}")
        return None, None

def verificar_pagamento_pix(payment_id: str):
    """Verifica o status de um pagamento PIX"""
    try:
        payment_response = sdk.payment().get(payment_id)
        
        if payment_response["status"] == 200:
            return payment_response["response"]
        else:
            print(f"Erro ao verificar pagamento PIX: {payment_response}")
            return None
            
    except Exception as e:
        print(f"Erro ao verificar pagamento PIX: {e}")
        return None

# ================== SISTEMA DE POSTS ATUALIZADO ==================
def pode_postar(user_id: int, tipo_plano: str):
    """Verifica se o usu√°rio pode postar baseado no plano dele"""
    db = load_planos_db()
    posts_db = load_posts_db()
    agora = int(time.time())
    
    # Verificar se tem plano ativo
    plano_ativo = None
    for plano in db:
        if (plano["user_id"] == user_id and 
            plano["tipo"] == tipo_plano and 
            plano.get("pago", False) and
            plano.get("data_fim", 0) > agora):
            plano_ativo = plano
            break
    
    if not plano_ativo:
        return False, "Voc√™ n√£o possui um plano ativo do tipo necess√°rio."
    
    # Buscar dados do plano
    plano_info = next((p for p in PLANOS if p["id_plano"] == plano_ativo["id_plano"]), None)
    if not plano_info:
        return False, "Erro: plano n√£o encontrado."
    
    user_posts = posts_db.get(str(user_id), {})
    ultimo_post = user_posts.get(f"ultimo_post_{tipo_plano}", 0)
    
    # VENDEDOR VERDE: Sistema alternado (hoje n√£o, amanh√£ sim)
    if plano_info["id_plano"] == 2:  # Vendedor Verde
        if ultimo_post == 0:  # Primeiro post
            return True, plano_ativo
            
        dias_desde_ultimo = (agora - ultimo_post) // 86400
        if dias_desde_ultimo == 0:  # Mesmo dia do √∫ltimo post
            return False, "Voc√™ pode postar novamente amanh√£ (sistema alternado)."
        elif dias_desde_ultimo >= 1:  # 1+ dias depois - pode postar
            return True, plano_ativo
    
    # COMPRADOR VERDE: 2 posts a cada 2 dias
    elif plano_info["id_plano"] == 8:  # Comprador Verde
        posts_por_periodo = plano_info.get("posts_por_periodo", 2)
        periodo = plano_info.get("dias_post", 2) * 86400  # 2 dias em segundos
        
        posts_no_periodo = user_posts.get(f"posts_periodo_{tipo_plano}", {"inicio": 0, "count": 0})
        
        # Se passou o per√≠odo, resetar contador
        if agora - posts_no_periodo["inicio"] >= periodo:
            posts_no_periodo = {"inicio": agora, "count": 0}
            user_posts[f"posts_periodo_{tipo_plano}"] = posts_no_periodo
            save_posts_db(posts_db)
        
        # Verificar se ainda pode postar no per√≠odo atual
        if posts_no_periodo["count"] >= posts_por_periodo:
            tempo_restante = periodo - (agora - posts_no_periodo["inicio"])
            horas_restantes = tempo_restante // 3600
            return False, f"Voc√™ j√° fez {posts_por_periodo} posts neste per√≠odo. Aguarde {horas_restantes} horas."
        
        return True, plano_ativo
    
    # OUTROS PLANOS: Sistema normal por dias
    else:
        dias_necessarios = plano_info.get("dias_post", 1)
        tempo_espera = dias_necessarios * 86400  # dias em segundos
        
        if agora - ultimo_post < tempo_espera:
            horas_restantes = (tempo_espera - (agora - ultimo_post)) // 3600
            return False, f"Voc√™ pode postar novamente em {horas_restantes} horas."
        
        return True, plano_ativo

def pode_usar_destaque(user_id: int):
    """Verifica se o usu√°rio pode usar a tag de destaque"""
    db = load_planos_db()
    posts_db = load_posts_db()
    agora = int(time.time())
    
    # Verificar se tem plano ativo de destacar
    plano_destacar = None
    for plano in db:
        if (plano["user_id"] == user_id and 
            plano["tipo"] == "destacar" and 
            plano.get("pago", False) and
            plano.get("data_fim", 0) > agora):
            plano_destacar = plano
            break
    
    if not plano_destacar:
        return False, "Voc√™ precisa de um plano de destaque para usar esta tag."
    
    # Buscar dados do plano
    plano_info = next((p for p in PLANOS if p["id_plano"] == plano_destacar["id_plano"]), None)
    if not plano_info:
        return False, "Erro: plano n√£o encontrado."
    
    # PLANO VERMELHO: ILIMITADO
    if plano_info["id_plano"] == 4:  # Destacar Vermelho
        return True, plano_destacar
    
    user_posts = posts_db.get(str(user_id), {})
    
    # Para planos Verde e Azul de destaque, verificar posts na rede
    if "posts_necessarios" in plano_info:
        posts_rede = user_posts.get("posts_rede", 0)
        destaques_usados = user_posts.get("destaques_usados", 0)
        
        # Calcular quantos destaques pode usar
        destaques_disponiveis = (posts_rede // plano_info["posts_necessarios"]) * plano_info["tags"]
        
        if destaques_usados >= destaques_disponiveis:
            posts_faltantes = plano_info["posts_necessarios"] - (posts_rede % plano_info["posts_necessarios"])
            return False, f"Voc√™ precisa fazer mais {posts_faltantes} posts na üõírede para usar destaque novamente."
    
    return True, plano_destacar

def registrar_post(user_id: int, canal_tipo: str, tem_destaque: bool = False):
    """Registra um post do usu√°rio"""
    posts_db = load_posts_db()
    user_posts = posts_db.get(str(user_id), {})
    agora = int(time.time())
    
    # Registrar √∫ltimo post por tipo
    if canal_tipo == "vendedor":
        user_posts["ultimo_post_vendedor"] = agora
        user_posts["posts_rede"] = user_posts.get("posts_rede", 0) + 1
    elif canal_tipo == "comprador":
        user_posts["ultimo_post_comprador"] = agora
        
        # Para comprador verde, atualizar contador do per√≠odo
        db = load_planos_db()
        for plano in db:
            if (plano["user_id"] == user_id and 
                plano["tipo"] == "comprador" and 
                plano.get("pago", False) and
                plano.get("data_fim", 0) > agora):
                
                plano_info = next((p for p in PLANOS if p["id_plano"] == plano["id_plano"]), None)
                if plano_info and plano_info["id_plano"] == 8:  # Comprador Verde
                    posts_no_periodo = user_posts.get("posts_periodo_comprador", {"inicio": 0, "count": 0})
                    posts_no_periodo["count"] += 1
                    user_posts["posts_periodo_comprador"] = posts_no_periodo
                break
    
    # Registrar uso de destaque
    if tem_destaque:
        user_posts["destaques_usados"] = user_posts.get("destaques_usados", 0) + 1
    
    posts_db[str(user_id)] = user_posts
    save_posts_db(posts_db)

async def mover_para_destaques(message: discord.Message):
    """Move uma mensagem com tag de destaque para o canal de destaques"""
    try:
        guild = message.guild
        canal_destaques = discord.utils.get(guild.channels, name=CHANNEL_CONFIG["destaques"])
        
        if not canal_destaques:
            print(f"Canal {CHANNEL_CONFIG['destaques']} n√£o encontrado")
            return
        
        embed = discord.Embed(
            title="üíØ Post em Destaque",
            description=message.content,
            color=discord.Color.gold()
        )
        embed.set_author(name=message.author.display_name, icon_url=message.author.avatar.url if message.author.avatar else None)
        embed.set_footer(text=f"Original em #{message.channel.name}")
        embed.timestamp = message.created_at
        
        if message.attachments:
            embed.set_image(url=message.attachments[0].url)
        
        await canal_destaques.send(embed=embed)
        print(f"Post de {message.author.display_name} movido para destaques")
        
    except Exception as e:
        print(f"Erro ao mover para destaques: {e}")

# ================== MERCADO PAGO CART√ÉO ==================
def criar_preferencia_pagamento(plano: dict, user_id: int, username: str, modalidade: str = "mensal"):
    try:
        tz_brasil = pytz.timezone('America/Sao_Paulo')
        agora = datetime.now(tz_brasil)
        
        # Calcular pre√ßo baseado na modalidade
        preco_final = plano["preco"]
        if modalidade == "unico":
            preco_final = plano["preco"] * 1.5  # 50% a mais
        
        referencia = f"plano_{plano['id_plano']}_user_{user_id}_{int(time.time())}_{modalidade}"
        nome_usuario = username[:50] if username else "Usuario Discord"
        
        preference_data = {
            "items": [
                {
                    "title": f"Plano {plano['descricao']} - {modalidade.capitalize()}",
                    "quantity": 1,
                    "unit_price": preco_final,
                    "currency_id": "BRL",
                    "description": f"Plano {plano['tipo']} - Discord Bot - {modalidade}"
                }
            ],
            "payer": {
                "name": nome_usuario,
                "surname": "Discord User"
            },
            "payment_methods": {
                "excluded_payment_methods": [],
                "excluded_payment_types": [],
                "installments": 12
            },
            "back_urls": {
                "success": "https://www.cleitodiscord.com/success",
                "failure": "https://www.cleitodiscord.com/failure", 
                "pending": "https://www.cleitodiscord.com/pending"
            },
            "auto_return": "approved",
            "external_reference": referencia,
            "statement_descriptor": "DISCORD_BOT",
            "expires": True,
            "expiration_date_from": agora.isoformat(),
            "expiration_date_to": (agora + timedelta(hours=24)).isoformat()
        }
        
        preference_response = sdk.preference().create(preference_data)
        
        if preference_response["status"] == 201:
            return preference_response["response"]
        else:
            print(f"Erro ao criar prefer√™ncia: {preference_response}")
            return None
    except Exception as e:
        print(f"Erro ao criar prefer√™ncia de pagamento: {e}")
        return None

def verificar_pagamento_por_referencia(external_reference):
    try:
        filters = {"external_reference": external_reference}
        search_response = sdk.payment().search(filters)
        
        if search_response["status"] == 200:
            results = search_response["response"]["results"]
            if results:
                return results[0]
        elif search_response["status"] == 429:
            print("Rate limit atingido - aguardando...")
            time.sleep(5)
            return None
        else:
            print(f"Erro na busca de pagamento: {search_response}")
        return None
    except Exception as e:
        print(f"Erro ao buscar pagamento: {e}")
        return None

def ativar_plano_apos_pagamento(user_id: int, plano: dict, modalidade: str = "mensal"):
    try:
        db = load_planos_db()
        
        timestamp = int(time.time())
        
        # Definir dura√ß√£o baseada na modalidade
        if modalidade == "unico":
            duracao = 30 * 86400  # 30 dias para pagamento √∫nico
        else:
            duracao = 30 * 86400  # 30 dias para mensal (seria recorrente em produ√ß√£o)
        
        plano_registro = {
            "user_id": user_id,
            "id_plano": plano["id_plano"],
            "descricao": plano["descricao"],
            "tipo": plano["tipo"],
            "pago": True,
            "modalidade": modalidade,
            "data_inicio": timestamp,
            "data_fim": timestamp + duracao
        }
        
        db.append(plano_registro)
        save_planos_db(db)
        return plano_registro
    except Exception as e:
        print(f"Erro ao ativar plano: {e}")
        return None

# ================== ROLES DISCORD ==================
async def ensure_role(guild: discord.Guild, name: str):
    role = discord.utils.get(guild.roles, name=name)
    if not role:
        try:
            role = await guild.create_role(name=name, color=discord.Color.blue())
            print(f"Cargo '{name}' criado no servidor {guild.name}")
        except discord.Forbidden:
            print(f"Sem permiss√£o para criar cargo: {name}")
            return None
        except Exception as e:
            print(f"Erro ao criar cargo {name}: {e}")
            return None
    return role

async def assign_role_to_member(member: discord.Member, tipo: str):
    try:
        role_name = tipo.capitalize()
        role = await ensure_role(member.guild, role_name)
        if role and role not in member.roles:
            await member.add_roles(role)
            print(f"Cargo '{role_name}' atribu√≠do a {member.display_name}")
            return True
        return True
    except discord.Forbidden:
        print(f"Sem permiss√£o para adicionar cargo a {member.display_name}")
        return False
    except Exception as e:
        print(f"Erro ao atribuir cargo: {e}")
        return False


class EscolherPagamentoView(View):
    def __init__(self, plano, modalidade):
        super().__init__(timeout=300)
        self.plano = plano
        self.modalidade = modalidade

    @discord.ui.button(label="üí≥ Cart√£o/D√©bito", style=discord.ButtonStyle.primary)
    async def pagamento_cartao(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.defer(ephemeral=True)
        
        try:
            preferencia = criar_preferencia_pagamento(self.plano, interaction.user.id, interaction.user.display_name, self.modalidade)
            
            if not preferencia:
                await interaction.followup.send("‚ùå Erro ao criar link de pagamento. Tente novamente em alguns minutos.", ephemeral=True)
                return
            
            preco_final = self.plano['preco'] if self.modalidade == "mensal" else self.plano['preco'] * 1.5
            
            embed = discord.Embed(
                title="üí≥ Pagamento com Cart√£o",
                description=f"**Plano:** {self.plano['descricao']}\n**Modalidade:** {self.modalidade.capitalize()}\n**Valor:** R$ {preco_final:.2f}",
                color=discord.Color.blue()
            )
            
            embed.add_field(
                name="üí∞ Formas de Pagamento Dispon√≠veis:",
                value="‚Ä¢ Cart√£o de Cr√©dito (at√© 12x)\n‚Ä¢ Cart√£o de D√©bito",
                inline=False
            )
            
            embed.add_field(
                name="üîó Link para Pagamento:",
                value=f"[**CLIQUE AQUI PARA PAGAR**]({preferencia['init_point']})",
                inline=False
            )
            
            embed.set_footer(text=f"ID: {preferencia['id']} - V√°lido por 24h")
            
            verificar_view = VerificarPagamentoView(preferencia["external_reference"], interaction.user.id, self.plano, self.modalidade)
            
            await interaction.followup.send(embed=embed, view=verificar_view, ephemeral=True)
            
        except Exception as e:
            print(f"Erro no pagamento cart√£o: {e}")
            await interaction.followup.send("‚ùå Erro interno. Tente novamente mais tarde.", ephemeral=True)

    @discord.ui.button(label="üì± PIX", style=discord.ButtonStyle.success)
    async def pagamento_pix(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.defer(ephemeral=True)
        
        try:
            payment_info, pix_record = criar_pagamento_pix(self.plano, interaction.user.id, interaction.user.display_name, self.modalidade)
            
            if not payment_info or not pix_record:
                await interaction.followup.send("‚ùå Erro ao criar pagamento PIX. Tente novamente.", ephemeral=True)
                return
            
            embed = discord.Embed(
                title="üì± Pagamento PIX",
                description=f"**Plano:** {self.plano['descricao']}\n**Modalidade:** {self.modalidade.capitalize()}\n**Valor:** R$ {pix_record['amount']:.2f}",
                color=discord.Color.green()
            )
            
            embed.add_field(
                name="üìã Como Pagar:",
                value="1. Copie o c√≥digo PIX abaixo\n2. Cole no seu app banc√°rio\n3. Confirme o pagamento\n4. Clique em 'Verificar Pagamento'",
                inline=False
            )
            
            embed.add_field(
                name="üîó C√≥digo PIX:",
                value=f"```{pix_record['qr_code']}```",
                inline=False
            )
            
            embed.add_field(name="‚è∞ Validade", value="30 minutos", inline=True)
            embed.add_field(name="üîç Status", value="Aguardando pagamento", inline=True)
            
            embed.set_footer(text=f"Payment ID: {payment_info['id']}")
            
            verificar_view = VerificarPagamentoPIXView(str(payment_info['id']), interaction.user.id, self.plano, self.modalidade)
            
            await interaction.followup.send(embed=embed, view=verificar_view, ephemeral=True)
            
        except Exception as e:
            print(f"Erro no pagamento PIX: {e}")
            await interaction.followup.send("‚ùå Erro interno. Tente novamente mais tarde.", ephemeral=True)

class VerificarPagamentoView(View):
    def __init__(self, external_reference, user_id, plano, modalidade):
        super().__init__(timeout=1800)
        self.external_reference = external_reference
        self.user_id = user_id
        self.plano = plano
        self.modalidade = modalidade

    @discord.ui.button(label="üîÑ Verificar Pagamento", style=discord.ButtonStyle.secondary)
    async def verificar_pagamento_btn(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.defer(ephemeral=True)
        
        try:
            pagamento = verificar_pagamento_por_referencia(self.external_reference)
            
            if not pagamento:
                await interaction.followup.send("‚è≥ Nenhum pagamento encontrado ainda. Se voc√™ acabou de pagar, aguarde alguns minutos.", ephemeral=True)
                return
            
            if pagamento["status"] == "approved":
                plano_ativado = ativar_plano_apos_pagamento(self.user_id, self.plano, self.modalidade)
                
                if not plano_ativado:
                    await interaction.followup.send("‚ùå Erro ao ativar plano. Contate o suporte.", ephemeral=True)
                    return
                
                guild_member = interaction.guild.get_member(self.user_id)
                if guild_member:
                    await assign_role_to_member(guild_member, self.plano["tipo"])
                
                preco_pago = self.plano['preco'] if self.modalidade == "mensal" else self.plano['preco'] * 1.5
                
                embed = discord.Embed(
                    title="‚úÖ PAGAMENTO APROVADO!",
                    description=f"Seu plano **{self.plano['descricao']}** foi ativado com sucesso!",
                    color=discord.Color.green()
                )
                embed.add_field(name="üìÖ Validade", value="30 dias", inline=True)
                embed.add_field(name="üí∞ Valor Pago", value=f"R$ {preco_pago:.2f}", inline=True)
                embed.add_field(name="üéØ Modalidade", value=self.modalidade.capitalize(), inline=True)
                
                for item in self.children:
                    item.disabled = True
                
                await interaction.followup.send(embed=embed, view=self)
                
            elif pagamento["status"] == "pending":
                await interaction.followup.send("‚è≥ Pagamento ainda processando. Aguarde alguns minutos e tente novamente.", ephemeral=True)
                
            elif pagamento["status"] == "rejected":
                embed = discord.Embed(
                    title="‚ùå Pagamento Rejeitado",
                    description="Seu pagamento foi rejeitado. Tente novamente ou use outro m√©todo.",
                    color=discord.Color.red()
                )
                await interaction.followup.send(embed=embed, ephemeral=True)
                
            else:
                await interaction.followup.send(f"Status: {pagamento['status']}. Continue aguardando ou tente novamente.", ephemeral=True)
        
        except Exception as e:
            print(f"Erro ao verificar pagamento: {e}")
            await interaction.followup.send("‚ùå Erro ao verificar pagamento. Tente novamente.", ephemeral=True)

class VerificarPagamentoPIXView(View):
    def __init__(self, payment_id, user_id, plano, modalidade):
        super().__init__(timeout=1800)
        self.payment_id = payment_id
        self.user_id = user_id
        self.plano = plano
        self.modalidade = modalidade

    @discord.ui.button(label="üîÑ Verificar PIX", style=discord.ButtonStyle.secondary)
    async def verificar_pix_btn(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.defer(ephemeral=True)
        
        try:
            pagamento = verificar_pagamento_pix(self.payment_id)
            
            if not pagamento:
                await interaction.followup.send("‚è≥ Erro ao verificar pagamento. Tente novamente.", ephemeral=True)
                return
            
            if pagamento["status"] == "approved":
                plano_ativado = ativar_plano_apos_pagamento(self.user_id, self.plano, self.modalidade)
                
                if not plano_ativado:
                    await interaction.followup.send("‚ùå Erro ao ativar plano. Contate o suporte.", ephemeral=True)
                    return
                
                guild_member = interaction.guild.get_member(self.user_id)
                if guild_member:
                    await assign_role_to_member(guild_member, self.plano["tipo"])
                
                # Atualizar status no banco PIX
                pix_db = load_pix_db()
                if self.payment_id in pix_db:
                    pix_db[self.payment_id]["status"] = "approved"
                    save_pix_db(pix_db)
                
                embed = discord.Embed(
                    title="‚úÖ PIX CONFIRMADO!",
                    description=f"Seu plano **{self.plano['descricao']}** foi ativado!",
                    color=discord.Color.green()
                )
                embed.add_field(name="üìÖ Validade", value="30 dias", inline=True)
                embed.add_field(name="üí∞ Valor", value=f"R$ {pix_db[self.payment_id]['amount']:.2f}", inline=True)
                embed.add_field(name="üéØ Modalidade", value=self.modalidade.capitalize(), inline=True)
                
                for item in self.children:
                    item.disabled = True
                
                await interaction.followup.send(embed=embed, view=self)
                
            elif pagamento["status"] == "pending":
                await interaction.followup.send("‚è≥ PIX ainda n√£o confirmado. Aguarde alguns minutos ap√≥s o pagamento.", ephemeral=True)
                
            else:
                await interaction.followup.send(f"Status PIX: {pagamento['status']}. Continue aguardando.", ephemeral=True)
        
        except Exception as e:
            print(f"Erro ao verificar PIX: {e}")
            await interaction.followup.send("‚ùå Erro ao verificar PIX. Tente novamente.", ephemeral=True)

class CancelarPlanoView(View):
    def __init__(self, planos_ativos):
        super().__init__(timeout=300)
        self.planos_ativos = planos_ativos
        
        options = []
        for i, plano in enumerate(planos_ativos):
            modalidade = plano.get("modalidade", "mensal")
            dias_restantes = (plano.get("data_fim", 0) - int(time.time())) // 86400
            
            taxa = calcular_taxa_cancelamento(plano.get("data_inicio", 0), modalidade == "unico")
            taxa_texto = f"Taxa: {int(taxa*100)}%" if taxa > 0 else "Sem taxa"
            
            options.append(discord.SelectOption(
                label=f"{plano['descricao']} ({modalidade})",
                value=str(i),
                description=f"{dias_restantes} dias restantes - {taxa_texto}",
                emoji="üî¥" if taxa > 0 else "üü¢"
            ))
        
        if options:
            self.select = discord.ui.Select(
                placeholder="Escolha o plano para cancelar...",
                options=options[:25],
                min_values=1,
                max_values=1
            )
            self.select.callback = self.select_callback
            self.add_item(self.select)
    
    async def select_callback(self, interaction: discord.Interaction):
        selected_index = int(self.select.values[0])
        plano_selecionado = self.planos_ativos[selected_index]
        
        modalidade = plano_selecionado.get("modalidade", "mensal")
        taxa = calcular_taxa_cancelamento(plano_selecionado.get("data_inicio", 0), modalidade == "unico")
        dias_desde_compra = (int(time.time()) - plano_selecionado.get("data_inicio", 0)) // 86400
        
        embed = discord.Embed(
            title="‚ö†Ô∏è Confirma√ß√£o de Cancelamento",
            description=f"**Plano:** {plano_selecionado['descricao']}\n**Modalidade:** {modalidade.capitalize()}",
            color=discord.Color.orange()
        )
        
        if taxa > 0:
            embed.add_field(
                name="üí∞ Taxa de Cancelamento",
                value=f"**{int(taxa*100)}%** do valor pago\n*Comprado h√° {dias_desde_compra} dias*",
                inline=False
            )
            embed.add_field(
                name="üìã Motivo da Taxa:",
                value="‚Ä¢ Cancelamento antes de 2 meses" + (" (Pagamento √∫nico)" if modalidade == "unico" else ""),
                inline=False
            )
        else:
            embed.add_field(
                name="‚úÖ Sem Taxa",
                value="Cancelamento ap√≥s 2 meses da compra",
                inline=False
            )
        
        embed.add_field(
            name="‚ö†Ô∏è ATEN√á√ÉO:",
            value="‚Ä¢ Plano ser√° cancelado imediatamente\n‚Ä¢ Acesso ser√° removido\n‚Ä¢ N√£o h√° reembolso al√©m da taxa",
            inline=False
        )
        
        view = ConfirmarCancelamentoView(plano_selecionado)
        await interaction.response.send_message(embed=embed, view=view, ephemeral=True)

class ConfirmarCancelamentoView(View):
    def __init__(self, plano):
        super().__init__(timeout=300)
        self.plano = plano

    @discord.ui.button(label="‚úÖ Confirmar Cancelamento", style=discord.ButtonStyle.danger)
    async def confirmar_cancelamento(self, interaction: discord.Interaction, button: discord.ui.Button):
        try:
            db = load_planos_db()
            
            # Remover o plano do banco de dados
            db = [p for p in db if not (p["user_id"] == self.plano["user_id"] and p["id_plano"] == self.plano["id_plano"])]
            save_planos_db(db)
            
            # Remover cargo do usu√°rio
            guild_member = interaction.guild.get_member(self.plano["user_id"])
            if guild_member:
                role_name = self.plano["tipo"].capitalize()
                role = discord.utils.get(guild_member.guild.roles, name=role_name)
                if role and role in guild_member.roles:
                    await guild_member.remove_roles(role)
            
            modalidade = self.plano.get("modalidade", "mensal")
            taxa = calcular_taxa_cancelamento(self.plano.get("data_inicio", 0), modalidade == "unico")
            
            embed = discord.Embed(
                title="‚úÖ Plano Cancelado",
                description=f"Seu plano **{self.plano['descricao']}** foi cancelado com sucesso.",
                color=discord.Color.red()
            )
            
            if taxa > 0:
                embed.add_field(
                    name="üí∞ Taxa Aplicada",
                    value=f"{int(taxa*100)}% conforme pol√≠tica de cancelamento",
                    inline=False
                )
            
            embed.add_field(
                name="üìã Informa√ß√µes:",
                value="‚Ä¢ Acesso removido imediatamente\n‚Ä¢ Cargo Discord removido\n‚Ä¢ Para reativar, fa√ßa uma nova compra",
                inline=False
            )
            
            for item in self.children:
                item.disabled = True
            
            await interaction.response.send_message(embed=embed, view=self, ephemeral=True)
            
        except Exception as e:
            print(f"Erro ao cancelar plano: {e}")
            await interaction.response.send_message("‚ùå Erro ao cancelar plano. Tente novamente.", ephemeral=True)

    @discord.ui.button(label="‚ùå Manter Plano", style=discord.ButtonStyle.secondary)
    async def manter_plano(self, interaction: discord.Interaction, button: discord.ui.Button):
        embed = discord.Embed(
            title="‚úÖ Cancelamento Abortado",
            description="Seu plano foi mantido e continua ativo.",
            color=discord.Color.green()
        )
        
        for item in self.children:
            item.disabled = True
        
        await interaction.response.send_message(embed=embed, view=self, ephemeral=True)

class ComprarViewCompleta(View):
    def __init__(self, plano):
        super().__init__(timeout=300)
        self.plano = plano

    @discord.ui.button(label="üí∞ Comprar Plano", style=discord.ButtonStyle.green)
    async def comprar_plano(self, interaction: discord.Interaction, button: discord.ui.Button):
        user_id = interaction.user.id
        
        try:
            db = load_planos_db()
            agora = int(time.time())
            
            for plano_ativo in db:
                if (plano_ativo["user_id"] == user_id and 
                    plano_ativo["tipo"] == self.plano["tipo"] and 
                    plano_ativo.get("pago", False) and
                    plano_ativo.get("data_fim", 0) > agora):
                    await interaction.response.send_message(
                        f"‚ùå Voc√™ j√° possui um plano ativo do tipo **{self.plano['tipo']}**!", 
                        ephemeral=True
                    )
                    return
            
            embed = discord.Embed(
                title="üõçÔ∏è Escolha a Modalidade",
                description=f"**Plano:** {self.plano['descricao']}\n**Tipo:** {self.plano['tipo'].capitalize()}",
                color=discord.Color.blue()
            )
            
            embed.add_field(
                name="üí∞ Mensal",
                value=f"R$ {self.plano['preco']:.2f}/m√™s\n‚úÖ Cancelamento flex√≠vel",
                inline=True
            )
            
            embed.add_field(
                name="üíé Pagar 1 Vez",
                value=f"R$ {self.plano['preco'] * 1.5:.2f} (+50%)\n‚ö†Ô∏è Taxa de cancelamento",
                inline=True
            )
            
            view = EscolherModalidadeView(self.plano)
            await interaction.response.send_message(embed=embed, view=view, ephemeral=True)
        
        except Exception as e:
            print(f"Erro na compra: {e}")
            await interaction.response.send_message("‚ùå Erro interno. Tente novamente.", ephemeral=True)

class SelecionarPlanoView(View):
    def __init__(self):
        super().__init__(timeout=300)
        
        options = []
        for plano in PLANOS:
            emoji = "üî¥" if "Vermelho" in plano["descricao"] else "üü¢" if "Verde" in plano["descricao"] else "üîµ"
            
            desc = f"Tipo: {plano['tipo'].capitalize()}"
            if plano["id_plano"] == 2:
                desc += " - Alternado"
            elif plano["id_plano"] == 4:
                desc += " - Ilimitado"
            elif plano["id_plano"] == 8:
                desc += " - 2 posts/2 dias"
            
            options.append(discord.SelectOption(
                label=f"{plano['descricao']} - R$ {plano['preco']:.2f}",
                value=str(plano["id_plano"]),
                emoji=emoji,
                description=desc
            ))
        
        self.select = discord.ui.Select(
            placeholder="Escolha um plano...",
            options=options[:25],
            min_values=1,
            max_values=1
        )
        self.select.callback = self.select_callback
        self.add_item(self.select)
    
    async def select_callback(self, interaction: discord.Interaction):
        selected_id = int(self.select.values[0])
        plano = next((p for p in PLANOS if p["id_plano"] == selected_id), None)
        
        if plano:
            embed = discord.Embed(
                title=f"üí∞ {plano['descricao']}",
                description=f"**Pre√ßo:** R$ {plano['preco']:.2f} (mensal)\n**Tipo:** {plano['tipo'].capitalize()}",
                color=discord.Color.green()
            )
            
            if plano["id_plano"] == 2:
                embed.add_field(name="üìÖ Postagem", value="Alternada (hoje n√£o, amanh√£ sim)", inline=True)
            elif plano["id_plano"] == 8:
                embed.add_field(name="üìÖ Postagem", value="2 posts a cada 2 dias", inline=True)
            elif "dias_post" in plano:
                if plano["dias_post"] == 1:
                    embed.add_field(name="üìÖ Postagem", value="Di√°ria", inline=True)
                else:
                    embed.add_field(name="üìÖ Postagem", value=f"A cada {plano['dias_post']} dias", inline=True)
            
            if "tags" in plano:
                if plano["tags"] == "ilimitado":
                    embed.add_field(name="üè∑Ô∏è Destaques", value="Ilimitados", inline=True)
                elif "posts_necessarios" in plano:
                    embed.add_field(name="üè∑Ô∏è Destaques", value=f"{plano['tags']} a cada {plano['posts_necessarios']} posts", inline=True)
                else:
                    embed.add_field(name="üè∑Ô∏è Tags", value=str(plano["tags"]), inline=True)
            
            embed.add_field(name="‚è∞ Dura√ß√£o", value="30 dias", inline=True)
            embed.set_footer(text="Escolha entre modalidade mensal ou pagamento √∫nico")
            
            view = ComprarViewCompleta(plano)
            await interaction.response.send_message(embed=embed, view=view, ephemeral=True)

        # ================== CORRE√á√ïES - ADICIONAR ESTAS FUN√á√ïES ==================

# 1. CORRIGIR FUN√á√ÉO DE CARGOS - SUBSTITUIR A EXISTENTE
async def assign_role_to_member(member: discord.Member, tipo: str):
    """VERS√ÉO CORRIGIDA - USA CARGOS EXISTENTES"""
    try:
        role_name = tipo.capitalize()  # vendedor -> Vendedor
        
        # BUSCAR cargo existente no servidor
        role = discord.utils.get(member.guild.roles, name=role_name)
        
        if not role:
            print(f"‚ùå Cargo '{role_name}' n√£o encontrado no servidor")
            return False
        
        if role not in member.roles:
            await member.add_roles(role)
            print(f"‚úÖ Cargo '{role_name}' atribu√≠do a {member.display_name}")
        
        return True
        
    except Exception as e:
        print(f"‚ùå Erro ao atribuir cargo: {e}")
        return False

# 2. NOVA VIEW PARA MODALIDADES (CORRIGIR BOT√ÉO "PAGAR 1 VEZ")
# ================== CORRE√á√ïES PRINCIPAIS ==================

# 1. ERRO NO BOT√ÉO "PAGAR 1 VEZ" - Typo no ephemeral
class EscolherModalidadeView(View):
    def __init__(self, plano):
        super().__init__(timeout=300)
        self.plano = plano

    @discord.ui.button(label="üí∞ Mensal", style=discord.ButtonStyle.green)
    async def modalidade_mensal(self, interaction: discord.Interaction, button: discord.ui.Button):
        embed = discord.Embed(
            title=f"üí∞ Plano Mensal",
            description=f"**Plano:** {self.plano['descricao']}\n**Pre√ßo:** R$ {self.plano['preco']:.2f}/m√™s",
            color=discord.Color.green()
        )
        embed.add_field(name="‚úÖ Vantagens", value="‚Ä¢ Cancelamento ap√≥s 2 meses sem taxa", inline=False)
        
        view = EscolherPagamentoView(self.plano, "mensal")
        await interaction.response.send_message(embed=embed, view=view, ephemeral=True)

    @discord.ui.button(label="üíé Pagar 1 Vez (+50%)", style=discord.ButtonStyle.blurple)
    async def modalidade_unica(self, interaction: discord.Interaction, button: discord.ui.Button):
        preco_unico = self.plano['preco'] * 1.5
        embed = discord.Embed(
            title=f"üíé Pagamento √önico",
            description=f"**Plano:** {self.plano['descricao']}\n**Pre√ßo:** R$ {preco_unico:.2f} (√∫nica vez)",
            color=discord.Color.purple()
        )
        embed.add_field(
            name="‚ö†Ô∏è Taxa de Cancelamento",
            value="‚Ä¢ Antes de 2 meses: **100% de taxa**\n‚Ä¢ V√°lido por 30 dias",
            inline=False
        )
        
        view = EscolherPagamentoView(self.plano, "unico")
        # ERRO ESTAVA AQUI: ephemeal -> ephemeral
        await interaction.response.send_message(embed=embed, view=view, ephemeral=True)

# 2. FUN√á√ÉO DE SALVAR PAGAMENTO CART√ÉO CORRIGIDA
def salvar_preferencia_pendente(preference_data, user_id, plano, modalidade="mensal"):
    try:
        payments_db = load_payments_db()
        
        # Calcular pre√ßo final baseado na modalidade
        preco_final = plano["preco"]
        if modalidade == "unico":
            preco_final = plano["preco"] * 1.5
        
        payment_record = {
            "preference_id": preference_data["id"],
            "user_id": user_id,
            "plano": plano,
            "modalidade": modalidade,  # ADICIONAR modalidade
            "amount": preco_final,     # USAR pre√ßo correto
            "status": "pending",
            "created_date": preference_data["date_created"],
            "checkout_link": preference_data["init_point"],
            "external_reference": preference_data.get("external_reference")
        }
        
        payments_db[str(preference_data["id"])] = payment_record
        save_payments_db(payments_db)
        return payment_record
    except Exception as e:
        print(f"Erro ao salvar prefer√™ncia pendente: {e}")
        return None

# 3. VIEW DE PAGAMENTO CORRIGIDA
class EscolherPagamentoView(View):
    def __init__(self, plano, modalidade):
        super().__init__(timeout=300)
        self.plano = plano
        self.modalidade = modalidade

    @discord.ui.button(label="üí≥ Cart√£o/D√©bito", style=discord.ButtonStyle.primary)
    async def pagamento_cartao(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.defer(ephemeral=True)
        
        try:
            preferencia = criar_preferencia_pagamento(self.plano, interaction.user.id, interaction.user.display_name, self.modalidade)
            
            if not preferencia:
                await interaction.followup.send("‚ùå Erro ao criar link de pagamento.", ephemeral=True)
                return
            
            # SALVAR COM MODALIDADE
            payment_record = salvar_preferencia_pendente(preferencia, interaction.user.id, self.plano, self.modalidade)
            
            preco_final = self.plano['preco'] if self.modalidade == "mensal" else self.plano['preco'] * 1.5
            
            embed = discord.Embed(
                title="üí≥ Pagamento com Cart√£o",
                description=f"**Plano:** {self.plano['descricao']}\n**Modalidade:** {self.modalidade.capitalize()}\n**Valor:** R$ {preco_final:.2f}",
                color=discord.Color.blue()
            )
            
            embed.add_field(
                name="üîó Link para Pagamento:",
                value=f"[**CLIQUE AQUI PARA PAGAR**]({preferencia['init_point']})",
                inline=False
            )
            
            verificar_view = VerificarPagamentoView(preferencia["external_reference"], interaction.user.id, self.plano, self.modalidade)
            await interaction.followup.send(embed=embed, view=verificar_view, ephemeral=True)
            
        except Exception as e:
            print(f"Erro no pagamento cart√£o: {e}")
            await interaction.followup.send("‚ùå Erro interno.", ephemeral=True)

    @discord.ui.button(label="üì± PIX", style=discord.ButtonStyle.success)
    async def pagamento_pix(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.defer(ephemeral=True)
        
        try:
            payment_info, pix_record = criar_pagamento_pix(self.plano, interaction.user.id, interaction.user.display_name, self.modalidade)
            
            if not payment_info or not pix_record:
                await interaction.followup.send("‚ùå Erro ao criar pagamento PIX.", ephemeral=True)
                return
            
            embed = discord.Embed(
                title="üì± Pagamento PIX",
                description=f"**Plano:** {self.plano['descricao']}\n**Modalidade:** {self.modalidade.capitalize()}\n**Valor:** R$ {pix_record['amount']:.2f}",
                color=discord.Color.green()
            )
            
            embed.add_field(
                name="üîó C√≥digo PIX:",
                value=f"```{pix_record['qr_code']}```",
                inline=False
            )
            
            verificar_view = VerificarPagamentoPIXView(str(payment_info['id']), interaction.user.id, self.plano, self.modalidade)
            await interaction.followup.send(embed=embed, view=verificar_view, ephemeral=True)
            
        except Exception as e:
            print(f"Erro no pagamento PIX: {e}")
            await interaction.followup.send("‚ùå Erro interno PIX.", ephemeral=True)

# 4. VERIFICA√á√ÉO DE PAGAMENTO CORRIGIDA
class VerificarPagamentoView(View):
    def __init__(self, external_reference, user_id, plano, modalidade):
        super().__init__(timeout=1800)
        self.external_reference = external_reference
        self.user_id = user_id
        self.plano = plano
        self.modalidade = modalidade

    @discord.ui.button(label="üîÑ Verificar Pagamento", style=discord.ButtonStyle.secondary)
    async def verificar_pagamento_btn(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.defer(ephemeral=True)
        
        try:
            pagamento = verificar_pagamento_por_referencia(self.external_reference)
            
            if not pagamento:
                await interaction.followup.send("‚è≥ Nenhum pagamento encontrado ainda.", ephemeral=True)
                return
            
            if pagamento["status"] == "approved":
                plano_ativado = ativar_plano_apos_pagamento(self.user_id, self.plano, self.modalidade)
                
                if not plano_ativado:
                    await interaction.followup.send("‚ùå Erro ao ativar plano.", ephemeral=True)
                    return
                
                guild_member = interaction.guild.get_member(self.user_id)
                if guild_member:
                    await assign_role_to_member(guild_member, self.plano["tipo"])
                
                # ATUALIZAR STATUS NO BANCO
                payments_db = load_payments_db()
                for payment_id, payment_data in payments_db.items():
                    if payment_data.get("external_reference") == self.external_reference:
                        payment_data["status"] = "approved"
                        save_payments_db(payments_db)
                        break
                
                preco_pago = self.plano['preco'] if self.modalidade == "mensal" else self.plano['preco'] * 1.5
                
                embed = discord.Embed(
                    title="‚úÖ PAGAMENTO APROVADO!",
                    description=f"Seu plano **{self.plano['descricao']}** foi ativado!",
                    color=discord.Color.green()
                )
                embed.add_field(name="üí∞ Valor", value=f"R$ {preco_pago:.2f}", inline=True)
                embed.add_field(name="üéØ Modalidade", value=self.modalidade.capitalize(), inline=True)
                
                for item in self.children:
                    item.disabled = True
                
                await interaction.followup.send(embed=embed, view=self, ephemeral=True)
                
            elif pagamento["status"] == "pending":
                await interaction.followup.send("‚è≥ Pagamento ainda processando.", ephemeral=True)
            else:
                await interaction.followup.send(f"Status: {pagamento['status']}", ephemeral=True)
        
        except Exception as e:
            print(f"Erro ao verificar pagamento: {e}")
            await interaction.followup.send("‚ùå Erro ao verificar pagamento.", ephemeral=True)

# 5. SISTEMA DE CANCELAMENTO CORRIGIDO
class CancelarPlanoView(View):
    def __init__(self, planos_ativos):
        super().__init__(timeout=300)
        self.planos_ativos = planos_ativos
        
        if not planos_ativos:
            return
        
        options = []
        for i, plano in enumerate(planos_ativos):
            modalidade = plano.get("modalidade", "mensal")
            dias_restantes = (plano.get("data_fim", 0) - int(time.time())) // 86400
            
            taxa = calcular_taxa_cancelamento(plano.get("data_inicio", 0), modalidade == "unico")
            taxa_texto = f"Taxa: {int(taxa*100)}%" if taxa > 0 else "Sem taxa"
            
            options.append(discord.SelectOption(
                label=f"{plano['descricao']} ({modalidade})",
                value=str(i),
                description=f"{dias_restantes} dias - {taxa_texto}",
                emoji="üî¥" if taxa > 0 else "üü¢"
            ))
        
        if options:
            self.select = discord.ui.Select(
                placeholder="Escolha o plano para cancelar...",
                options=options[:25]
            )
            self.select.callback = self.select_callback
            self.add_item(self.select)
    
    async def select_callback(self, interaction: discord.Interaction):
        try:
            selected_index = int(self.select.values[0])
            plano_selecionado = self.planos_ativos[selected_index]
            
            modalidade = plano_selecionado.get("modalidade", "mensal")
            taxa = calcular_taxa_cancelamento(plano_selecionado.get("data_inicio", 0), modalidade == "unico")
            
            embed = discord.Embed(
                title="‚ö†Ô∏è Confirma√ß√£o de Cancelamento",
                description=f"**Plano:** {plano_selecionado['descricao']}\n**Modalidade:** {modalidade.capitalize()}",
                color=discord.Color.orange()
            )
            
            if taxa > 0:
                embed.add_field(
                    name="üí∞ Taxa de Cancelamento",
                    value=f"**{int(taxa*100)}%** do valor pago",
                    inline=False
                )
            else:
                embed.add_field(
                    name="‚úÖ Sem Taxa",
                    value="Cancelamento ap√≥s 2 meses da compra",
                    inline=False
                )
            
            view = ConfirmarCancelamentoView(plano_selecionado)
            await interaction.response.send_message(embed=embed, view=view, ephemeral=True)
            
        except Exception as e:
            print(f"Erro no select callback: {e}")
            await interaction.response.send_message("‚ùå Erro ao processar sele√ß√£o.", ephemeral=True)

class ConfirmarCancelamentoView(View):
    def __init__(self, plano):
        super().__init__(timeout=300)
        self.plano = plano

    @discord.ui.button(label="‚úÖ Confirmar Cancelamento", style=discord.ButtonStyle.danger)
    async def confirmar_cancelamento(self, interaction: discord.Interaction, button: discord.ui.Button):
        try:
            db = load_planos_db()
            
            # REMOVER PLANO CORRETAMENTE
            db_filtrado = []
            plano_removido = False
            
            for p in db:
                if (p["user_id"] == self.plano["user_id"] and 
                    p["id_plano"] == self.plano["id_plano"] and
                    p.get("data_inicio") == self.plano.get("data_inicio")):
                    plano_removido = True
                    continue
                db_filtrado.append(p)
            
            if not plano_removido:
                await interaction.response.send_message("‚ùå Plano n√£o encontrado.", ephemeral=True)
                return
            
            save_planos_db(db_filtrado)
            
            # REMOVER CARGO
            guild_member = interaction.guild.get_member(self.plano["user_id"])
            if guild_member:
                role_name = self.plano["tipo"].capitalize()
                role = discord.utils.get(guild_member.guild.roles, name=role_name)
                if role and role in guild_member.roles:
                    await guild_member.remove_roles(role)
            
            embed = discord.Embed(
                title="‚úÖ Plano Cancelado",
                description=f"Seu plano **{self.plano['descricao']}** foi cancelado.",
                color=discord.Color.red()
            )
            
            for item in self.children:
                item.disabled = True
            
            await interaction.response.send_message(embed=embed, view=self, ephemeral=True)
            
        except Exception as e:
            print(f"Erro ao cancelar plano: {e}")
            await interaction.response.send_message("‚ùå Erro ao cancelar plano.", ephemeral=True)

    @discord.ui.button(label="‚ùå Manter Plano", style=discord.ButtonStyle.secondary)
    async def manter_plano(self, interaction: discord.Interaction, button: discord.ui.Button):
        embed = discord.Embed(
            title="‚úÖ Cancelamento Abortado",
            description="Seu plano foi mantido e continua ativo.",
            color=discord.Color.green()
        )
        
        for item in self.children:
            item.disabled = True
        
        await interaction.response.send_message(embed=embed, view=self, ephemeral=True)

# 6. VERIFICA√á√ÉO AUTOM√ÅTICA CORRIGIDA
@tasks.loop(minutes=5)
async def verificar_pagamentos_automatico():
    """Verifica pagamentos pendentes automaticamente"""
    await bot.wait_until_ready()
    
    try:
        # Verificar pagamentos de cart√£o
        payments_db = load_payments_db()
        if payments_db:
            for payment_id, payment_data in payments_db.items():
                if payment_data["status"] == "pending":
                    external_ref = payment_data.get("external_reference")
                    if external_ref:
                        pagamento_atual = verificar_pagamento_por_referencia(external_ref)
                        
                        if pagamento_atual and pagamento_atual["status"] == "approved":
                            user_id = payment_data["user_id"]
                            plano = payment_data["plano"]
                            modalidade = payment_data.get("modalidade", "mensal")  # PEGAR MODALIDADE
                            
                            plano_ativado = ativar_plano_apos_pagamento(user_id, plano, modalidade)
                            
                            if plano_ativado:
                                # NOTIFICAR USU√ÅRIO E ATRIBUIR CARGO
                                for guild in bot.guilds:
                                    member = guild.get_member(user_id)
                                    if member:
                                        await assign_role_to_member(member, plano["tipo"])
                                        break
                                
                                payments_db[payment_id]["status"] = "approved"
                                save_payments_db(payments_db)
                                
                                print(f"‚úÖ Plano {plano['descricao']} ativado automaticamente para usu√°rio {user_id}")
        
        # Verificar pagamentos PIX
        pix_db = load_pix_db()
        if pix_db:
            for payment_id, pix_data in pix_db.items():
                if pix_data["status"] == "pending":
                    pagamento_pix = verificar_pagamento_pix(payment_id)
                    
                    if pagamento_pix and pagamento_pix["status"] == "approved":
                        user_id = pix_data["user_id"]
                        plano = pix_data["plano"]
                        modalidade = pix_data["modalidade"]
                        
                        plano_ativado = ativar_plano_apos_pagamento(user_id, plano, modalidade)
                        
                        if plano_ativado:
                            for guild in bot.guilds:
                                member = guild.get_member(user_id)
                                if member:
                                    await assign_role_to_member(member, plano["tipo"])
                                    break
                            
                            pix_db[payment_id]["status"] = "approved"
                            save_pix_db(pix_db)
                            
                            print(f"‚úÖ Plano PIX {plano['descricao']} ativado automaticamente")
    
    except Exception as e:
        print(f"Erro na verifica√ß√£o autom√°tica: {e}")

# 7. COMANDO STATUS COM CANCELAMENTO
@bot.command(name="status")
async def status_usuario(ctx):
    """Mostra status dos planos do usu√°rio com op√ß√£o de cancelamento"""
    try:
        user_id = ctx.author.id
        db = load_planos_db()
        
        embed = discord.Embed(
            title=f"üìä Meus Planos - {ctx.author.display_name}",
            color=discord.Color.blue()
        )
        
        agora = int(time.time())
        planos_ativos = []
        
        for plano in db:
            if plano["user_id"] == user_id and plano.get("pago", False):
                fim = plano.get("data_fim", agora)
                if fim > agora:
                    planos_ativos.append(plano)
        
        if planos_ativos:
            ativo_text = ""
            for plano in planos_ativos:
                fim = plano.get("data_fim", agora)
                dias_restantes = (fim - agora) // 86400
                modalidade = plano.get("modalidade", "mensal")
                ativo_text += f"‚Ä¢ **{plano['descricao']}** ({modalidade})\n  üìÖ {dias_restantes} dias restantes\n\n"
            
            embed.add_field(name="‚úÖ Planos Ativos", value=ativo_text, inline=False)
            
            # BOT√ÉO DE CANCELAMENTO
            view = View(timeout=300)
            cancelar_btn = discord.ui.Button(label="üóëÔ∏è Cancelar Plano", style=discord.ButtonStyle.danger)
            
            async def cancelar_callback(interaction):
                if interaction.user.id != user_id:
                    await interaction.response.send_message("‚ùå Voc√™ n√£o pode usar este bot√£o.", ephemeral=True)
                    return
                
                view_cancelar = CancelarPlanoView(planos_ativos)
                embed_cancelar = discord.Embed(
                    title="üóëÔ∏è Cancelar Plano",
                    description="Escolha o plano que deseja cancelar:",
                    color=discord.Color.orange()
                )
                await interaction.response.send_message(embed=embed_cancelar, view=view_cancelar, ephemeral=True)
            
            cancelar_btn.callback = cancelar_callback
            view.add_item(cancelar_btn)
        else:
            embed.description = "Nenhum plano ativo encontrado."
            view = None
        
        await ctx.send(embed=embed, view=view)
        
    except Exception as e:
        print(f"Erro ao mostrar status: {e}")
        await ctx.send("‚ùå Erro ao verificar status.")

# 3. CORRIGIR VIEW DE COMPRA PARA MOSTRAR MODALIDADES
class ComprarViewCompleta(View):
    def __init__(self, plano):
        super().__init__(timeout=300)
        self.plano = plano

    @discord.ui.button(label="üí∞ Comprar Plano", style=discord.ButtonStyle.green)
    async def comprar_plano(self, interaction: discord.Interaction, button: discord.ui.Button):
        user_id = interaction.user.id
        db = load_planos_db()
        agora = int(time.time())
        
        # Verificar se j√° tem plano ativo do mesmo tipo
        for plano_ativo in db:
            if (plano_ativo["user_id"] == user_id and 
                plano_ativo["tipo"] == self.plano["tipo"] and 
                plano_ativo.get("pago", False) and
                plano_ativo.get("data_fim", 0) > agora):
                await interaction.response.send_message(
                    f"‚ùå Voc√™ j√° possui um plano **{self.plano['tipo']}** ativo!", 
                    ephemeral=True
                )
                return
        
        # Mostrar op√ß√µes de modalidade
        embed = discord.Embed(
            title="üõçÔ∏è Escolha a Modalidade",
            description=f"**Plano:** {self.plano['descricao']}",
            color=discord.Color.blue()
        )
        embed.add_field(
            name="üí∞ Mensal",
            value=f"R$ {self.plano['preco']:.2f}/m√™s",
            inline=True
        )
        embed.add_field(
            name="üíé √önica (+50%)",
            value=f"R$ {self.plano['preco'] * 1.5:.2f}",
            inline=True
        )
        
        view = EscolherModalidadeView(self.plano)
        await interaction.response.send_message(embed=embed, view=view, ephemeral=True)

# 4. STATUS AUTOM√ÅTICO EM CANAL ESPEC√çFICO
async def enviar_status_automatico(guild: discord.Guild):
    """Envia status em canal espec√≠fico automaticamente"""
    try:
        canal_status = discord.utils.get(guild.channels, name="status-de-plano")
        
        if not canal_status:
            print("Canal 'status-de-plano' n√£o encontrado")
            return
        
        # Limpar mensagens antigas
        try:
            async for message in canal_status.history(limit=100):
                if message.author == bot.user:
                    await message.delete()
        except:
            pass
        
        db = load_planos_db()
        agora = int(time.time())
        
        embed = discord.Embed(
            title="üìä Status Geral de Planos",
            description="Atualiza√ß√µes autom√°ticas dos planos ativos",
            color=discord.Color.blue()
        )
        
        planos_ativos = 0
        usuarios_ativos = set()
        
        for plano in db:
            if plano.get("pago", False) and plano.get("data_fim", 0) > agora:
                planos_ativos += 1
                usuarios_ativos.add(plano["user_id"])
        
        embed.add_field(name="üìà Planos Ativos", value=str(planos_ativos), inline=True)
        embed.add_field(name="üë• Usu√°rios com Plano", value=str(len(usuarios_ativos)), inline=True)
        embed.add_field(name="üîÑ √öltima Atualiza√ß√£o", value="Agora", inline=True)
        
        embed.set_footer(text="Use !status para ver seus planos individuais")
        
        await canal_status.send(embed=embed)
        
    except Exception as e:
        print(f"Erro no status autom√°tico: {e}")

# 5. COMANDO STATUS INTEGRADO
@bot.command(name="status")
async def status_integrado(ctx):
    """Status com integra√ß√£o ao canal espec√≠fico"""
    try:
        user_id = ctx.author.id
        db = load_planos_db()
        
        embed = discord.Embed(
            title=f"üìä Seus Planos - {ctx.author.display_name}",
            color=discord.Color.blue()
        )
        
        agora = int(time.time())
        planos_ativos = []
        
        for plano in db:
            if plano["user_id"] == user_id and plano.get("pago", False):
                fim = plano.get("data_fim", agora)
                if fim > agora:
                    planos_ativos.append(plano)
        
        if planos_ativos:
            texto_planos = ""
            for plano in planos_ativos:
                fim = plano.get("data_fim", agora)
                dias_restantes = (fim - agora) // 86400
                modalidade = plano.get("modalidade", "mensal")
                texto_planos += f"‚Ä¢ **{plano['descricao']}** ({modalidade})\n  üìÖ {dias_restantes} dias restantes\n\n"
            
            embed.add_field(name="‚úÖ Planos Ativos", value=texto_planos, inline=False)
            
            # Bot√£o cancelar s√≥ se tem planos
            view = View(timeout=300)
            btn_cancelar = discord.ui.Button(label="üóëÔ∏è Cancelar Plano", style=discord.ButtonStyle.danger)
            
            async def cancelar_callback(interaction):
                if interaction.user.id != user_id:
                    await interaction.response.send_message("‚ùå N√£o √© seu plano.", ephemeral=True)
                    return
                
                view_cancelar = CancelarPlanoView(planos_ativos)
                embed_cancelar = discord.Embed(
                    title="üóëÔ∏è Cancelar Plano",
                    description="Escolha qual plano cancelar:",
                    color=discord.Color.orange()
                )
                await interaction.response.send_message(embed=embed_cancelar, view=view_cancelar, ephemeral=True)
            
            btn_cancelar.callback = cancelar_callback
            view.add_item(btn_cancelar)
        else:
            embed.description = "Nenhum plano ativo."
            view = None
        
        # Tentar enviar no canal status-de-plano tamb√©m
        try:
            canal_status = discord.utils.get(ctx.guild.channels, name="status-de-plano")
            if canal_status:
                embed_canal = embed.copy()
                embed_canal.set_footer(text=f"Status solicitado por {ctx.author.display_name}")
                await canal_status.send(embed=embed_canal)
        except:
            pass
        
        await ctx.send(embed=embed, view=view)
        
    except Exception as e:
        await ctx.send("‚ùå Erro ao verificar status.")

# 6. TASK PARA ATUALIZAR STATUS AUTOM√ÅTICO
@tasks.loop(hours=6)  # Atualiza a cada 6 horas
async def atualizar_status_automatico():
    """Atualiza status no canal auimport os

import json
import time
import random
import asyncio
import requests
from typing import List, Dict, Any
from datetime import datetime, timedelta
import pytz

import discord
from discord.ext import commands, tasks
from discord.ui import View, Button
from dotenv import load_dotenv
import mercadopago
import importlib
import importlib.util
import os

# ----------------- CONFIGURA√á√ïES -----------------
load_dotenv("arquivo.env")
DISCORD_TOKEN = os.getenv("DISCORD_TOKEN")
ML_TOKEN = os.getenv("ML_TOKEN")
ML_PUBLIC_KEY = os.getenv("ML_PUBLIC_KEY")

# Inicializar SDK do Mercado Pago
sdk = mercadopago.SDK(ML_TOKEN)

DB_FILE = "planos_ativos.json"
POST_DB = "posts.json"
PAYMENTS_DB = "pagamentos.json"

intents = discord.Intents.default()
intents.message_content = True
intents.guilds = True
intents.members = True
bot = commands.Bot(command_prefix="!", intents=intents, help_command=None)

# ----------------- PLANOS ATUALIZADOS CONFORME SOLICITADO -----------------
PLANOS = [
    {"id_plano": 1, "descricao": "Vendedor Vermelho üî¥", "tipo": "vendedor", "dias_post": 1, "preco": 25.00},
    {"id_plano": 2, "descricao": "Vendedor Verde üü¢", "tipo": "vendedor", "dias_post": 1, "alternado": True, "preco": 15.90},
    {"id_plano": 3, "descricao": "Vendedor Azul üîµ", "tipo": "vendedor", "dias_post": 2, "preco": 7.90},
    {"id_plano": 4, "descricao": "Destacar Vermelho üî¥", "tipo": "destacar", "tags": "ilimitado", "preco": 75.00},
    {"id_plano": 5, "descricao": "Destacar Verde üü¢", "tipo": "destacar", "tags": 2, "posts_necessarios": 10, "preco": 27.80},
    {"id_plano": 6, "descricao": "Destacar Azul üîµ", "tipo": "destacar", "tags": 1, "posts_necessarios": 10, "preco": 17.80},
    {"id_plano": 7, "descricao": "Comprador Vermelho üî¥", "tipo": "comprador", "dias_post": 1, "preco": 24.90},
    {"id_plano": 8, "descricao": "Comprador Verde üü¢", "tipo": "comprador", "dias_post": 2, "posts_por_periodo": 2, "preco": 12.00},
    {"id_plano": 9, "descricao": "Comprador Azul üîµ", "tipo": "comprador", "dias_post": 2, "preco": 9.50},
]

# Configura√ß√µes dos canais
CHANNEL_CONFIG = {
    "rede": "üõírede",
    "recomendacao": "üåürecomenda√ß√£o-do-caveira",
    "destaques": "üíØdestaques",
    "forum_assinaturas": "assinarüåü",
    "categoria_assinaturas": "üìÉüåüAssinaturas"
}

# ================== UTILIT√ÅRIOS JSON ==================
def load_json(path: str, default):
    try:
        with open(path, "r", encoding="utf-8") as f:
            return json.load(f)
    except FileNotFoundError:
        return default
    except json.JSONDecodeError:
        print(f"Erro ao ler {path}, usando valores padr√£o")
        return default

def save_json(path: str, data):
    try:
        with open(path, "w", encoding="utf-8") as f:
            json.dump(data, f, indent=4, ensure_ascii=False)
    except Exception as e:
        print(f"Erro ao salvar {path}: {e}")

def load_planos_db():
    return load_json(DB_FILE, [])

def save_planos_db(data):
    save_json(DB_FILE, data)

def load_payments_db():
    return load_json(PAYMENTS_DB, {})

def save_payments_db(data):
    save_json(PAYMENTS_DB, data)

def load_posts_db():
    return load_json(POST_DB, {})

def save_posts_db(data):
    save_json(POST_DB, data)

# ================== SISTEMA DE F√ìRUM PRIVADO ==================
async def obter_ou_criar_thread_privada(user: discord.Member, guild: discord.Guild):
    "Obt√©m ou cria uma thread privada no f√≥rum de assinaturas para o usu√°rio"""
    try:
        categoria = discord.utils.get(guild.categories, name=CHANNEL_CONFIG["categoria_assinaturas"])
        if not categoria:
            print(f"Categoria {CHANNEL_CONFIG['categoria_assinaturas']} n√£o encontrada")
            return None
        
        forum_channel = discord.utils.get(categoria.channels, name=CHANNEL_CONFIG["forum_assinaturas"])
        if not forum_channel:
            print(f"F√≥rum {CHANNEL_CONFIG['forum_assinaturas']} n√£o encontrado na categoria")
            return None
        
        if not isinstance(forum_channel, discord.ForumChannel):
            print(f"Canal {CHANNEL_CONFIG['forum_assinaturas']} n√£o √© um canal de f√≥rum")
            return None
        
        for thread in forum_channel.threads:
            if thread.name == f"Assinatura - {user.display_name}" or thread.owner_id == user.id:
                return thread
        
        try:
            embed = discord.Embed(
                title=f"üåü Assinatura Privada - {user.display_name}",
                description="Este √© seu espa√ßo privado de assinatura. Apenas voc√™ pode ver e interagir aqui.",
                color=discord.Color.gold()
            )
            embed.add_field(
                name="üìã Como usar:",
                value="‚Ä¢ Use `!status` para ver seus planos\n‚Ä¢ Use `!planos` para comprar novos planos\n‚Ä¢ Este chat √© totalmente privado",
                inline=False
            )
            embed.set_footer(text="Sistema de Assinaturas Privadas")
            
            thread = await forum_channel.create_thread(
                name=f"Assinatura - {user.display_name}",
                content="",
                embed=embed,
                auto_archive_duration=10080,
                slowmode_delay=0
            )
            
            overwrites = {
                guild.default_role: discord.PermissionOverwrite(read_messages=False, send_messages=False),
                user: discord.PermissionOverwrite(read_messages=True, send_messages=True),
                guild.me: discord.PermissionOverwrite(read_messages=True, send_messages=True)
            }
            
            await thread.thread.edit(overwrites=overwrites)
            await thread.thread.add_user(user)
            
            print(f"Thread privada criada para {user.display_name}")
            return thread.thread
            
        except discord.Forbidden:
            print(f"Sem permiss√£o para criar thread no f√≥rum")
            return None
        except Exception as e:
            print(f"Erro ao criar thread: {e}")
            return None
    
    except Exception as e:
        print(f"Erro no sistema de f√≥rum privado: {e}")
        return None

async def garantir_forum_configurado(guild: discord.Guild):
    """Garante que o f√≥rum e categoria est√£o configurados corretamente"""
    try:
        categoria = discord.utils.get(guild.categories, name=CHANNEL_CONFIG["categoria_assinaturas"])
        if not categoria:
            try:
                categoria = await guild.create_category(CHANNEL_CONFIG["categoria_assinaturas"])
                print(f"Categoria {CHANNEL_CONFIG['categoria_assinaturas']} criada")
            except discord.Forbidden:
                print("Sem permiss√£o para criar categoria")
                return False
        
        forum_channel = discord.utils.get(categoria.channels, name=CHANNEL_CONFIG["forum_assinaturas"])
        if not forum_channel:
            try:
                overwrites = {
                    guild.default_role: discord.PermissionOverwrite(
                        read_messages=True, 
                        send_messages=False,
                        create_public_threads=False,
                        create_private_threads=False
                    ),
                    guild.me: discord.PermissionOverwrite(
                        read_messages=True,
                        send_messages=True,
                        create_public_threads=True,
                        create_private_threads=True,
                        manage_threads=True
                    )
                }
                
                forum_channel = await categoria.create_forum(
                    CHANNEL_CONFIG["forum_assinaturas"],
                    topic="F√≥rum de assinaturas privadas - cada usu√°rio tem seu espa√ßo individual",
                    overwrites=overwrites,
                    slowmode_delay=60
                )
                print(f"F√≥rum {CHANNEL_CONFIG['forum_assinaturas']} criado")
            except discord.Forbidden:
                print("Sem permiss√£o para criar f√≥rum")
                return False
            except Exception as e:
                print(f"Erro ao criar f√≥rum: {e}")
                return False
        
        return True
    
    except Exception as e:
        print(f"Erro ao configurar f√≥rum: {e}")
        return False

def pode_postar(user_id: int, tipo_plano: str):
    """Verifica se o usu√°rio pode postar baseado no plano dele - VERS√ÉO ATUALIZADA"""
    db = load_planos_db()
    posts_db = load_posts_db()
    agora = int(time.time())
    
    # Verificar se tem plano ativo
    plano_ativo = None
    for plano in db:
        if (plano["user_id"] == user_id and 
            plano["tipo"] == tipo_plano and 
            plano.get("pago", False) and
            plano.get("data_fim", 0) > agora):
            plano_ativo = plano
            break
    
    if not plano_ativo:
        return False, "Voc√™ n√£o possui um plano ativo do tipo necess√°rio."
    
    # Buscar dados do plano
    plano_info = next((p for p in PLANOS if p["id_plano"] == plano_ativo["id_plano"]), None)
    if not plano_info:
        return False, "Erro: plano n√£o encontrado."
    
    user_posts = posts_db.get(str(user_id), {})
    ultimo_post = user_posts.get(f"ultimo_post_{tipo_plano}", 0)
    
    # VENDEDOR VERDE: Sistema alternado (hoje n√£o, amanh√£ sim)
    if plano_info["id_plano"] == 2:  # Vendedor Verde
        if ultimo_post == 0:  # Primeiro post
            return True, plano_ativo
            
        dias_desde_ultimo = (agora - ultimo_post) // 86400
        if dias_desde_ultimo == 0:  # Mesmo dia do √∫ltimo post
            return False, "Voc√™ pode postar novamente amanh√£ (sistema alternado)."
        elif dias_desde_ultimo >= 1:  # 1+ dias depois - pode postar
            return True, plano_ativo
    
    # COMPRADOR VERDE: 2 posts a cada 2 dias
    elif plano_info["id_plano"] == 8:  # Comprador Verde
        posts_por_periodo = plano_info.get("posts_por_periodo", 2)
        periodo = plano_info.get("dias_post", 2) * 86400  # 2 dias em segundos
        
        posts_no_periodo = user_posts.get(f"posts_periodo_{tipo_plano}", {"inicio": 0, "count": 0})
        
        # Se passou o per√≠odo, resetar contador
        if agora - posts_no_periodo["inicio"] >= periodo:
            posts_no_periodo = {"inicio": agora, "count": 0}
            user_posts[f"posts_periodo_{tipo_plano}"] = posts_no_periodo
            save_posts_db(posts_db)
        
        # Verificar se ainda pode postar no per√≠odo atual
        if posts_no_periodo["count"] >= posts_por_periodo:
            tempo_restante = periodo - (agora - posts_no_periodo["inicio"])
            horas_restantes = tempo_restante // 3600
            return False, f"Voc√™ j√° fez {posts_por_periodo} posts neste per√≠odo. Aguarde {horas_restantes} horas."
        
        return True, plano_ativo
    
    # OUTROS PLANOS: Sistema normal por dias
    else:
        dias_necessarios = plano_info.get("dias_post", 1)
        tempo_espera = dias_necessarios * 86400  # dias em segundos
        
        if agora - ultimo_post < tempo_espera:
            horas_restantes = (tempo_espera - (agora - ultimo_post)) // 3600
            return False, f"Voc√™ pode postar novamente em {horas_restantes} horas."
        
        return True, plano_ativo

def pode_usar_destaque(user_id: int):
    """Verifica se o usu√°rio pode usar a tag de destaque - VERS√ÉO ATUALIZADA"""
    db = load_planos_db()
    posts_db = load_posts_db()
    agora = int(time.time())
    
    # Verificar se tem plano ativo de destacar
    plano_destacar = None
    for plano in db:
        if (plano["user_id"] == user_id and 
            plano["tipo"] == "destacar" and 
            plano.get("pago", False) and
            plano.get("data_fim", 0) > agora):
            plano_destacar = plano
            break
    
    if not plano_destacar:
        return False, "Voc√™ precisa de um plano de destaque para usar esta tag."
    
    # Buscar dados do plano
    plano_info = next((p for p in PLANOS if p["id_plano"] == plano_destacar["id_plano"]), None)
    if not plano_info:
        return False, "Erro: plano n√£o encontrado."
    
    # PLANO VERMELHO: ILIMITADO
    if plano_info["id_plano"] == 4:  # Destacar Vermelho
        return True, plano_destacar
    
    user_posts = posts_db.get(str(user_id), {})
    
    # Para planos Verde e Azul de destaque, verificar posts na rede
    if "posts_necessarios" in plano_info:
        posts_rede = user_posts.get("posts_rede", 0)
        destaques_usados = user_posts.get("destaques_usados", 0)
        
        # Calcular quantos destaques pode usar
        destaques_disponiveis = (posts_rede // plano_info["posts_necessarios"]) * plano_info["tags"]
        
        if destaques_usados >= destaques_disponiveis:
            posts_faltantes = plano_info["posts_necessarios"] - (posts_rede % plano_info["posts_necessarios"])
            return False, f"Voc√™ precisa fazer mais {posts_faltantes} posts na üõírede para usar destaque novamente."
    
    return True, plano_destacar

def registrar_post(user_id: int, canal_tipo: str, tem_destaque: bool = False):
    """Registra um post do usu√°rio - VERS√ÉO ATUALIZADA"""
    posts_db = load_posts_db()
    user_posts = posts_db.get(str(user_id), {})
    agora = int(time.time())
    
    # Registrar √∫ltimo post por tipo
    if canal_tipo == "vendedor":
        user_posts["ultimo_post_vendedor"] = agora
        user_posts["posts_rede"] = user_posts.get("posts_rede", 0) + 1
    elif canal_tipo == "comprador":
        user_posts["ultimo_post_comprador"] = agora
        
        # Para comprador verde, atualizar contador do per√≠odo
        db = load_planos_db()
        for plano in db:
            if (plano["user_id"] == user_id and 
                plano["tipo"] == "comprador" and 
                plano.get("pago", False) and
                plano.get("data_fim", 0) > agora):
                
                plano_info = next((p for p in PLANOS if p["id_plano"] == plano["id_plano"]), None)
                if plano_info and plano_info["id_plano"] == 8:  # Comprador Verde
                    posts_no_periodo = user_posts.get("posts_periodo_comprador", {"inicio": 0, "count": 0})
                    posts_no_periodo["count"] += 1
                    user_posts["posts_periodo_comprador"] = posts_no_periodo
                break
    
    # Registrar uso de destaque
    if tem_destaque:
        user_posts["destaques_usados"] = user_posts.get("destaques_usados", 0) + 1
    
    posts_db[str(user_id)] = user_posts
    save_posts_db(posts_db)

async def mover_para_destaques(message: discord.Message):
    """Move uma mensagem com tag de destaque para o canal de destaques"""
    try:
        guild = message.guild
        canal_destaques = discord.utils.get(guild.channels, name=CHANNEL_CONFIG["destaques"])
        
        if not canal_destaques:
            print(f"Canal {CHANNEL_CONFIG['destaques']} n√£o encontrado")
            return
        
        embed = discord.Embed(
            title="üíØ Post em Destaque",
            description=message.content,
            color=discord.Color.gold()
        )
        embed.set_author(name=message.author.display_name, icon_url=message.author.avatar.url if message.author.avatar else None)
        embed.set_footer(text=f"Original em #{message.channel.name}")
        embed.timestamp = message.created_at
        
        if message.attachments:
            embed.set_image(url=message.attachments[0].url)
        
        await canal_destaques.send(embed=embed)
        print(f"Post de {message.author.display_name} movido para destaques")
        
    except Exception as e:
        print(f"Erro ao mover para destaques: {e}")

# ================== MERCADO PAGO ==================
def criar_assinatura_recorrente(plano: dict, user_id: int, username: str):
    """Cria assinatura recorrente mensal (s√≥ cart√£o)"""
    try:
        referencia = f"sub_{plano['id_plano']}_user_{user_id}_{int(time.time())}"
        
        subscription_data = {
            "reason": f"Assinatura {plano['descricao']}",
            "auto_recurring": {
                "frequency": 1,
                "frequency_type": "months",
                "transaction_amount": plano["preco"],
                "currency_id": "BRL"
            },
            "payer_email": f"user{user_id}@discord.bot",
            "card_token_id": "CARD_TOKEN",  # Obtido do frontend
            "status": "authorized",
            "external_reference": referencia
        }
        
        response = sdk.subscription().create(subscription_data)
        
        if response["status"] == 201:
            return response["response"]
        else:
            print(f"Erro ao criar assinatura: {response}")
            return None
            
    except Exception as e:
        print(f"Erro na assinatura recorrente: {e}")
        return None

def cancelar_assinatura_mp(subscription_id: str):
    """Cancela assinatura no Mercado Pago"""
    try:
        response = sdk.subscription().update(subscription_id, {"status": "cancelled"})
        return response["status"] == 200
    except Exception as e:
        print(f"Erro ao cancelar assinatura MP: {e}")
        return False
def gerar_chave_pix_aleatoria():
    import uuid
    return str(uuid.uuid4())

def criar_preferencia_pagamento(plano: dict, user_id: int, username: str):
    try:
        tz_brasil = pytz.timezone('America/Sao_Paulo')
        agora = datetime.now(tz_brasil)
        
        referencia = f"plano_{plano['id_plano']}_user_{user_id}_{int(time.time())}"
        nome_usuario = username[:50] if username else "Usuario Discord"
        
        preference_data = {
            "items": [
                {
                    "title": f"Plano {plano['descricao']}",
                    "quantity": 1,
                    "unit_price": plano["preco"],
                    "currency_id": "BRL",
                    "description": f"Plano {plano['tipo']} - Discord Bot"
                }
            ],
            "payer": {
                "name": nome_usuario,
                "surname": "Discord User"
            },
            "payment_methods": {
                "excluded_payment_methods": [],
                "excluded_payment_types": [],
                "installments": 12
            },
            "back_urls": {
                "success": "https://www.cleitodiscord.com/success",
                "failure": "https://www.cleitodiscord.com/failure", 
                "pending": "https://www.cleitodiscord.com/pending"
            },
            "auto_return": "approved",
            "external_reference": referencia,
            "statement_descriptor": "DISCORD_BOT",
            "expires": True,
            "expiration_date_from": agora.isoformat(),
            "expiration_date_to": (agora + timedelta(hours=24)).isoformat()
        }
        
        preference_response = sdk.preference().create(preference_data)
        
        if preference_response["status"] == 201:
            return preference_response["response"]
        else:
            print(f"Erro ao criar prefer√™ncia: {preference_response}")
            return None
    except Exception as e:
        print(f"Erro ao criar prefer√™ncia de pagamento: {e}")
        return None

def verificar_pagamento_por_referencia(external_reference):
    try:
        filters = {"external_reference": external_reference}
        search_response = sdk.payment().search(filters)
        
        if search_response["status"] == 200:
            results = search_response["response"]["results"]
            if results:
                return results[0]
        elif search_response["status"] == 429:
            print("Rate limit atingido - aguardando...")
            time.sleep(5)
            return None
        else:
            print(f"Erro na busca de pagamento: {search_response}")
        return None
    except Exception as e:
        print(f"Erro ao buscar pagamento: {e}")
        return None

def salvar_preferencia_pendente(preference_data, user_id, plano):
    try:
        payments_db = load_payments_db()
        
        payment_record = {
            "preference_id": preference_data["id"],
            "user_id": user_id,
            "plano": plano,
            "amount": plano["preco"],
            "status": "pending",
            "created_date": preference_data["date_created"],
            "checkout_link": preference_data["init_point"],
            "external_reference": preference_data.get("external_reference")
        }
        
        payments_db[str(preference_data["id"])] = payment_record
        save_payments_db(payments_db)
        return payment_record
    except Exception as e:
        print(f"Erro ao salvar prefer√™ncia pendente: {e}")
        return None

def ativar_plano_apos_pagamento(user_id: int, plano: dict):
    try:
        db = load_planos_db()
        
        timestamp = int(time.time())
        duracao = 30 * 86400  # 30 dias
        
        plano_registro = {
            "user_id": user_id,
            "id_plano": plano["id_plano"],
            "descricao": plano["descricao"],
            "tipo": plano["tipo"],
            "pago": True,
            "data_inicio": timestamp,
            "data_fim": timestamp + duracao
        }
        
        db.append(plano_registro)
        save_planos_db(db)
        return plano_registro
    except Exception as e:
        print(f"Erro ao ativar plano: {e}")
        return None

# ================== ROLES DISCORD ==================
async def ensure_role(guild: discord.Guild, name: str):
    role = discord.utils.get(guild.roles, name=name)
    if not role:
        try:
            role = await guild.create_role(name=name, color=discord.Color.blue())
            print(f"Cargo '{name}' criado no servidor {guild.name}")
        except discord.Forbidden:
            print(f"Sem permiss√£o para criar cargo: {name}")
            return None
        except Exception as e:
            print(f"Erro ao criar cargo {name}: {e}")
            return None
    return role

async def assign_role_to_member(member: discord.Member, tipo: str):
    try:
        role_name = tipo.capitalize()
        role = await ensure_role(member.guild, role_name)
        if role and role not in member.roles:
            await member.add_roles(role)
            print(f"Cargo '{role_name}' atribu√≠do a {member.display_name}")
            return True
        return True
    except discord.Forbidden:
        print(f"Sem permiss√£o para adicionar cargo a {member.display_name}")
        return False
    except Exception as e:
        print(f"Erro ao atribuir cargo: {e}")
        return False

# ================== VIEWS ==================
class StatusPlanoView(View):
    def __init__(self, user_id, planos_ativos):
        super().__init__(timeout=None)  # Permanente
        self.user_id = user_id
        self.planos_ativos = planos_ativos
        self.expandido = False

    @discord.ui.button(label="üëÄ Ver Mais", style=discord.ButtonStyle.secondary)
    async def ver_mais(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.user_id:
            await interaction.response.send_message("‚ùå N√£o √© seu painel.", ephemeral=True)
            return
        
        self.expandido = True
        button.label = "üìÑ Ver Menos"
        button.emoji = "üìÑ"
        
        embed = await self.gerar_embed_expandido()
        await interaction.response.edit_message(embed=embed, view=self)

    async def gerar_embed_expandido(self):
        """Gera embed com informa√ß√µes detalhadas"""
        db = load_planos_db()
        agora = int(time.time())
        
        embed = discord.Embed(
            title=f"üìä Hist√≥rico Completo - {interaction.user.display_name}",
            color=discord.Color.blue()
        )
        
        # Planos ativos
        if self.planos_ativos:
            texto_ativo = ""
            for plano in self.planos_ativos:
                dias_restantes = (plano.get("data_fim", 0) - agora) // 86400
                modalidade = plano.get("modalidade", "mensal")
                data_inicio = datetime.fromtimestamp(plano.get("data_inicio", 0)).strftime("%d/%m/%Y")
                texto_ativo += f"üü¢ **{plano['descricao']}** ({modalidade})\n"
                texto_ativo += f"   üìÖ Iniciado: {data_inicio}\n"
                texto_ativo += f"   ‚è∞ Restam: {dias_restantes} dias\n\n"
            
            embed.add_field(name="‚úÖ Planos Ativos", value=texto_ativo, inline=False)
        
        # Hist√≥rico de cancelamentos
        cancelamentos = []
        for plano in db:
            if (plano["user_id"] == self.user_id and 
                plano.get("cancelado", False)):
                cancelamentos.append(plano)
        
        if cancelamentos:
            texto_cancelado = ""
            for plano in cancelamentos[-5:]:  # √öltimos 5
                data_cancel = datetime.fromtimestamp(plano.get("data_cancelamento", 0)).strftime("%d/%m/%Y")
                taxa = plano.get("taxa_cancelamento", 0)
                modalidade = plano.get("modalidade", "mensal")
                texto_cancelado += f"üî¥ **{plano['descricao']}** ({modalidade})\n"
                texto_cancelado += f"   üìÖ Cancelado: {data_cancel}\n"
                texto_cancelado += f"   üí∞ Taxa: {int(taxa*100)}%\n\n"
            
            embed.add_field(name="‚ùå Cancelamentos (√∫ltimos 5)", value=texto_cancelado, inline=False)
        
        return embed

    @discord.ui.button(label="üóëÔ∏è Cancelar Plano", style=discord.ButtonStyle.danger)
    async def cancelar_plano(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.user_id:
            await interaction.response.send_message("‚ùå N√£o √© seu painel.", ephemeral=True)
            return
        
        if not self.planos_ativos:
            await interaction.response.send_message("‚ùå Nenhum plano ativo para cancelar.", ephemeral=True)
            return
        
        view = CancelarPlanoView(self.planos_ativos)
        embed = discord.Embed(
            title="üóëÔ∏è Cancelar Plano",
            description="Escolha qual plano cancelar:",
            color=discord.Color.orange()
        )
        await interaction.response.send_message(embed=embed, view=view, ephemeral=True)

    @discord.ui.button(label="üõí Comprar Assinaturas", style=discord.ButtonStyle.success)
    async def comprar_assinaturas(self, interaction: discord.Interaction, button: discord.ui.Button):
        # Redirecionar para comando !planos
        embed = discord.Embed(
            title="üõí Comprar Assinaturas",
            description="Use o comando `!planos` para ver todas as op√ß√µes dispon√≠veis.",
            color=discord.Color.green()
        )
        await interaction.response.send_message(embed=embed, ephemeral=True)
class EscolherModalidadeView(View):
    def __init__(self, plano):
        super().__init__(timeout=300)
        self.plano = plano

    @discord.ui.button(label="üí∞ Mensal", style=discord.ButtonStyle.green)
    async def modalidade_mensal(self, interaction: discord.Interaction, button: discord.ui.Button):
        embed = discord.Embed(
            title="üí∞ Assinatura Mensal",
            description=f"**Plano:** {self.plano['descricao']}\n**Pre√ßo:** R$ {self.plano['preco']:.2f}/m√™s",
            color=discord.Color.green()
        )
        embed.add_field(name="‚úÖ Vantagens", value="‚Ä¢ Cobran√ßa autom√°tica todo m√™s\n‚Ä¢ Cancelamento ap√≥s 2 meses sem taxa", inline=False)
        
        view = EscolherPagamentoView(self.plano, "mensal")
        await interaction.response.send_message(embed=embed, view=view, ephemeral=True)

    @discord.ui.button(label="üíé Pagar 1 Vez (+50%)", style=discord.ButtonStyle.blurple)
    async def modalidade_unica(self, interaction: discord.Interaction, button: discord.ui.Button):
        preco_unico = self.plano['preco'] * 1.5
        embed = discord.Embed(
            title="üíé Pagamento √önico",
            description=f"**Plano:** {self.plano['descricao']}\n**Pre√ßo:** R$ {preco_unico:.2f} (√∫nica vez)",
            color=discord.Color.purple()
        )
        embed.add_field(
            name="‚ö†Ô∏è Pol√≠tica de Cancelamento",
            value="‚Ä¢ Antes de 2 meses: 100% de taxa\n‚Ä¢ 2-6 meses: 35% de taxa\n‚Ä¢ Ap√≥s 6 meses: 15% de taxa",
            inline=False
        )
        
        view = EscolherPagamentoView(self.plano, "unico")
        await interaction.response.send_message(embed=embed, view=view, ephemeral=True)
class PagamentoViewCompleta(View):
    def __init__(self, plano):
        super().__init__(timeout=1800)
        self.plano = plano

    @discord.ui.button(label="üí≥ PIX/Cart√£o/D√©bito", style=discord.ButtonStyle.green, emoji="üí∞")
    async def abrir_checkout(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.defer(ephemeral=True)
        
        try:
            preferencia = criar_preferencia_pagamento(self.plano, interaction.user.id, interaction.user.display_name)
            
            if not preferencia:
                await interaction.followup.send("‚ùå Erro ao criar link de pagamento. Tente novamente em alguns minutos.", ephemeral=True)
                return
            
            payment_record = salvar_preferencia_pendente(preferencia, interaction.user.id, self.plano)
            
            if not payment_record:
                await interaction.followup.send("‚ùå Erro interno. Tente novamente.", ephemeral=True)
                return
            
            embed = discord.Embed(
                title="üí≥ Pagamento Criado!",
                description=f"**Plano:** {self.plano['descricao']}\n**Valor:** R$ {self.plano['preco']:.2f}",
                color=discord.Color.green()
            )
            
            embed.add_field(
                name="üí∞ Formas de Pagamento Dispon√≠veis:",
                value="‚Ä¢ PIX (aprova√ß√£o instant√¢nea)\n‚Ä¢ Cart√£o de Cr√©dito (at√© 12x)\n‚Ä¢ Cart√£o de D√©bito",
                inline=False
            )
            
            embed.add_field(
                name="üîó Link para Pagamento:",
                value=f"[**CLIQUE AQUI PARA PAGAR**]({preferencia['init_point']})",
                inline=False
            )
            
            embed.add_field(name="‚è∞ Validade", value="30 minutos", inline=True)
            embed.add_field(name="üîç Status", value="Aguardando pagamento", inline=True)
            
            embed.add_field(
                name="üìã Como pagar:",
                value="1. Clique no link acima\n2. Escolha: PIX, Cart√£o ou D√©bito\n3. Complete o pagamento\n4. Volte aqui e clique 'Verificar Pagamento'",
                inline=False
            )
            
            embed.set_footer(text=f"ID: {preferencia['id']} - Plano ativa ap√≥s confirma√ß√£o")
            
            verificar_view = VerificarPagamentoViewCompleta(preferencia["external_reference"], interaction.user.id, self.plano)
            
            await interaction.followup.send(embed=embed, view=verificar_view, ephemeral=True)
            
        except Exception as e:
            print(f"Erro no checkout: {e}")
            await interaction.followup.send("‚ùå Erro interno. Tente novamente mais tarde.", ephemeral=True)

class VerificarPagamentoViewCompleta(View):
    def __init__(self, external_reference, user_id, plano):
        super().__init__(timeout=1800)
        self.external_reference = external_reference
        self.user_id = user_id
        self.plano = plano

    @discord.ui.button(label="üîÑ Verificar Pagamento", style=discord.ButtonStyle.secondary)
    async def verificar_pagamento_btn(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.defer(ephemeral=True)
        
        try:
            pagamento = verificar_pagamento_por_referencia(self.external_reference)
            
            if not pagamento:
                await interaction.followup.send("‚è≥ Nenhum pagamento encontrado ainda. Se voc√™ acabou de pagar, aguarde alguns minutos.", ephemeral=True)
                return
            
            if pagamento["status"] == "approved":
                plano_ativado = ativar_plano_apos_pagamento(self.user_id, self.plano)
                
                if not plano_ativado:
                    await interaction.followup.send("‚ùå Erro ao ativar plano. Contate o suporte.", ephemeral=True)
                    return
                
                guild_member = interaction.guild.get_member(self.user_id)
                if guild_member:
                    await assign_role_to_member(guild_member, self.plano["tipo"])
                
                embed = discord.Embed(
                    title="‚úÖ PAGAMENTO APROVADO!",
                    description=f"Seu plano **{self.plano['descricao']}** foi ativado com sucesso!",
                    color=discord.Color.green()
                )
                embed.add_field(name="üìÖ Validade", value="30 dias", inline=True)
                embed.add_field(name="üí∞ Valor Pago", value=f"R$ {self.plano['preco']:.2f}", inline=True)
                embed.add_field(name="üéØ Tipo", value=self.plano['tipo'].capitalize(), inline=True)
                
                for item in self.children:
                    item.disabled = True
                
                await interaction.followup.send(embed=embed, view=self)
                
                payments_db = load_payments_db()
                for payment_id, payment_data in payments_db.items():
                    if payment_data.get("external_reference") == self.external_reference:
                        payment_data["status"] = "approved"
                        save_payments_db(payments_db)
                        break
                
            elif pagamento["status"] == "pending":
                await interaction.followup.send("‚è≥ Pagamento ainda processando. Aguarde alguns minutos e tente novamente.", ephemeral=True)
                
            elif pagamento["status"] == "rejected":
                embed = discord.Embed(
                    title="‚ùå Pagamento Rejeitado",
                    description="Seu pagamento foi rejeitado. Tente novamente ou use outro m√©todo.",
                    color=discord.Color.red()
                )
                await interaction.followup.send(embed=embed, ephemeral=True)
                
            else:
                await interaction.followup.send(f"Status: {pagamento['status']}. Continue aguardando ou tente novamente.", ephemeral=True)
        
        except Exception as e:
            print(f"Erro ao verificar pagamento: {e}")
            await interaction.followup.send("‚ùå Erro ao verificar pagamento. Tente novamente.", ephemeral=True)

class ComprarViewCompleta(View):
    def __init__(self, plano):
        super().__init__(timeout=300)
        self.plano = plano

    @discord.ui.button(label="üí∞ Comprar Plano", style=discord.ButtonStyle.green)
    async def comprar_plano(self, interaction: discord.Interaction, button: discord.ui.Button):
        user_id = interaction.user.id
        
        try:
            db = load_planos_db()
            agora = int(time.time())
            
            for plano_ativo in db:
                if (plano_ativo["user_id"] == user_id and 
                    plano_ativo["tipo"] == self.plano["tipo"] and 
                    plano_ativo.get("pago", False) and
                    plano_ativo.get("data_fim", 0) > agora):
                    await interaction.response.send_message(
                        f"‚ùå Voc√™ j√° possui um plano ativo do tipo **{self.plano['tipo']}**!", 
                        ephemeral=True
                    )
                    return
            
            embed = discord.Embed(
                title="üí≥ Finalizar Compra",
                description=f"**Plano:** {self.plano['descricao']}\n**üí∞ Valor:** R$ {self.plano['preco']:.2f}",
                color=discord.Color.blue()
            )
            
            info = f"**Tipo:** {self.plano['tipo'].capitalize()}\n"
            
            if self.plano["id_plano"] == 2:  # Vendedor Verde
                info += "üìÖ **Postagem:** Alternada (hoje n√£o, amanh√£ sim)\n"
            elif self.plano["id_plano"] == 8:  # Comprador Verde
                info += "üìÖ **Postagem:** 2 posts a cada 2 dias\n"
            elif "dias_post" in self.plano:
                if self.plano["dias_post"] == 1:
                    info += "üìÖ **Postagem:** Di√°ria\n"
                else:
                    info += f"üìÖ **Postagem:** A cada {self.plano['dias_post']} dias\n"
            
            if "tags" in self.plano:
                if self.plano["tags"] == "ilimitado":
                    info += "üè∑Ô∏è **Destaques:** Ilimitados\n"
                elif "posts_necessarios" in self.plano:
                    info += f"üè∑Ô∏è **Destaques:** {self.plano['tags']} a cada {self.plano['posts_necessarios']} posts\n"
                else:
                    info += f"üè∑Ô∏è **Tags dispon√≠veis:** {self.plano['tags']}\n"
            
            embed.add_field(name="‚ÑπÔ∏è Detalhes", value=info, inline=False)
            embed.add_field(name="‚è∞ Dura√ß√£o", value="30 dias", inline=True)
            embed.add_field(name="üí≥ Formas de Pagamento", value="PIX, Cart√£o Cr√©dito/D√©bito", inline=True)
            
            embed.set_footer(text="‚ö†Ô∏è Plano s√≥ √© ativado ap√≥s confirma√ß√£o do pagamento!")
            
            pagamento_view = PagamentoViewCompleta(self.plano)
            await interaction.response.send_message(embed=embed, view=pagamento_view, ephemeral=True)
        
        except Exception as e:
            print(f"Erro na compra: {e}")
            await interaction.response.send_message("‚ùå Erro interno. Tente novamente.", ephemeral=True)

class SelecionarPlanoView(View):
    def __init__(self):
        super().__init__(timeout=300)
        
        options = []
        for plano in PLANOS:
            emoji = "üî¥" if "Vermelho" in plano["descricao"] else "üü¢" if "Verde" in plano["descricao"] else "üîµ"
            
            # Descri√ß√£o personalizada para cada plano
            desc = f"Tipo: {plano['tipo'].capitalize()}"
            if plano["id_plano"] == 2:  # Vendedor Verde
                desc += " - Alternado"
            elif plano["id_plano"] == 4:  # Destacar Vermelho  
                desc += " - Ilimitado"
            elif plano["id_plano"] == 8:  # Comprador Verde
                desc += " - 2 posts/2 dias"
            
            options.append(discord.SelectOption(
                label=f"{plano['descricao']} - R$ {plano['preco']:.2f}",
                value=str(plano["id_plano"]),
                emoji=emoji,
                description=desc
            ))
        
        self.select = discord.ui.Select(
            placeholder="Escolha um plano...",
            options=options[:25],
            min_values=1,
            max_values=1
        )
        self.select.callback = self.select_callback
        self.add_item(self.select)
    
    async def select_callback(self, interaction: discord.Interaction):
        selected_id = int(self.select.values[0])
        plano = next((p for p in PLANOS if p["id_plano"] == selected_id), None)
        
        if plano:
            embed = discord.Embed(
                title=f"üí∞ {plano['descricao']}",
                description=f"**Pre√ßo:** R$ {plano['preco']:.2f}\n**Tipo:** {plano['tipo'].capitalize()}",
                color=discord.Color.green()
            )
            
            # Descri√ß√µes espec√≠ficas para cada plano
            if plano["id_plano"] == 2:  # Vendedor Verde
                embed.add_field(name="üìÖ Postagem", value="Alternada (hoje n√£o, amanh√£ sim)", inline=True)
            elif plano["id_plano"] == 8:  # Comprador Verde
                embed.add_field(name="üìÖ Postagem", value="2 posts a cada 2 dias", inline=True)
            elif "dias_post" in plano:
                if plano["dias_post"] == 1:
                    embed.add_field(name="üìÖ Postagem", value="Di√°ria", inline=True)
                else:
                    embed.add_field(name="üìÖ Postagem", value=f"A cada {plano['dias_post']} dias", inline=True)
            
            if "tags" in plano:
                if plano["tags"] == "ilimitado":
                    embed.add_field(name="üè∑Ô∏è Destaques", value="Ilimitados", inline=True)
                elif "posts_necessarios" in plano:
                    embed.add_field(name="üè∑Ô∏è Destaques", value=f"{plano['tags']} a cada {plano['posts_necessarios']} posts", inline=True)
                else:
                    embed.add_field(name="üè∑Ô∏è Tags", value=str(plano["tags"]), inline=True)
            
            embed.add_field(name="‚è∞ Dura√ß√£o", value="30 dias", inline=True)
            embed.set_footer(text="‚ö†Ô∏è Plano s√≥ √© ativado ap√≥s confirma√ß√£o do pagamento!")
            
            view = ComprarViewCompleta(plano)
            await interaction.response.send_message(embed=embed, view=view, ephemeral=True)

# ================== MONITORAMENTO DE MENSAGENS ==================
@bot.event
async def on_message(message):
    """Monitora mensagens para controlar posts e detectar tags de destaque"""
    if message.author.bot:
        return
    
    await bot.process_commands(message)
    
    # Verificar se √© um canal de postagem
    canal_nome = message.channel.name
    user_id = message.author.id
    
    # Post na rede (vendedores)
    if canal_nome == CHANNEL_CONFIG["rede"]:
        pode, resultado = pode_postar(user_id, "vendedor")
        if not pode:
            await message.delete()
            await message.channel.send(
                f"‚ùå {message.author.mention} {resultado}",
                delete_after=10
            )
            return
        
        # Verificar se tem tag de destaque
        tem_destaque = "üíØDestaques" in message.content
        
        if tem_destaque:
            pode_destacar, resultado_destaque = pode_usar_destaque(user_id)
            if not pode_destacar:
                # Remover apenas a tag, n√£o deletar a mensagem
                content_sem_tag = message.content.replace("üíØDestaques", "").strip()
                await message.edit(content=content_sem_tag)
                await message.channel.send(
                    f"‚ö†Ô∏è {message.author.mention} {resultado_destaque} A tag foi removida do seu post.",
                    delete_after=15
                )
                tem_destaque = False
        
        # Registrar o post
        registrar_post(user_id, "vendedor", tem_destaque)
        
        # Mover para destaques se necess√°rio
        if tem_destaque:
            await mover_para_destaques(message)
    
    # Post na recomenda√ß√£o (compradores)
    elif canal_nome == CHANNEL_CONFIG["recomendacao"]:
        pode, resultado = pode_postar(user_id, "comprador")
        if not pode:
            await message.delete()
            await message.channel.send(
                f"‚ùå {message.author.mention} {resultado}",
                delete_after=10
            )
            return
        
        # Compradores n√£o podem usar tag de destaque
        if "üíØDestaques" in message.content:
            content_sem_tag = message.content.replace("üíØDestaques", "").strip()
            await message.edit(content=content_sem_tag)
            await message.channel.send(
                f"‚ö†Ô∏è {message.author.mention} A tag de destaque n√£o √© permitida neste canal.",
                delete_after=10
            )
        
        # Registrar o post
        registrar_post(user_id, "comprador", False)

# ================== VERIFICA√á√ÉO AUTOM√ÅTICA DE PAGAMENTOS ==================
@tasks.loop(minutes=5)
async def verificar_pagamentos_automatico():
    """Verifica pagamentos pendentes automaticamente a cada 5 minutos"""
    await bot.wait_until_ready()
    
    try:
        payments_db = load_payments_db()
        if not payments_db:
            return
        
        for payment_id, payment_data in payments_db.items():
            if payment_data["status"] == "pending":
                external_ref = payment_data.get("external_reference")
                if external_ref:
                    pagamento_atual = verificar_pagamento_por_referencia(external_ref)
                    
                    if pagamento_atual and pagamento_atual["status"] == "approved":
                        user_id = payment_data["user_id"]
                        plano = payment_data["plano"]
                        
                        plano_ativado = ativar_plano_apos_pagamento(user_id, plano)
                        
                        if plano_ativado:
                            user = bot.get_user(user_id)
                            if user:
                                for guild in bot.guilds:
                                    member = guild.get_member(user_id)
                                    if member:
                                        await assign_role_to_member(member, plano["tipo"])
                                        
                                        try:
                                            embed = discord.Embed(
                                                title="‚úÖ PAGAMENTO CONFIRMADO AUTOMATICAMENTE!",
                                                description=f"Seu plano **{plano['descricao']}** foi ativado!",
                                                color=discord.Color.green()
                                            )
                                            embed.add_field(name="üìÖ Validade", value="30 dias", inline=True)
                                            embed.add_field(name="üí∞ Valor", value=f"R$ {plano['preco']:.2f}", inline=True)
                                            
                                            await user.send(embed=embed)
                                        except discord.Forbidden:
                                            print(f"N√£o foi poss√≠vel enviar DM para {user.display_name}")
                                        except Exception as e:
                                            print(f"Erro ao notificar usu√°rio: {e}")
                                        break
                            
                            payments_db[payment_id]["status"] = "approved"
                            save_payments_db(payments_db)
                            
                            print(f"‚úÖ Plano {plano['descricao']} ativado automaticamente para usu√°rio {user_id}")
    
    except Exception as e:
        print(f"Erro na verifica√ß√£o autom√°tica: {e}")

# ================== COMANDOS ==================
@bot.command(name="planos")
async def mostrar_planos(ctx):
    """Mostra todos os planos dispon√≠veis"""
    try:
        embed = discord.Embed(
            title="üíº Planos Dispon√≠veis",
            description="‚ö†Ô∏è **IMPORTANTE:** Planos s√≥ s√£o ativados ap√≥s confirma√ß√£o do pagamento!\n\nüõí Use o menu abaixo para escolher:",
            color=discord.Color.blue()
        )
        
        vendedor_info = ""
        comprador_info = ""
        destacar_info = ""
        
        for plano in PLANOS:
            preco = f"R$ {plano['preco']:.2f}"
            if plano["tipo"] == "vendedor":
                if plano["id_plano"] == 2:  # Verde
                    vendedor_info += f"‚Ä¢ {plano['descricao']}: {preco} (alternado - hoje n√£o, amanh√£ sim)\n"
                elif plano["dias_post"] == 1:
                    vendedor_info += f"‚Ä¢ {plano['descricao']}: {preco} (di√°rio)\n"
                else:
                    vendedor_info += f"‚Ä¢ {plano['descricao']}: {preco} (a cada {plano['dias_post']} dias)\n"
            elif plano["tipo"] == "comprador":
                if plano["id_plano"] == 8:  # Verde
                    comprador_info += f"‚Ä¢ {plano['descricao']}: {preco} (2 posts a cada 2 dias)\n"
                elif plano["dias_post"] == 1:
                    comprador_info += f"‚Ä¢ {plano['descricao']}: {preco} (di√°rio)\n"
                else:
                    comprador_info += f"‚Ä¢ {plano['descricao']}: {preco} (a cada {plano['dias_post']} dias)\n"
            elif plano["tipo"] == "destacar":
                if plano["tags"] == "ilimitado":
                    destacar_info += f"‚Ä¢ {plano['descricao']}: {preco} (destaques ilimitados)\n"
                elif "posts_necessarios" in plano:
                    destacar_info += f"‚Ä¢ {plano['descricao']}: {preco} ({plano['tags']} destaque(s) a cada {plano['posts_necessarios']} posts)\n"
                else:
                    destacar_info += f"‚Ä¢ {plano['descricao']}: {preco} ({plano['tags']} destaque(s))\n"
        
        if vendedor_info:
            embed.add_field(name="üõçÔ∏è Planos Vendedor", value=vendedor_info, inline=True)
        if comprador_info:
            embed.add_field(name="üõí Planos Comprador", value=comprador_info, inline=True)
        if destacar_info:
            embed.add_field(name="‚≠ê Planos Destacar", value=destacar_info, inline=True)
        
        embed.add_field(
            name="üìã Informa√ß√µes dos Canais",
            value=f"‚Ä¢ **Vendedores:** Postem na {CHANNEL_CONFIG['rede']}\n‚Ä¢ **Compradores:** Postem na {CHANNEL_CONFIG['recomendacao']}\n‚Ä¢ **Destaques:** Posts com üíØDestaques v√£o para {CHANNEL_CONFIG['destaques']}",
            inline=False
        )
        
        embed.add_field(
            name="üí≥ Formas de Pagamento",
            value="‚Ä¢ PIX (aprova√ß√£o instant√¢nea)\n‚Ä¢ Cart√£o de Cr√©dito (at√© 12x)\n‚Ä¢ Cart√£o de D√©bito",
            inline=False
        )
        
        view = SelecionarPlanoView()
        await ctx.send(embed=embed, view=view)
        
    except Exception as e:
        print(f"Erro ao mostrar planos: {e}")
        await ctx.send("‚ùå Erro ao carregar planos. Tente novamente.")

@bot.command(name="plano")
async def plano_individual(ctx, id_plano: int = None):
    """Comprar plano espec√≠fico por ID: !plano 1, !plano 2, etc"""
    if id_plano is None:
        embed = discord.Embed(
            title="‚ùì Como usar",
            description="Use: `!plano <n√∫mero>`\n\n**Exemplos:**\n‚Ä¢ `!plano 1` - Vendedor Vermelho\n‚Ä¢ `!plano 2` - Vendedor Verde\n‚Ä¢ `!plano 3` - Vendedor Azul",
            color=discord.Color.orange()
        )
        embed.add_field(
            name="üìã Lista de IDs",
            value="\n".join([f"`{p['id_plano']}` - {p['descricao']}" for p in PLANOS[:5]]) + f"\n\n*Use `!planos` para ver todos*",
            inline=False
        )
        await ctx.send(embed=embed)
        return
    
    plano = next((p for p in PLANOS if p["id_plano"] == id_plano), None)
    if not plano:
        await ctx.send(f"‚ùå Plano {id_plano} n√£o encontrado. Use `!planos` para ver todos os planos dispon√≠veis.")
        return
    
    try:
        embed = discord.Embed(
            title=f"Plano {id_plano}: {plano['descricao']}",
            description=f"**Pre√ßo:** R$ {plano['preco']:.2f}\n**Tipo:** {plano['tipo'].capitalize()}",
            color=discord.Color.blue()
        )
        
        # Descri√ß√µes espec√≠ficas para cada plano
        if plano["id_plano"] == 2:  # Vendedor Verde
            embed.add_field(name="üìÖ Postagem", value="Alternada (hoje n√£o, amanh√£ sim)", inline=True)
        elif plano["id_plano"] == 8:  # Comprador Verde
            embed.add_field(name="üìÖ Postagem", value="2 posts a cada 2 dias", inline=True)
        elif "dias_post" in plano:
            if plano["dias_post"] == 1:
                embed.add_field(name="üìÖ Postagem", value="Di√°ria", inline=True)
            else:
                embed.add_field(name="üìÖ Postagem", value=f"A cada {plano['dias_post']} dias", inline=True)
        
        if "tags" in plano:
            if plano["tags"] == "ilimitado":
                embed.add_field(name="üè∑Ô∏è Destaques", value="Ilimitados", inline=True)
            elif "posts_necessarios" in plano:
                embed.add_field(name="üè∑Ô∏è Destaques", value=f"{plano['tags']} a cada {plano['posts_necessarios']} posts", inline=True)
            else:
                embed.add_field(name="üè∑Ô∏è Tags", value=str(plano["tags"]), inline=True)
        
        embed.add_field(name="‚è∞ Dura√ß√£o", value="30 dias", inline=True)
        embed.set_footer(text="‚ö†Ô∏è Plano s√≥ √© ativado ap√≥s confirma√ß√£o do pagamento!")
        
        view = ComprarViewCompleta(plano)
        await ctx.send(embed=embed, view=view)
        
    except Exception as e:
        print(f"Erro ao mostrar plano individual: {e}")
        await ctx.send("‚ùå Erro interno. Tente novamente.")

@bot.command(name="status")
async def status_usuario(ctx):
    """Mostra status dos planos do usu√°rio"""
    try:
        user_id = ctx.author.id
        db = load_planos_db()
        posts_db = load_posts_db()
        
        embed = discord.Embed(
            title=f"üìä Meus Planos - {ctx.author.display_name}",
            color=discord.Color.blue()
        )
        
        agora = int(time.time())
        planos_encontrados = False
        planos_ativos = []
        planos_expirados = []
        
        for plano in db:
            if plano["user_id"] == user_id and plano.get("pago", False):
                planos_encontrados = True
                fim = plano.get("data_fim", agora)
                
                if agora > fim:
                    planos_expirados.append(plano)
                else:
                    planos_ativos.append(plano)
        
        if planos_ativos:
            ativo_text = ""
            for plano in planos_ativos:
                fim = plano.get("data_fim", agora)
                dias_restantes = (fim - agora) // 86400
                ativo_text += f"‚Ä¢ **{plano['descricao']}**\n  üìÖ {dias_restantes} dias restantes\n  üéØ Tipo: {plano['tipo'].capitalize()}\n\n"
            
            embed.add_field(
                name="‚úÖ Planos Ativos",
                value=ativo_text,
                inline=False
            )
        
        # Mostrar estat√≠sticas de posts para planos de destaque
        user_posts = posts_db.get(str(user_id), {})
        if any(p["tipo"] == "destacar" for p in planos_ativos):
            posts_rede = user_posts.get("posts_rede", 0)
            destaques_usados = user_posts.get("destaques_usados", 0)
            
            embed.add_field(
                name="üìä Estat√≠sticas de Destaque",
                value=f"‚Ä¢ Posts na rede: {posts_rede}\n‚Ä¢ Destaques usados: {destaques_usados}",
                inline=True
            )
        
        # Mostrar estat√≠sticas de posts para comprador verde
        if any(p["id_plano"] == 8 for p in planos_ativos):  # Comprador Verde
            posts_periodo = user_posts.get("posts_periodo_comprador", {"count": 0})
            embed.add_field(
                name="üìä Posts no Per√≠odo Atual",
                value=f"‚Ä¢ Posts usados: {posts_periodo.get('count', 0)}/2",
                inline=True
            )
        
        if planos_expirados:
            expirado_text = ""
            for plano in planos_expirados[-3:]:
                expirado_text += f"‚Ä¢ {plano['descricao']}\n"
            
            embed.add_field(
                name="‚ùå Planos Expirados (√∫ltimos 3)",
                value=expirado_text,
                inline=False
            )
        
        if not planos_encontrados:
            embed.description = "Nenhum plano ativo encontrado.\n\nüõçÔ∏è Use `!planos` para ver as op√ß√µes dispon√≠veis!"
            embed.color = discord.Color.orange()
        
        embed.add_field(
            name="üìã Comandos √öteis",
            value="‚Ä¢ `!planos` - Ver todos os planos\n‚Ä¢ `!plano <id>` - Comprar plano espec√≠fico\n‚Ä¢ `!ajuda` - Todos os comandos",
            inline=False
        )
        
        await ctx.send(embed=embed)
        
    except Exception as e:
        print(f"Erro ao mostrar status: {e}")
        await ctx.send("‚ùå Erro ao verificar status. Tente novamente.")

@bot.command(name="ajuda", aliases=["help"])
async def ajuda(ctx):
    """Comandos dispon√≠veis"""
    embed = discord.Embed(
        title="ü§ñ Central de Ajuda - Discord Bot",
        description="Sistema completo de planos com pagamentos reais via Mercado Pago",
        color=discord.Color.green()
    )
    
    embed.add_field(
        name="üõçÔ∏è Comandos de Compra",
        value="‚Ä¢ `!planos` - Ver todos os planos dispon√≠veis\n‚Ä¢ `!plano <id>` - Comprar plano espec√≠fico (ex: `!plano 1`)\n‚Ä¢ `!status` - Ver seus planos ativos",
        inline=False
    )
    
    embed.add_field(
        name="üåü Sistema Privado",
        value="‚Ä¢ `!assinatura` - Acessar seu espa√ßo privado de assinatura\n‚Ä¢ `!assinar` - Alias para o comando acima\n‚Ä¢ `!privado` - Outro alias para privacidade",
        inline=False
    )
    
    embed.add_field(
        name="üìã Tipos de Planos ATUALIZADOS",
        value=f"‚Ä¢ **Vendedor** - Para postar na {CHANNEL_CONFIG['rede']}\n  - Verde: Alternado (hoje n√£o, amanh√£ sim)\n  - Vermelho: Di√°rio\n  - Azul: A cada 2 dias\n‚Ä¢ **Comprador** - Para postar na {CHANNEL_CONFIG['recomendacao']}\n  - Verde: 2 posts a cada 2 dias\n  - Vermelho: Di√°rio\n  - Azul: A cada 2 dias\n‚Ä¢ **Destacar** - Para usar a tag üíØDestaques\n  - Vermelho: Ilimitado\n  - Verde/Azul: Baseado em posts",
        inline=False
    )
    
    embed.add_field(
        name="üè∑Ô∏è Sistema de Destaques",
        value=f"‚Ä¢ Tag **üíØDestaques** s√≥ funciona na {CHANNEL_CONFIG['rede']}\n‚Ä¢ Posts destacados aparecem automaticamente no {CHANNEL_CONFIG['destaques']}\n‚Ä¢ **Vermelho:** Ilimitado\n‚Ä¢ **Verde:** 2 destaques a cada 10 posts\n‚Ä¢ **Azul:** 1 destaque a cada 10 posts",
        inline=False
    )
    
    embed.add_field(
        name="üîí Privacidade Garantida",
        value=f"‚Ä¢ Use `!assinatura` para acessar seu espa√ßo privado\n‚Ä¢ Localizado na categoria **{CHANNEL_CONFIG['categoria_assinaturas']}**\n‚Ä¢ Apenas voc√™ pode ver suas conversas\n‚Ä¢ Todos os comandos funcionam no espa√ßo privado",
        inline=False
    )
    
    embed.add_field(
        name="üí≥ Formas de Pagamento",
        value="‚Ä¢ **PIX** - Aprova√ß√£o instant√¢nea\n‚Ä¢ **Cart√£o de Cr√©dito** - At√© 12x sem juros\n‚Ä¢ **Cart√£o de D√©bito** - Aprova√ß√£o r√°pida",
        inline=True
    )
    
    embed.add_field(
        name="‚ö° Processo de Compra",
        value="1. Use `!assinatura` para privacidade\n2. Escolha o plano com `!planos`\n3. Efetue o pagamento\n4. Aguarde confirma√ß√£o autom√°tica\n5. Plano ativado!",
        inline=True
    )
    
    embed.add_field(
        name="‚è∞ Informa√ß√µes Importantes",
        value="‚Ä¢ **Dura√ß√£o:** Todos os planos duram 30 dias\n‚Ä¢ **Ativa√ß√£o:** Autom√°tica ap√≥s pagamento confirmado\n‚Ä¢ **Verifica√ß√£o:** Sistema verifica pagamentos a cada 5 minutos\n‚Ä¢ **Cooldown:** Respeitado automaticamente conforme plano",
        inline=False
    )
    
    embed.set_footer(text="üí° Dica: Use !assinatura para come√ßar com privacidade!")
    
    await ctx.send(embed=embed)

@bot.command(name="limpar", aliases=["clear"])
@commands.has_permissions(manage_messages=True)
async def limpar_planos_expirados(ctx, confirmar: str = None):
    """Remove planos expirados do banco de dados (apenas administradores)"""
    if confirmar != "SIM":
        embed = discord.Embed(
            title="‚ö†Ô∏è Confirma√ß√£o Necess√°ria",
            description="Este comando ir√° remover TODOS os planos expirados do banco de dados.\n\nPara confirmar, use: `!limpar SIM`",
            color=discord.Color.orange()
        )
        await ctx.send(embed=embed)
        return
    
    try:
        db = load_planos_db()
        agora = int(time.time())
        
        planos_ativos = []
        removidos = 0
        
        for plano in db:
            fim = plano.get("data_fim", 0)
            if fim > agora:
                planos_ativos.append(plano)
            else:
                removidos += 1
        
        save_planos_db(planos_ativos)
        
        embed = discord.Embed(
            title="üßπ Limpeza Conclu√≠da",
            description=f"**{removidos}** planos expirados foram removidos.\n**{len(planos_ativos)}** planos ativos mantidos.",
            color=discord.Color.green()
        )
        
        await ctx.send(embed=embed)
        
    except Exception as e:
        print(f"Erro na limpeza: {e}")
        await ctx.send("‚ùå Erro ao limpar banco de dados.")

@bot.command(name="assinatura", aliases=["assinar", "privado"])
async def acessar_assinatura_privada(ctx):
    """Cria ou acessa seu espa√ßo privado de assinatura"""
    try:
        # Configurar f√≥rum se necess√°rio
        forum_configurado = await garantir_forum_configurado(ctx.guild)
        if not forum_configurado:
            await ctx.send("‚ùå Erro ao configurar sistema de f√≥rum. Contate um administrador.", delete_after=10)
            return
        
        # Obter ou criar thread privada
        thread_privada = await obter_ou_criar_thread_privada(ctx.author, ctx.guild)
        
        if not thread_privada:
            await ctx.send("‚ùå Erro ao criar/acessar seu espa√ßo privado. Tente novamente.", delete_after=10)
            return
        
        # Resposta p√∫blica tempor√°ria
        embed = discord.Embed(
            title="‚úÖ Espa√ßo Privado Criado!",
            description=f"Seu espa√ßo privado de assinatura foi criado!\n\nüîó **Acesse:** {thread_privada.mention}",
            color=discord.Color.green()
        )
        embed.add_field(
            name="üîí Privacidade",
            value="‚Ä¢ Apenas voc√™ pode ver e interagir\n‚Ä¢ Comandos do bot funcionam normalmente\n‚Ä¢ Totalmente confidencial",
            inline=False
        )
        embed.set_footer(text="Esta mensagem ser√° deletada em 15 segundos")
        
        await ctx.send(embed=embed, delete_after=15)
        
        # Deletar comando do usu√°rio por privacidade
        try:
            await ctx.message.delete()
        except discord.NotFound:
            pass
        
        # Mensagem de boas-vindas na thread privada
        if thread_privada.message_count <= 1:  # Se √© nova thread
            welcome_embed = discord.Embed(
                title="üéâ Bem-vindo ao seu espa√ßo privado!",
                description="Este √© seu ambiente privado para gerenciar assinaturas e planos.",
                color=discord.Color.blue()
            )
            welcome_embed.add_field(
                name="üõçÔ∏è Comandos Dispon√≠veis:",
                value="‚Ä¢ `!planos` - Ver planos dispon√≠veis\n‚Ä¢ `!status` - Seus planos ativos\n‚Ä¢ `!plano <id>` - Comprar plano espec√≠fico",
                inline=False
            )
            welcome_embed.add_field(
                name="üîí Privacidade Garantida:",
                value="‚Ä¢ Ningu√©m mais pode ver este chat\n‚Ä¢ Seus dados est√£o seguros\n‚Ä¢ Pagamentos processados com seguran√ßa",
                inline=False
            )
            
            await thread_privada.send(embed=welcome_embed)
        
    except Exception as e:
        print(f"Erro no comando assinatura: {e}")
        await ctx.send("‚ùå Erro interno. Tente novamente.", delete_after=5)

@bot.command(name="stats")
@commands.has_permissions(administrator=True)
async def estatisticas_bot(ctx):
    """Mostra estat√≠sticas do bot (apenas administradores)"""
    try:
        db = load_planos_db()
        payments_db = load_payments_db()
        posts_db = load_posts_db()
        agora = int(time.time())
        
        planos_ativos = 0
        planos_expirados = 0
        total_arrecadado = 0
        pagamentos_pendentes = 0
        
        for plano in db:
            fim = plano.get("data_fim", 0)
            if fim > agora:
                planos_ativos += 1
            else:
                planos_expirados += 1
        
        for payment_data in payments_db.values():
            if payment_data["status"] == "approved":
                total_arrecadado += payment_data.get("amount", 0)
            elif payment_data["status"] == "pending":
                pagamentos_pendentes += 1
        
        tipos = {"vendedor": 0, "comprador": 0, "destacar": 0}
        for plano in db:
            if plano.get("data_fim", 0) > agora:
                tipo = plano.get("tipo", "")
                if tipo in tipos:
                    tipos[tipo] += 1
        
        total_posts_rede = sum(user_data.get("posts_rede", 0) for user_data in posts_db.values())
        total_destaques = sum(user_data.get("destaques_usados", 0) for user_data in posts_db.values())
        
        embed = discord.Embed(
            title="üìä Estat√≠sticas do Bot",
            color=discord.Color.blue()
        )
        
        embed.add_field(
            name="üìà Planos",
            value=f"**Ativos:** {planos_ativos}\n**Expirados:** {planos_expirados}\n**Total:** {planos_ativos + planos_expirados}",
            inline=True
        )
        
        embed.add_field(
            name="üí∞ Financeiro",
            value=f"**Arrecadado:** R$ {total_arrecadado:.2f}\n**Pendentes:** {pagamentos_pendentes}",
            inline=True
        )
        
        embed.add_field(
            name="üéØ Por Tipo (Ativos)",
            value=f"**Vendedor:** {tipos['vendedor']}\n**Comprador:** {tipos['comprador']}\n**Destacar:** {tipos['destacar']}",
            inline=True
        )
        
        embed.add_field(
            name="üìä Atividade",
            value=f"**Posts na rede:** {total_posts_rede}\n**Destaques usados:** {total_destaques}",
            inline=True
        )
        
        embed.add_field(
            name="ü§ñ Bot Info",
            value=f"**Servidores:** {len(bot.guilds)}\n**Usu√°rios:** {len(set(bot.get_all_members()))}",
            inline=True
        )
        
        embed.set_footer(text=f"√öltima verifica√ß√£o: {datetime.now().strftime('%d/%m/%Y %H:%M')}")
        
        await ctx.send(embed=embed)
        
    except Exception as e:
        print(f"Erro nas estat√≠sticas: {e}")
        await ctx.send("‚ùå Erro ao gerar estat√≠sticas.")

# ================== EVENTOS ==================
@bot.event
async def on_ready():
    print(f"ü§ñ {bot.user} est√° online!")
    print(f"üìä Conectado a {len(bot.guilds)} servidor(s)")
    print(f"üë• Alcan√ßando {len(set(bot.get_all_members()))} usu√°rios √∫nicos")
    print(f"üí≥ Mercado Pago integrado - Sistema de cobran√ßa REAL ativo")
    print(f"‚ö†Ô∏è  Planos s√≥ s√£o ativados ap√≥s confirma√ß√£o de pagamento!")
    print(f"üè∑Ô∏è  Sistema de destaques integrado com canais: {CHANNEL_CONFIG}")
    print("üîÑ PLANOS ATUALIZADOS:")
    print("   ‚Ä¢ Vendedor Verde: Alternado (hoje n√£o, amanh√£ sim)")
    print("   ‚Ä¢ Comprador Verde: 2 posts a cada 2 dias")
    print("   ‚Ä¢ Destacar Vermelho: Ilimitado")
    
    if not verificar_pagamentos_automatico.is_running():
        verificar_pagamentos_automatico.start()
        print("üîÑ Verifica√ß√£o autom√°tica de pagamentos iniciada (a cada 5 minutos)")

@bot.event
async def on_command_error(ctx, error):
    """Tratamento de erros dos comandos"""
    if isinstance(error, commands.CommandNotFound):
        embed = discord.Embed(
            title="‚ùì Comando n√£o encontrado",
            description=f"O comando `{ctx.message.content}` n√£o existe.\n\nUse `!ajuda` para ver todos os comandos dispon√≠veis.",
            color=discord.Color.orange()
        )
        await ctx.send(embed=embed, delete_after=10)
    
    elif isinstance(error, commands.MissingPermissions):
        await ctx.send("‚ùå Voc√™ n√£o tem permiss√£o para usar este comando.", delete_after=5)
    
    elif isinstance(error, commands.BadArgument):
        await ctx.send("‚ùå Argumento inv√°lido. Verifique o comando e tente novamente.", delete_after=5)
    
    else:
        print(f"Erro no comando {ctx.command}: {error}")
        await ctx.send("‚ùå Erro interno. Tente novamente mais tarde.", delete_after=5)

@bot.event
async def on_guild_join(guild):
    """Quando o bot entra em um servidor novo"""
    print(f"‚ûï Bot adicionado ao servidor: {guild.name} (ID: {guild.id})")
    
    # Configurar f√≥rum automaticamente
    await garantir_forum_configurado(guild)
    
    for channel in guild.text_channels:
        if channel.permissions_for(guild.me).send_messages:
            embed = discord.Embed(
                title="üéâ Obrigado por me adicionar!",
                description="Sou um bot de **venda de planos** com pagamentos reais via Mercado Pago!",
                color=discord.Color.green()
            )
            
            embed.add_field(
                name="üöÄ Como come√ßar",
                value="‚Ä¢ `!ajuda` - Ver todos os comandos\n‚Ä¢ `!assinatura` - Acessar espa√ßo privado\n‚Ä¢ `!planos` - Ver planos dispon√≠veis\n‚Ä¢ `!status` - Verificar seus planos",
                inline=False
            )
            
            embed.add_field(
                name="üîí Sistema Privado",
                value="‚Ä¢ Use `!assinatura` para ter privacidade total\n‚Ä¢ Cada usu√°rio tem seu espa√ßo individual\n‚Ä¢ Ningu√©m pode ver suas conversas ou compras",
                inline=False
            )
            
            embed.add_field(
                name="üí≥ Sobre os Pagamentos",
                value="‚Ä¢ Pagamentos **100% reais** via Mercado Pago\n‚Ä¢ PIX, Cart√£o de Cr√©dito e D√©bito\n‚Ä¢ Ativa√ß√£o autom√°tica ap√≥s confirma√ß√£o",
                inline=False
            )
            
            embed.add_field(
                name="üè∑Ô∏è Configura√ß√£o dos Canais",
                value=f"‚Ä¢ Crie o canal **{CHANNEL_CONFIG['rede']}** para vendedores\n‚Ä¢ Crie o canal **{CHANNEL_CONFIG['recomendacao']}** para compradores\n‚Ä¢ Crie o canal **{CHANNEL_CONFIG['destaques']}** para posts destacados\n‚Ä¢ Categoria **{CHANNEL_CONFIG['categoria_assinaturas']}** criada automaticamente",
                inline=False
            )
            
            embed.add_field(
                name="üÜï PLANOS ATUALIZADOS",
                value="‚Ä¢ **Vendedor Verde:** Alternado (hoje n√£o, amanh√£ sim)\n‚Ä¢ **Comprador Verde:** 2 posts a cada 2 dias\n‚Ä¢ **Destacar Vermelho:** Destaques ilimitados",
                inline=False
            )
            
            embed.set_footer(text="Digite !assinatura para come√ßar com total privacidade!")
            
            try:
                await channel.send(embed=embed)
                break
            except discord.Forbidden:
                continue

@bot.event
async def on_member_join(member):
    """Quando um usu√°rio entra no servidor"""
    try:
        db = load_planos_db()
        agora = int(time.time())
        
        for plano in db:
            if (plano["user_id"] == member.id and 
                plano.get("pago", False) and 
                plano.get("data_fim", 0) > agora):
                
                await assign_role_to_member(member, plano["tipo"])
                print(f"Cargo {plano['tipo']} reatribu√≠do para {member.display_name}")
                
    except Exception as e:
        print(f"Erro ao reatribuir cargos para {member.display_name}: {e}")

# ================== INICIALIZA√á√ÉO ==================
if __name__ == "__main__":
    print("üöÄ Iniciando Discord Bot...")
    print("üí≥ Sistema de cobran√ßa REAL ativo via Mercado Pago")
    print("‚ö†Ô∏è  IMPORTANTE: Planos s√≥ s√£o ativados ap√≥s confirma√ß√£o de pagamento!")
    print("üîÑ Verifica√ß√£o autom√°tica de pagamentos a cada 5 minutos")
    print(f"üè∑Ô∏è Canais configurados: {CHANNEL_CONFIG}")
    print("üÜï ATUALIZA√á√ïES DOS PLANOS:")
    print("   ‚Ä¢ Vendedor Verde: Sistema alternado")
    print("   ‚Ä¢ Comprador Verde: 2 posts a cada 2 dias")
    print("   ‚Ä¢ Destacar Vermelho: Destaques ilimitados")
    print("=" * 60)
    
    if not DISCORD_TOKEN:
        print("‚ùå DISCORD_TOKEN n√£o encontrado no arquivo .env!")
        exit(1)
    
    if not ML_TOKEN:
        print("‚ùå ML_TOKEN n√£o encontrado no arquivo .env!")
        exit(1)
    
    if ML_TOKEN.startswith("APP_USR"):
        print("üö® ATEN√á√ÉO: Usando tokens de PRODU√á√ÉO - Cobran√ßas ser√£o REAIS!")
    elif ML_TOKEN.startswith("TEST"):
        print("üß™ Usando tokens de TESTE - Ambiente de desenvolvimento")
    else:
        print("‚ö†Ô∏è  Token do Mercado Pago n√£o identificado")
    
    try:
        bot.run(DISCORD_TOKEN)
    except discord.LoginFailure:
        print("‚ùå TOKEN do Discord inv√°lido! Verifique o arquivo .env")
    except discord.HTTPException as e:
        print(f"‚ùå Erro HTTP: {e}")
    except KeyboardInterrupt:
        print("\nüëã Bot encerrado pelo usu√°rio")
    except Exception as e:
        print(f"‚ùå Erro inesperado ao iniciar bot: {e}")
    finally:
        print("üî¥ Bot desconectado")
        # ================== MONITORAMENTO DE MENSAGENS ==================
@bot.event
async def on_message(message):
    """Monitora mensagens para controlar posts e detectar tags de destaque"""
    if message.author.bot:
        return
    
    await bot.process_commands(message)
    
    # Verificar se √© um canal de postagem
    canal_nome = message.channel.name
    user_id = message.author.id
    
    # Post na rede (vendedores)
    if canal_nome == CHANNEL_CONFIG["rede"]:
        pode, resultado = pode_postar(user_id, "vendedor")
        if not pode:
            await message.delete()
            await message.channel.send(
                f"‚ùå {message.author.mention} {resultado}",
                delete_after=10
            )
            return
        
        # Verificar se tem tag de destaque
        tem_destaque = "üíØDestaques" in message.content
        
        if tem_destaque:
            pode_destacar, resultado_destaque = pode_usar_destaque(user_id)
            if not pode_destacar:
                content_sem_tag = message.content.replace("üíØDestaques", "").strip()
                await message.edit(content=content_sem_tag)
                await message.channel.send(
                    f"‚ö†Ô∏è {message.author.mention} {resultado_destaque} A tag foi removida do seu post.",
                    delete_after=15
                )
                tem_destaque = False
        
        # Registrar o post
        registrar_post(user_id, "vendedor", tem_destaque)
        
        # Mover para destaques se necess√°rio
        if tem_destaque:
            await mover_para_destaques(message)
    
    # Post na recomenda√ß√£o (compradores)
    elif canal_nome == CHANNEL_CONFIG["recomendacao"]:
        pode, resultado = pode_postar(user_id, "comprador")
        if not pode:
            await message.delete()
            await message.channel.send(
                f"‚ùå {message.author.mention} {resultado}",
                delete_after=10
            )
            return
        
        # Compradores n√£o podem usar tag de destaque
        if "üíØDestaques" in message.content:
            content_sem_tag = message.content.replace("üíØDestaques", "").strip()
            await message.edit(content=content_sem_tag)
            await message.channel.send(
                f"‚ö†Ô∏è {message.author.mention} A tag de destaque n√£o √© permitida neste canal.",
                delete_after=10
            )
        
        # Registrar o post
        registrar_post(user_id, "comprador", False)

# ================== VERIFICA√á√ÉO AUTOM√ÅTICA DE PAGAMENTOS ==================
@tasks.loop(minutes=5)
async def verificar_pagamentos_automatico():
    """Verifica pagamentos pendentes automaticamente a cada 5 minutos"""
    await bot.wait_until_ready()
    
    try:
        # Verificar pagamentos de cart√£o
        payments_db = load_payments_db()
        if payments_db:
            for payment_id, payment_data in payments_db.items():
                if payment_data["status"] == "pending":
                    external_ref = payment_data.get("external_reference")
                    if external_ref:
                        pagamento_atual = verificar_pagamento_por_referencia(external_ref)
                        
                        if pagamento_atual and pagamento_atual["status"] == "approved":
                            user_id = payment_data["user_id"]
                            plano = payment_data["plano"]
                            modalidade = external_ref.split("_")[-1] if "_" in external_ref else "mensal"
                            
                            plano_ativado = ativar_plano_apos_pagamento(user_id, plano, modalidade)
                            
                            if plano_ativado:
                                user = bot.get_user(user_id)
                                if user:
                                    for guild in bot.guilds:
                                        member = guild.get_member(user_id)
                                        if member:
                                            await assign_role_to_member(member, plano["tipo"])
                                            
                                            try:
                                                embed = discord.Embed(
                                                    title="‚úÖ PAGAMENTO CONFIRMADO AUTOMATICAMENTE!",
                                                    description=f"Seu plano **{plano['descricao']}** foi ativado!",
                                                    color=discord.Color.green()
                                                )
                                                embed.add_field(name="üìÖ Validade", value="30 dias", inline=True)
                                                embed.add_field(name="üéØ Modalidade", value=modalidade.capitalize(), inline=True)
                                                
                                                await user.send(embed=embed)
                                            except discord.Forbidden:
                                                print(f"N√£o foi poss√≠vel enviar DM para {user.display_name}")
                                            except Exception as e:
                                                print(f"Erro ao notificar usu√°rio: {e}")
                                            break
                                
                                payments_db[payment_id]["status"] = "approved"
                                save_payments_db(payments_db)
                                
                                print(f"‚úÖ Plano {plano['descricao']} ativado automaticamente para usu√°rio {user_id}")
        
        # Verificar pagamentos PIX
        pix_db = load_pix_db()
        if pix_db:
            for payment_id, pix_data in pix_db.items():
                if pix_data["status"] == "pending":
                    pagamento_pix = verificar_pagamento_pix(payment_id)
                    
                    if pagamento_pix and pagamento_pix["status"] == "approved":
                        user_id = pix_data["user_id"]
                        plano = pix_data["plano"]
                        modalidade = pix_data["modalidade"]
                        
                        plano_ativado = ativar_plano_apos_pagamento(user_id, plano, modalidade)
                        
                        if plano_ativado:
                            user = bot.get_user(user_id)
                            if user:
                                for guild in bot.guilds:
                                    member = guild.get_member(user_id)
                                    if member:
                                        await assign_role_to_member(member, plano["tipo"])
                                        
                                        try:
                                            embed = discord.Embed(
                                                title="‚úÖ PIX CONFIRMADO AUTOMATICAMENTE!",
                                                description=f"Seu plano **{plano['descricao']}** foi ativado!",
                                                color=discord.Color.green()
                                            )
                                            embed.add_field(name="üìÖ Validade", value="30 dias", inline=True)
                                            embed.add_field(name="üéØ Modalidade", value=modalidade.capitalize(), inline=True)
                                            embed.add_field(name="üí∞ Valor", value=f"R$ {pix_data['amount']:.2f}", inline=True)
                                            
                                            await user.send(embed=embed)
                                        except discord.Forbidden:
                                            print(f"N√£o foi poss√≠vel enviar DM para {user.display_name}")
                                        except Exception as e:
                                            print(f"Erro ao notificar usu√°rio: {e}")
                                        break
                            
                            pix_db[payment_id]["status"] = "approved"
                            save_pix_db(pix_db)
                            
                            print(f"‚úÖ Plano PIX {plano['descricao']} ativado automaticamente para usu√°rio {user_id}")
    
    except Exception as e:
        print(f"Erro na verifica√ß√£o autom√°tica: {e}")

# ================== COMANDOS ==================
@bot.command(name="planos")
async def mostrar_planos(ctx):
    """Mostra todos os planos dispon√≠veis"""
    try:
        embed = discord.Embed(
            title="üíº Planos Dispon√≠veis",
            description="üõçÔ∏è Escolha entre **Mensal** ou **Pagamento √önico (+50%)**\n\nüõí Use o menu abaixo para escolher:",
            color=discord.Color.blue()
        )
        
        vendedor_info = ""
        comprador_info = ""
        destacar_info = ""
        
        for plano in PLANOS:
            preco = f"R$ {plano['preco']:.2f}"
            preco_unico = f"R$ {plano['preco'] * 1.5:.2f}"
            
            if plano["tipo"] == "vendedor":
                if plano["id_plano"] == 2:
                    vendedor_info += f"‚Ä¢ {plano['descricao']}: {preco} | {preco_unico} (alternado)\n"
                elif plano["dias_post"] == 1:
                    vendedor_info += f"‚Ä¢ {plano['descricao']}: {preco} | {preco_unico} (di√°rio)\n"
                else:
                    vendedor_info += f"‚Ä¢ {plano['descricao']}: {preco} | {preco_unico} (a cada {plano['dias_post']} dias)\n"
            elif plano["tipo"] == "comprador":
                if plano["id_plano"] == 8:
                    comprador_info += f"‚Ä¢ {plano['descricao']}: {preco} | {preco_unico} (2 posts/2 dias)\n"
                elif plano["dias_post"] == 1:
                    comprador_info += f"‚Ä¢ {plano['descricao']}: {preco} | {preco_unico} (di√°rio)\n"
                else:
                    comprador_info += f"‚Ä¢ {plano['descricao']}: {preco} | {preco_unico} (a cada {plano['dias_post']} dias)\n"
            elif plano["tipo"] == "destacar":
                if plano["tags"] == "ilimitado":
                    destacar_info += f"‚Ä¢ {plano['descricao']}: {preco} | {preco_unico} (ilimitado)\n"
                elif "posts_necessarios" in plano:
                    destacar_info += f"‚Ä¢ {plano['descricao']}: {preco} | {preco_unico} ({plano['tags']} a cada {plano['posts_necessarios']} posts)\n"
        
        if vendedor_info:
            embed.add_field(name="üõçÔ∏è Vendedor (Mensal | √önico)", value=vendedor_info, inline=True)
        if comprador_info:
            embed.add_field(name="üõí Comprador (Mensal | √önico)", value=comprador_info, inline=True)
        if destacar_info:
            embed.add_field(name="‚≠ê Destacar (Mensal | √önico)", value=destacar_info, inline=True)
        
        embed.add_field(
            name="üíé Pagamento √önico",
            value="‚Ä¢ 50% a mais no valor\n‚Ä¢ V√°lido por 1 m√™s\n‚Ä¢ Taxa de cancelamento antes de 2 meses: 100%",
            inline=False
        )
        
        embed.add_field(
            name="üí≥ Formas de Pagamento",
            value="‚Ä¢ **PIX** - Confirma√ß√£o r√°pida\n‚Ä¢ **Cart√£o** - Cr√©dito/D√©bito (at√© 12x)",
            inline=False
        )
        
        view = SelecionarPlanoView()
        await ctx.send(embed=embed, view=view)
        
    except Exception as e:
        print(f"Erro ao mostrar planos: {e}")
        await ctx.send("‚ùå Erro ao carregar planos. Tente novamente.")

@bot.command(name="plano")
async def plano_individual(ctx, id_plano: int = None):
    """Comprar plano espec√≠fico por ID"""
    if id_plano is None:
        embed = discord.Embed(
            title="‚ùì Como usar",
            description="Use: `!plano <n√∫mero>`\n\n**Exemplos:**\n‚Ä¢ `!plano 1` - Vendedor Vermelho\n‚Ä¢ `!plano 2` - Vendedor Verde",
            color=discord.Color.orange()
        )
        embed.add_field(
            name="üìã Lista de IDs",
            value="\n".join([f"`{p['id_plano']}` - {p['descricao']}" for p in PLANOS[:5]]) + "\n\n*Use `!planos` para ver todos*",
            inline=False
        )
        await ctx.send(embed=embed)
        return
    
    plano = next((p for p in PLANOS if p["id_plano"] == id_plano), None)
    if not plano:
        await ctx.send(f"‚ùå Plano {id_plano} n√£o encontrado. Use `!planos` para ver todos os planos dispon√≠veis.")
        return
    
    try:
        embed = discord.Embed(
            title=f"Plano {id_plano}: {plano['descricao']}",
            description=f"**Mensal:** R$ {plano['preco']:.2f}\n**√önico:** R$ {plano['preco'] * 1.5:.2f} (+50%)\n**Tipo:** {plano['tipo'].capitalize()}",
            color=discord.Color.blue()
        )
        
        if plano["id_plano"] == 2:
            embed.add_field(name="üìÖ Postagem", value="Alternada (hoje n√£o, amanh√£ sim)", inline=True)
        elif plano["id_plano"] == 8:
            embed.add_field(name="üìÖ Postagem", value="2 posts a cada 2 dias", inline=True)
        elif "dias_post" in plano:
            if plano["dias_post"] == 1:
                embed.add_field(name="üìÖ Postagem", value="Di√°ria", inline=True)
            else:
                embed.add_field(name="üìÖ Postagem", value=f"A cada {plano['dias_post']} dias", inline=True)
        
        if "tags" in plano:
            if plano["tags"] == "ilimitado":
                embed.add_field(name="üè∑Ô∏è Destaques", value="Ilimitados", inline=True)
            elif "posts_necessarios" in plano:
                embed.add_field(name="üè∑Ô∏è Destaques", value=f"{plano['tags']} a cada {plano['posts_necessarios']} posts", inline=True)
        
        embed.add_field(name="‚è∞ Dura√ß√£o", value="30 dias", inline=True)
        
        view = ComprarViewCompleta(plano)
        await ctx.send(embed=embed, view=view)
        
    except Exception as e:
        print(f"Erro ao mostrar plano individual: {e}")
        await ctx.send("‚ùå Erro interno. Tente novamente.")

@bot.command(name="status")
async def status_usuario(ctx):
    """Mostra status dos planos do usu√°rio"""
    try:
        user_id = ctx.author.id
        db = load_planos_db()
        posts_db = load_posts_db()
        
        embed = discord.Embed(
            title=f"üìä Meus Planos - {ctx.author.display_name}",
            color=discord.Color.blue()
        )
        
        agora = int(time.time())
        planos_encontrados = False
        planos_ativos = []
        planos_expirados = []
        
        for plano in db:
            if plano["user_id"] == user_id and plano.get("pago", False):
                planos_encontrados = True
                fim = plano.get("data_fim", agora)
                
                if agora > fim:
                    planos_expirados.append(plano)
                else:
                    planos_ativos.append(plano)
        
        if planos_ativos:
            ativo_text = ""
            for plano in planos_ativos:
                fim = plano.get("data_fim", agora)
                dias_restantes = (fim - agora) // 86400
                modalidade = plano.get("modalidade", "mensal")
                ativo_text += f"‚Ä¢ **{plano['descricao']}** ({modalidade})\n  üìÖ {dias_restantes} dias restantes\n  üéØ Tipo: {plano['tipo'].capitalize()}\n\n"
            
            embed.add_field(
                name="‚úÖ Planos Ativos",
                value=ativo_text,
                inline=False
            )
            
            # Bot√£o para cancelar planos
            view = View(timeout=300)
            cancelar_btn = discord.ui.Button(label="üóëÔ∏è Cancelar Plano", style=discord.ButtonStyle.danger)
            
            async def cancelar_callback(interaction):
                if interaction.user.id != user_id:
                    await interaction.response.send_message("‚ùå Voc√™ n√£o pode usar este bot√£o.", ephemeral=True)
                    return
                
                agora = int(time.time())
                planos_cancelaveis = [p for p in planos_ativos if p.get("data_fim", 0) > agora]
                
                if not planos_cancelaveis:
                    await interaction.response.send_message("‚ùå Nenhum plano ativo para cancelar.", ephemeral=True)
                    return
                
                view_cancelar = CancelarPlanoView(planos_cancelaveis)
                embed_cancelar = discord.Embed(
                    title="üóëÔ∏è Cancelar Plano",
                    description="Escolha o plano que deseja cancelar:",
                    color=discord.Color.orange()
                )
                embed_cancelar.add_field(
                    name="‚ö†Ô∏è Pol√≠tica de Cancelamento:",
                    value="‚Ä¢ Antes de 2 meses: Taxa de 100%\n‚Ä¢ Ap√≥s 2 meses: Sem taxa\n‚Ä¢ Pagamento √∫nico: Sempre taxa de 100%",
                    inline=False
                )
                
                await interaction.response.send_message(embed=embed_cancelar, view=view_cancelar, ephemeral=True)
            
            cancelar_btn.callback = cancelar_callback
            view.add_item(cancelar_btn)
            
            embed.set_footer(text="Use o bot√£o abaixo para cancelar um plano")
        else:
            view = None
        
        # Estat√≠sticas de posts
        user_posts = posts_db.get(str(user_id), {})
        if any(p["tipo"] == "destacar" for p in planos_ativos):
            posts_rede = user_posts.get("posts_rede", 0)
            destaques_usados = user_posts.get("destaques_usados", 0)
            
            embed.add_field(
                name="üìä Estat√≠sticas de Destaque",
                value=f"‚Ä¢ Posts na rede: {posts_rede}\n‚Ä¢ Destaques usados: {destaques_usados}",
                inline=True
            )
        
        if any(p["id_plano"] == 8 for p in planos_ativos):
            posts_periodo = user_posts.get("posts_periodo_comprador", {"count": 0})
            embed.add_field(
                name="üìä Posts no Per√≠odo Atual",
                value=f"‚Ä¢ Posts usados: {posts_periodo.get('count', 0)}/2",
                inline=True
            )
        
        if planos_expirados:
            expirado_text = ""
            for plano in planos_expirados[-3:]:
                modalidade = plano.get("modalidade", "mensal")
                expirado_text += f"‚Ä¢ {plano['descricao']} ({modalidade})\n"
            
            embed.add_field(
                name="‚ùå Planos Expirados (√∫ltimos 3)",
                value=expirado_text,
                inline=False
            )
        
        if not planos_encontrados:
            embed.description = "Nenhum plano ativo encontrado.\n\nüõçÔ∏è Use `!planos` para ver as op√ß√µes dispon√≠veis!"
            embed.color = discord.Color.orange()
        
        embed.add_field(
            name="üìã Comandos √öteis",
            value="‚Ä¢ `!planos` - Ver todos os planos\n‚Ä¢ `!plano <id>` - Comprar plano espec√≠fico\n‚Ä¢ `!ajuda` - Todos os comandos",
            inline=False
        )
        
        await ctx.send(embed=embed, view=view)
        
    except Exception as e:
        print(f"Erro ao mostrar status: {e}")
        await ctx.send("‚ùå Erro ao verificar status. Tente novamente.")

@bot.command(name="ajuda", aliases=["help"])
async def ajuda(ctx):
    """Comandos dispon√≠veis"""
    embed = discord.Embed(
        title="ü§ñ Central de Ajuda - Sistema de Assinaturas",
        description="Sistema completo com PIX, Cart√£o e Cancelamentos",
        color=discord.Color.green()
    )
    
    embed.add_field(
        name="üõçÔ∏è Comandos de Compra",
        value="‚Ä¢ `!planos` - Ver todos os planos\n‚Ä¢ `!plano <id>` - Comprar plano espec√≠fico\n‚Ä¢ `!status` - Ver/cancelar seus planos",
        inline=False
    )
    
    embed.add_field(
        name="üåü Sistema Privado",
        value="‚Ä¢ `!assinatura` - Espa√ßo privado de assinatura\n‚Ä¢ `!assinar` - Alias para privacidade\n‚Ä¢ `!privado` - Outro alias",
        inline=False
    )
    
    embed.add_field(
        name="üí∞ Modalidades de Pagamento",
        value="‚Ä¢ **Mensal**: Pre√ßo normal, cancelamento flex√≠vel\n‚Ä¢ **√önico**: +50% do valor, v√°lido 1 m√™s, taxa cancelamento\n‚Ä¢ **PIX**: Confirma√ß√£o r√°pida\n‚Ä¢ **Cart√£o**: Cr√©dito/D√©bito at√© 12x",
        inline=False
    )
    
    embed.add_field(
        name="üóëÔ∏è Sistema de Cancelamento",
        value="‚Ä¢ Use `!status` e clique em 'Cancelar Plano'\n‚Ä¢ Antes de 2 meses: Taxa de 100%\n‚Ä¢ Ap√≥s 2 meses: Sem taxa\n‚Ä¢ Pagamento √∫nico: Sempre 100% de taxa",
        inline=False
    )
    
    embed.add_field(
        name="üìã Tipos de Planos",
        value="‚Ä¢ **Vendedor Verde**: Alternado (hoje n√£o, amanh√£ sim)\n‚Ä¢ **Comprador Verde**: 2 posts a cada 2 dias\n‚Ä¢ **Destacar Vermelho**: Destaques ilimitados",
        inline=False
    )
    
    embed.set_footer(text="üí° Use !assinatura para total privacidade!")
    
    await ctx.send(embed=embed)

@bot.command(name="limpar", aliases=["clear"])
@commands.has_permissions(manage_messages=True)
async def limpar_planos_expirados(ctx, confirmar: str = None):
    """Remove planos expirados do banco de dados"""
    if confirmar != "SIM":
        embed = discord.Embed(
            title="‚ö†Ô∏è Confirma√ß√£o Necess√°ria",
            description="Este comando ir√° remover TODOS os planos expirados.\n\nPara confirmar: `!limpar SIM`",
            color=discord.Color.orange()
        )
        await ctx.send(embed=embed)
        return
    
    try:
        db = load_planos_db()
        agora = int(time.time())
        
        planos_ativos = []
        removidos = 0
        
        for plano in db:
            fim = plano.get("data_fim", 0)
            if fim > agora:
                planos_ativos.append(plano)
            else:
                removidos += 1
        
        save_planos_db(planos_ativos)
        
        embed = discord.Embed(
            title="üßπ Limpeza Conclu√≠da",
            description=f"**{removidos}** planos expirados removidos.\n**{len(planos_ativos)}** planos ativos mantidos.",
            color=discord.Color.green()
        )
        
        await ctx.send(embed=embed)
        
    except Exception as e:
        print(f"Erro na limpeza: {e}")
        await ctx.send("‚ùå Erro ao limpar banco de dados.")

@bot.command(name="assinatura", aliases=["assinar", "privado"])
async def acessar_assinatura_privada(ctx):
    """Cria ou acessa seu espa√ßo privado de assinatura"""
    try:
        forum_configurado = await garantir_forum_configurado(ctx.guild)
        if not forum_configurado:
            await ctx.send("‚ùå Erro ao configurar sistema de f√≥rum. Contate um administrador.", delete_after=10)
            return
        
        thread_privada = await obter_ou_criar_thread_privada(ctx.author, ctx.guild)
        
        if not thread_privada:
            await ctx.send("‚ùå Erro ao criar/acessar seu espa√ßo privado. Tente novamente.", delete_after=10)
            return
        
        embed = discord.Embed(
            title="‚úÖ Espa√ßo Privado Criado!",
            description=f"Acesse: {thread_privada.mention}",
            color=discord.Color.green()
        )
        embed.add_field(
            name="üîí Privacidade Total",
            value="‚Ä¢ Apenas voc√™ pode ver\n‚Ä¢ PIX e Cart√£o dispon√≠veis\n‚Ä¢ Cancelamento via !status",
            inline=False
        )
        embed.set_footer(text="Mensagem deletada em 15s")
        
        await ctx.send(embed=embed, delete_after=15)
        
        try:
            await ctx.message.delete()
        except discord.NotFound:
            pass
        
        if thread_privada.message_count <= 1:
            welcome_embed = discord.Embed(
                title="üéâ Seu Espa√ßo Privado!",
                description="Ambiente privado para gerenciar assinaturas.",
                color=discord.Color.blue()
            )
            welcome_embed.add_field(
                name="üõçÔ∏è Comandos:",
                value="‚Ä¢ `!planos` - Ver planos\n‚Ä¢ `!status` - Gerenciar/cancelar\n‚Ä¢ `!plano <id>` - Comprar espec√≠fico",
                inline=False
            )
            welcome_embed.add_field(
                name="üí≥ Pagamentos:",
                value="‚Ä¢ PIX - Confirma√ß√£o r√°pida\n‚Ä¢ Cart√£o - At√© 12x sem juros\n‚Ä¢ Modalidade √∫nica ou mensal",
                inline=False
            )
            
            await thread_privada.send(embed=welcome_embed)
        
    except Exception as e:
        print(f"Erro no comando assinatura: {e}")
        await ctx.send("‚ùå Erro interno. Tente novamente.", delete_after=5)

@bot.command(name="stats")
@commands.has_permissions(administrator=True)
async def estatisticas_bot(ctx):
    """Estat√≠sticas do bot"""
    try:
        db = load_planos_db()
        payments_db = load_payments_db()
        pix_db = load_pix_db()
        posts_db = load_posts_db()
        agora = int(time.time())
        
        planos_ativos = 0
        planos_expirados = 0
        total_arrecadado_cartao = 0
        total_arrecadado_pix = 0
        pagamentos_pendentes = 0
        
        for plano in db:
            fim = plano.get("data_fim", 0)
            if fim > agora:
                planos_ativos += 1
            else:
                planos_expirados += 1
        
        for payment_data in payments_db.values():
            if payment_data["status"] == "approved":
                total_arrecadado_cartao += payment_data.get("amount", 0)
            elif payment_data["status"] == "pending":
                pagamentos_pendentes += 1
        
        for pix_data in pix_db.values():
            if pix_data["status"] == "approved":
                total_arrecadado_pix += pix_data.get("amount", 0)
        
        tipos = {"vendedor": 0, "comprador": 0, "destacar": 0}
        modalidades = {"mensal": 0, "unico": 0}
        
        for plano in db:
            if plano.get("data_fim", 0) > agora:
                tipo = plano.get("tipo", "")
                modalidade = plano.get("modalidade", "mensal")
                if tipo in tipos:
                    tipos[tipo] += 1
                if modalidade in modalidades:
                    modalidades[modalidade] += 1
        
        total_posts_rede = sum(user_data.get("posts_rede", 0) for user_data in posts_db.values())
        total_destaques = sum(user_data.get("destaques_usados", 0) for user_data in posts_db.values())
        
        embed = discord.Embed(
            title="üìä Estat√≠sticas do Sistema",
            color=discord.Color.blue()
        )
        
        embed.add_field(
            name="üìà Planos",
            value=f"**Ativos:** {planos_ativos}\n**Expirados:** {planos_expirados}",
            inline=True
        )
        
        total_arrecadado = total_arrecadado_cartao + total_arrecadado_pix
        embed.add_field(
            name="üí∞ Financeiro",
            value=f"**Total:** R$ {total_arrecadado:.2f}\n**Cart√£o:** R$ {total_arrecadado_cartao:.2f}\n**PIX:** R$ {total_arrecadado_pix:.2f}\n**Pendentes:** {pagamentos_pendentes}",
            inline=True
        )
        
        embed.add_field(
            name="üéØ Por Tipo",
            value=f"**Vendedor:** {tipos['vendedor']}\n**Comprador:** {tipos['comprador']}\n**Destacar:** {tipos['destacar']}",
            inline=True
        )
        
        embed.add_field(
            name="üíé Modalidades",
            value=f"**Mensal:** {modalidades['mensal']}\n**√önico:** {modalidades['unico']}",
            inline=True
        )
        
        embed.add_field(
            name="üìä Atividade",
            value=f"**Posts rede:** {total_posts_rede}\n**Destaques:** {total_destaques}",
            inline=True
        )
        
        embed.add_field(
            name="ü§ñ Bot",
            value=f"**Servidores:** {len(bot.guilds)}\n**Usu√°rios:** {len(set(bot.get_all_members()))}",
            inline=True
        )
        
        embed.set_footer(text=f"√öltima verifica√ß√£o: {datetime.now().strftime('%d/%m/%Y %H:%M')}")
        
        await ctx.send(embed=embed)
        
    except Exception as e:
        print(f"Erro nas estat√≠sticas: {e}")
        await ctx.send("‚ùå Erro ao gerar estat√≠sticas.")

# ================== EVENTOS ==================
@bot.event
async def on_ready():
    print(f"ü§ñ {bot.user} est√° online!")
    print(f"üìä Conectado a {len(bot.guilds)} servidor(s)")
    print(f"üë• Alcan√ßando {len(set(bot.get_all_members()))} usu√°rios √∫nicos")
    print(f"üí≥ Sistema COMPLETO ativo:")
    print("   ‚Ä¢ Pagamentos PIX e Cart√£o")
    print("   ‚Ä¢ Modalidades: Mensal e √önica (+50%)")
    print("   ‚Ä¢ Sistema de cancelamento com taxas")
    print("   ‚Ä¢ Verifica√ß√£o autom√°tica a cada 5min")
    print(f"üè∑Ô∏è Canais: {CHANNEL_CONFIG}")
    print("üîÑ FUNCIONALIDADES PRINCIPAIS:")
    print("   ‚Ä¢ PIX: Pagamento r√°pido via c√≥digo")
    print("   ‚Ä¢ Cart√£o: At√© 12x sem juros")  
    print("   ‚Ä¢ Cancelamento: Taxa 100% antes de 2 meses")
    print("   ‚Ä¢ Cargos: Vendedor/Comprador/Destacar")
    
    if not verificar_pagamentos_automatico.is_running():
        verificar_pagamentos_automatico.start()
        print("üîÑ Verifica√ß√£o autom√°tica iniciada")

@bot.event
async def on_command_error(ctx, error):
    """Tratamento de erros"""
    if isinstance(error, commands.CommandNotFound):
        embed = discord.Embed(
            title="‚ùì Comando n√£o encontrado",
            description=f"Use `!ajuda` para ver comandos dispon√≠veis.",
            color=discord.Color.orange()
        )
        await ctx.send(embed=embed, delete_after=10)
    
    elif isinstance(error, commands.MissingPermissions):
        await ctx.send("‚ùå Sem permiss√£o.", delete_after=5)
    
    elif isinstance(error, commands.BadArgument):
        await ctx.send("‚ùå Argumento inv√°lido.", delete_after=5)
    
    else:
        print(f"Erro no comando {ctx.command}: {error}")
        await ctx.send("‚ùå Erro interno. Tente novamente.", delete_after=5)

@bot.event
async def on_guild_join(guild):
    """Quando o bot entra em um servidor novo"""
    print(f"‚ûï Bot adicionado ao servidor: {guild.name} (ID: {guild.id})")
    
    # Configurar f√≥rum automaticamente
    await garantir_forum_configurado(guild)
    
    for channel in guild.text_channels:
        if channel.permissions_for(guild.me).send_messages:
            embed = discord.Embed(
                title="üéâ Sistema de Assinaturas Ativado!",
                description="Bot com pagamentos reais via PIX e Cart√£o!",
                color=discord.Color.green()
            )
            
            embed.add_field(
                name="üöÄ Come√ßar",
                value="‚Ä¢ `!ajuda` - Todos os comandos\n‚Ä¢ `!assinatura` - Espa√ßo privado\n‚Ä¢ `!planos` - Ver planos dispon√≠veis",
                inline=False
            )
            
            embed.add_field(
                name="üí∞ Novidades",
                value="‚Ä¢ **PIX**: Pagamento instant√¢neo\n‚Ä¢ **Modalidade √önica**: +50% do valor, 1 m√™s\n‚Ä¢ **Cancelamento**: Com sistema de taxas",
                inline=False
            )
            
            embed.add_field(
                name="üè∑Ô∏è Configure os Canais",
                value=f"‚Ä¢ `{CHANNEL_CONFIG['rede']}` - Para vendedores\n‚Ä¢ `{CHANNEL_CONFIG['recomendacao']}` - Para compradores\n‚Ä¢ `{CHANNEL_CONFIG['destaques']}` - Posts destacados",
                inline=False
            )
            
            embed.add_field(
                name="‚ö° Sistema Autom√°tico",
                value="‚Ä¢ Verifica√ß√£o de pagamentos a cada 5min\n‚Ä¢ Cargos atribu√≠dos automaticamente\n‚Ä¢ Controle de posts por plano",
                inline=False
            )
            
            embed.set_footer(text="Digite !assinatura para come√ßar com privacidade total!")
            
            try:
                await channel.send(embed=embed)
                break
            except discord.Forbidden:
                continue

@bot.event
async def on_member_join(member):
    """Quando um usu√°rio entra no servidor - reatribuir cargos"""
    try:
        db = load_planos_db()
        agora = int(time.time())
        
        for plano in db:
            if (plano["user_id"] == member.id and 
                plano.get("pago", False) and 
                plano.get("data_fim", 0) > agora):
                
                await assign_role_to_member(member, plano["tipo"])
                print(f"Cargo {plano['tipo']} reatribu√≠do para {member.display_name}")
                
    except Exception as e:
        print(f"Erro ao reatribuir cargos para {member.display_name}: {e}")

# ================== INICIALIZA√á√ÉO ==================
if __name__ == "__main__":
    print("üöÄ Iniciando Sistema de Assinaturas Discord...")
    print("=" * 60)
    print("üí≥ PAGAMENTOS REAIS VIA MERCADO PAGO")
    print("üì± PIX - Pagamento instant√¢neo")
    print("üí≥ CART√ÉO - Cr√©dito/D√©bito at√© 12x")
    print("üíé MODALIDADE √öNICA - +50% do valor, v√°lido 1 m√™s")
    print("üóëÔ∏è SISTEMA DE CANCELAMENTO - Taxa 100% antes de 2 meses")
    print("ü§ñ VERIFICA√á√ÉO AUTOM√ÅTICA - A cada 5 minutos")
    print("üéØ CARGOS AUTOM√ÅTICOS - Vendedor/Comprador/Destacar")
    print("=" * 60)
    print(f"üè∑Ô∏è Canais configurados: {CHANNEL_CONFIG}")
    print("üÜï ATUALIZA√á√ïES DOS PLANOS:")
    print("   ‚Ä¢ Vendedor Verde: Sistema alternado (hoje n√£o, amanh√£ sim)")
    print("   ‚Ä¢ Comprador Verde: 2 posts a cada 2 dias")
    print("   ‚Ä¢ Destacar Vermelho: Destaques ilimitados")
    print("=" * 60)
    
    if not DISCORD_TOKEN:
        print("‚ùå DISCORD_TOKEN n√£o encontrado no arquivo .env!")
        exit(1)
    
    if not ML_TOKEN:
        print("‚ùå ML_TOKEN n√£o encontrado no arquivo .env!")
        exit(1)
    
    if ML_TOKEN.startswith("APP_USR"):
        print("üö® ATEN√á√ÉO: TOKENS DE PRODU√á√ÉO - COBRAN√áAS REAIS!")
        print("üí∞ PIX e Cart√µes ser√£o cobrados de verdade!")
    elif ML_TOKEN.startswith("TEST"):
        print("üß™ TOKENS DE TESTE - Ambiente de desenvolvimento")
        print("üîß Pagamentos simulados para testes")
    else:
        print("‚ö†Ô∏è Token do Mercado Pago n√£o identificado")
    
    print("=" * 60)
    print("üîÑ RECURSOS IMPLEMENTADOS:")
    print("‚úÖ PIX com c√≥digo QR")
    print("‚úÖ Cart√£o at√© 12x sem juros")
    print("‚úÖ Modalidade √∫nica (+50%)")
    print("‚úÖ Sistema de cancelamento")
    print("‚úÖ Verifica√ß√£o autom√°tica")
    print("‚úÖ Cargos autom√°ticos")
    print("‚úÖ Controle de posts")
    print("‚úÖ Sistema de destaques")
    print("‚úÖ Espa√ßo privado por usu√°rio")
    print("=" * 60)
    
    try:
        carregar_modulos()
        bot.run(DISCORD_TOKEN)
    except discord.LoginFailure:
        print("‚ùå TOKEN do Discord inv√°lido! Verifique o arquivo .env")
    except discord.HTTPException as e:
        print(f"‚ùå Erro HTTP: {e}")
    except KeyboardInterrupt:
        print("\nüëã Bot encerrado pelo usu√°rio")
    except Exception as e:
        print(f"‚ùå Erro inesperado: {e}")
    finally:
        print("üî¥ Bot desconectado")
import os
import json
import time
import random
import asyncio
import requests
from typing import List, Dict, Any
from datetime import datetime, timedelta
import pytz

import discord
from discord.ext import commands, tasks
from discord.ui import View, Button
from dotenv import load_dotenv
import mercadopago

# ----------------- CONFIGURA√á√ïES -----------------
load_dotenv("arquivo.env")
DISCORD_TOKEN = os.getenv("DISCORD_TOKEN")
ML_TOKEN = os.getenv("ML_TOKEN")
ML_PUBLIC_KEY = os.getenv("ML_PUBLIC_KEY")

# Inicializar SDK do Mercado Pago
sdk = mercadopago.SDK(ML_TOKEN)

DB_FILE = "planos_ativos.json"
POST_DB = "posts.json"
PAYMENTS_DB = "pagamentos.json"
PIX_DB = "pix_payments.json"

intents = discord.Intents.default()
intents.message_content = True
intents.guilds = True
intents.members = True
bot = commands.Bot(command_prefix="!", intents=intents, help_command=None)

# ----------------- PLANOS ATUALIZADOS COM MODALIDADES -----------------
PLANOS = [
    {"id_plano": 1, "descricao": "Vendedor Vermelho üî¥", "tipo": "vendedor", "dias_post": 1, "preco": 25.00},
    {"id_plano": 2, "descricao": "Vendedor Verde üü¢", "tipo": "vendedor", "dias_post": 1, "alternado": True, "preco": 15.90},
    {"id_plano": 3, "descricao": "Vendedor Azul üîµ", "tipo": "vendedor", "dias_post": 2, "preco": 7.90},
    {"id_plano": 4, "descricao": "Destacar Vermelho üî¥", "tipo": "destacar", "tags": "ilimitado", "preco": 75.00},
    {"id_plano": 5, "descricao": "Destacar Verde üü¢", "tipo": "destacar", "tags": 2, "posts_necessarios": 10, "preco": 27.80},
    {"id_plano": 6, "descricao": "Destacar Azul üîµ", "tipo": "destacar", "tags": 1, "posts_necessarios": 10, "preco": 17.80},
    {"id_plano": 7, "descricao": "Comprador Vermelho üî¥", "tipo": "comprador", "dias_post": 1, "preco": 24.90},
    {"id_plano": 8, "descricao": "Comprador Verde üü¢", "tipo": "comprador", "dias_post": 2, "posts_por_periodo": 2, "preco": 12.00},
    {"id_plano": 9, "descricao": "Comprador Azul üîµ", "tipo": "comprador", "dias_post": 2, "preco": 9.50},
]

# Configura√ß√µes dos canais
CHANNEL_CONFIG = {
    "rede": "üõírede",
    "recomendacao": "üåürecomenda√ß√£o-do-caveira",
    "destaques": "üíØdestaques",
    "forum_assinaturas": "assinarüåü",
    "categoria_assinaturas": "üìÉüåüAssinaturas"
}

# ================== UTILIT√ÅRIOS JSON ==================
def load_json(path: str, default):
    try:
        with open(path, "r", encoding="utf-8") as f:
            return json.load(f)
    except FileNotFoundError:
        return default
    except json.JSONDecodeError:
        print(f"Erro ao ler {path}, usando valores padr√£o")
        return default

def save_json(path: str, data):
    try:
        with open(path, "w", encoding="utf-8") as f:
            json.dump(data, f, indent=4, ensure_ascii=False)
    except Exception as e:
        print(f"Erro ao salvar {path}: {e}")

def load_planos_db():
    return load_json(DB_FILE, [])

def save_planos_db(data):
    save_json(DB_FILE, data)

def load_payments_db():
    return load_json(PAYMENTS_DB, {})

def save_payments_db(data):
    save_json(PAYMENTS_DB, data)

def load_posts_db():
    return load_json(POST_DB, {})

def save_posts_db(data):
    save_json(POST_DB, data)

def load_pix_db():
    return load_json(PIX_DB, {})

def save_pix_db(data):
    save_json(PIX_DB, data)

# ================== SISTEMA DE F√ìRUM PRIVADO ==================
async def obter_ou_criar_thread_privada(user: discord.Member, guild: discord.Guild):
    """Obt√©m ou cria uma thread privada no f√≥rum de assinaturas para o usu√°rio"""
    try:
        categoria = discord.utils.get(guild.categories, name=CHANNEL_CONFIG["categoria_assinaturas"])
        if not categoria:
            print(f"Categoria {CHANNEL_CONFIG['categoria_assinaturas']} n√£o encontrada")
            return None
        
        forum_channel = discord.utils.get(categoria.channels, name=CHANNEL_CONFIG["forum_assinaturas"])
        if not forum_channel:
            print(f"F√≥rum {CHANNEL_CONFIG['forum_assinaturas']} n√£o encontrado na categoria")
            return None
        
        if not isinstance(forum_channel, discord.ForumChannel):
            print(f"Canal {CHANNEL_CONFIG['forum_assinaturas']} n√£o √© um canal de f√≥rum")
            return None
        
        for thread in forum_channel.threads:
            if thread.name == f"Assinatura - {user.display_name}" or thread.owner_id == user.id:
                return thread
        
        try:
            embed = discord.Embed(
                title=f"üåü Assinatura Privada - {user.display_name}",
                description="Este √© seu espa√ßo privado de assinatura. Apenas voc√™ pode ver e interagir aqui.",
                color=discord.Color.gold()
            )
            embed.add_field(
                name="üìã Como usar:",
                value="‚Ä¢ Use `!status` para ver seus planos\n‚Ä¢ Use `!planos` para comprar novos planos\n‚Ä¢ Este chat √© totalmente privado",
                inline=False
            )
            embed.set_footer(text="Sistema de Assinaturas Privadas")
            
            thread = await forum_channel.create_thread(
                name=f"Assinatura - {user.display_name}",
                content="",
                embed=embed,
                auto_archive_duration=10080,
                slowmode_delay=0
            )
            
            overwrites = {
                guild.default_role: discord.PermissionOverwrite(read_messages=False, send_messages=False),
                user: discord.PermissionOverwrite(read_messages=True, send_messages=True),
                guild.me: discord.PermissionOverwrite(read_messages=True, send_messages=True)
            }
            
            await thread.thread.edit(overwrites=overwrites)
            await thread.thread.add_user(user)
            
            print(f"Thread privada criada para {user.display_name}")
            return thread.thread
            
        except discord.Forbidden:
            print(f"Sem permiss√£o para criar thread no f√≥rum")
            return None
        except Exception as e:
            print(f"Erro ao criar thread: {e}")
            return None
    
    except Exception as e:
        print(f"Erro no sistema de f√≥rum privado: {e}")
        return None

async def garantir_forum_configurado(guild: discord.Guild):
    """Garante que o f√≥rum e categoria est√£o configurados corretamente"""
    try:
        categoria = discord.utils.get(guild.categories, name=CHANNEL_CONFIG["categoria_assinaturas"])
        if not categoria:
            try:
                categoria = await guild.create_category(CHANNEL_CONFIG["categoria_assinaturas"])
                print(f"Categoria {CHANNEL_CONFIG['categoria_assinaturas']} criada")
            except discord.Forbidden:
                print("Sem permiss√£o para criar categoria")
                return False
        
        forum_channel = discord.utils.get(categoria.channels, name=CHANNEL_CONFIG["forum_assinaturas"])
        if not forum_channel:
            try:
                overwrites = {
                    guild.default_role: discord.PermissionOverwrite(
                        read_messages=True, 
                        send_messages=False,
                        create_public_threads=False,
                        create_private_threads=False
                    ),
                    guild.me: discord.PermissionOverwrite(
                        read_messages=True,
                        send_messages=True,
                        create_public_threads=True,
                        create_private_threads=True,
                        manage_threads=True
                    )
                }
                
                forum_channel = await categoria.create_forum(
                    CHANNEL_CONFIG["forum_assinaturas"],
                    topic="F√≥rum de assinaturas privadas - cada usu√°rio tem seu espa√ßo individual",
                    overwrites=overwrites,
                    slowmode_delay=60
                )
                print(f"F√≥rum {CHANNEL_CONFIG['forum_assinaturas']} criado")
            except discord.Forbidden:
                print("Sem permiss√£o para criar f√≥rum")
                return False
            except Exception as e:
                print(f"Erro ao criar f√≥rum: {e}")
                return False
        
        return True
    
    except Exception as e:
        print(f"Erro ao configurar f√≥rum: {e}")
        return False

# ================== SISTEMA DE CANCELAMENTO ==================
def calcular_taxa_cancelamento(data_inicio: int, eh_pagamento_unico: bool = False):
    """Calcula a taxa de cancelamento baseada no tempo desde a compra"""
    agora = int(time.time())
    dias_desde_compra = (agora - data_inicio) // 86400
    
    if dias_desde_compra < 60:  # Menos de 2 meses
        if eh_pagamento_unico:
            return 1.0  # 100% de taxa para pagamento √∫nico
        else:
            return 1.0  # 100% de taxa para cancelamento antes de 2 meses
    else:
        return 0.0  # Sem taxa ap√≥s 2 meses

def pode_cancelar_plano(user_id: int, id_plano: int):
    """Verifica se o usu√°rio pode cancelar um plano espec√≠fico"""
    db = load_planos_db()
    agora = int(time.time())
    
    for plano in db:
        if (plano["user_id"] == user_id and 
            plano["id_plano"] == id_plano and 
            plano.get("pago", False) and
            plano.get("data_fim", 0) > agora):
            
            return True, plano
    
    return False, None

# ================== SISTEMA PIX ==================
def gerar_chave_pix():
    """Gera uma chave PIX √∫nica para o pagamento"""
    import uuid
    return str(uuid.uuid4())

def criar_pagamento_pix(plano: dict, user_id: int, username: str, modalidade: str = "mensal"):
    """Cria um pagamento PIX atrav√©s do Mercado Pago"""
    try:
        tz_brasil = pytz.timezone('America/Sao_Paulo')
        agora = datetime.now(tz_brasil)
        
        # Calcular pre√ßo baseado na modalidade
        preco_final = plano["preco"]
        if modalidade == "unico":
            preco_final = plano["preco"] * 1.5  # 50% a mais
        
        referencia_pix = f"pix_{plano['id_plano']}_user_{user_id}_{int(time.time())}"
        nome_usuario = username[:50] if username else "Usuario Discord"
        
        payment_data = {
            "transaction_amount": preco_final,
            "description": f"Plano {plano['descricao']} - {modalidade.capitalize()}",
            "payment_method_id": "pix",
            "payer": {
                "email": f"user{user_id}@discord.bot",
                "first_name": nome_usuario,
                "last_name": "Discord",
                "identification": {
                    "type": "CPF",
                    "number": "00000000000"  # CPF fict√≠cio para teste
                }
            },
            "external_reference": referencia_pix,
            "notification_url": "https://webhook.site/unique-id",  # Substitua por sua URL de webhook
            "date_of_expiration": (agora + timedelta(minutes=30)).isoformat()
        }
        
        payment_response = sdk.payment().create(payment_data)
        
        if payment_response["status"] == 201:
            payment_info = payment_response["response"]
            
            # Salvar informa√ß√µes do PIX
            pix_db = load_pix_db()
            pix_record = {
                "payment_id": payment_info["id"],
                "user_id": user_id,
                "plano": plano,
                "modalidade": modalidade,
                "amount": preco_final,
                "status": "pending",
                "created_date": payment_info["date_created"],
                "external_reference": referencia_pix,
                "qr_code": payment_info["point_of_interaction"]["transaction_data"]["qr_code"],
                "qr_code_base64": payment_info["point_of_interaction"]["transaction_data"]["qr_code_base64"],
                "ticket_url": payment_info["point_of_interaction"]["transaction_data"]["ticket_url"]
            }
            
            pix_db[str(payment_info["id"])] = pix_record
            save_pix_db(pix_db)
            
            return payment_info, pix_record
        else:
            print(f"Erro ao criar pagamento PIX: {payment_response}")
            return None, None
            
    except Exception as e:
        print(f"Erro ao criar pagamento PIX: {e}")
        return None, None

def verificar_pagamento_pix(payment_id: str):
    """Verifica o status de um pagamento PIX"""
    try:
        payment_response = sdk.payment().get(payment_id)
        
        if payment_response["status"] == 200:
            return payment_response["response"]
        else:
            print(f"Erro ao verificar pagamento PIX: {payment_response}")
            return None
            
    except Exception as e:
        print(f"Erro ao verificar pagamento PIX: {e}")
        return None

# ================== SISTEMA DE POSTS ATUALIZADO ==================
def pode_postar(user_id: int, tipo_plano: str):
    """Verifica se o usu√°rio pode postar baseado no plano dele"""
    db = load_planos_db()
    posts_db = load_posts_db()
    agora = int(time.time())
    
    # Verificar se tem plano ativo
    plano_ativo = None
    for plano in db:
        if (plano["user_id"] == user_id and 
            plano["tipo"] == tipo_plano and 
            plano.get("pago", False) and
            plano.get("data_fim", 0) > agora):
            plano_ativo = plano
            break
    
    if not plano_ativo:
        return False, "Voc√™ n√£o possui um plano ativo do tipo necess√°rio."
    
    # Buscar dados do plano
    plano_info = next((p for p in PLANOS if p["id_plano"] == plano_ativo["id_plano"]), None)
    if not plano_info:
        return False, "Erro: plano n√£o encontrado."
    
    user_posts = posts_db.get(str(user_id), {})
    ultimo_post = user_posts.get(f"ultimo_post_{tipo_plano}", 0)
    
    # VENDEDOR VERDE: Sistema alternado (hoje n√£o, amanh√£ sim)
    if plano_info["id_plano"] == 2:  # Vendedor Verde
        if ultimo_post == 0:  # Primeiro post
            return True, plano_ativo
            
        dias_desde_ultimo = (agora - ultimo_post) // 86400
        if dias_desde_ultimo == 0:  # Mesmo dia do √∫ltimo post
            return False, "Voc√™ pode postar novamente amanh√£ (sistema alternado)."
        elif dias_desde_ultimo >= 1:  # 1+ dias depois - pode postar
            return True, plano_ativo
    
    # COMPRADOR VERDE: 2 posts a cada 2 dias
    elif plano_info["id_plano"] == 8:  # Comprador Verde
        posts_por_periodo = plano_info.get("posts_por_periodo", 2)
        periodo = plano_info.get("dias_post", 2) * 86400  # 2 dias em segundos
        
        posts_no_periodo = user_posts.get(f"posts_periodo_{tipo_plano}", {"inicio": 0, "count": 0})
        
        # Se passou o per√≠odo, resetar contador
        if agora - posts_no_periodo["inicio"] >= periodo:
            posts_no_periodo = {"inicio": agora, "count": 0}
            user_posts[f"posts_periodo_{tipo_plano}"] = posts_no_periodo
            save_posts_db(posts_db)
        
        # Verificar se ainda pode postar no per√≠odo atual
        if posts_no_periodo["count"] >= posts_por_periodo:
            tempo_restante = periodo - (agora - posts_no_periodo["inicio"])
            horas_restantes = tempo_restante // 3600
            return False, f"Voc√™ j√° fez {posts_por_periodo} posts neste per√≠odo. Aguarde {horas_restantes} horas."
        
        return True, plano_ativo
    
    # OUTROS PLANOS: Sistema normal por dias
    else:
        dias_necessarios = plano_info.get("dias_post", 1)
        tempo_espera = dias_necessarios * 86400  # dias em segundos
        
        if agora - ultimo_post < tempo_espera:
            horas_restantes = (tempo_espera - (agora - ultimo_post)) // 3600
            return False, f"Voc√™ pode postar novamente em {horas_restantes} horas."
        
        return True, plano_ativo

def pode_usar_destaque(user_id: int):
    """Verifica se o usu√°rio pode usar a tag de destaque"""
    db = load_planos_db()
    posts_db = load_posts_db()
    agora = int(time.time())
    
    # Verificar se tem plano ativo de destacar
    plano_destacar = None
    for plano in db:
        if (plano["user_id"] == user_id and 
            plano["tipo"] == "destacar" and 
            plano.get("pago", False) and
            plano.get("data_fim", 0) > agora):
            plano_destacar = plano
            break
    
    if not plano_destacar:
        return False, "Voc√™ precisa de um plano de destaque para usar esta tag."
    
    # Buscar dados do plano
    plano_info = next((p for p in PLANOS if p["id_plano"] == plano_destacar["id_plano"]), None)
    if not plano_info:
        return False, "Erro: plano n√£o encontrado."
    
    # PLANO VERMELHO: ILIMITADO
    if plano_info["id_plano"] == 4:  # Destacar Vermelho
        return True, plano_destacar
    
    user_posts = posts_db.get(str(user_id), {})
    
    # Para planos Verde e Azul de destaque, verificar posts na rede
    if "posts_necessarios" in plano_info:
        posts_rede = user_posts.get("posts_rede", 0)
        destaques_usados = user_posts.get("destaques_usados", 0)
        
        # Calcular quantos destaques pode usar
        destaques_disponiveis = (posts_rede // plano_info["posts_necessarios"]) * plano_info["tags"]
        
        if destaques_usados >= destaques_disponiveis:
            posts_faltantes = plano_info["posts_necessarios"] - (posts_rede % plano_info["posts_necessarios"])
            return False, f"Voc√™ precisa fazer mais {posts_faltantes} posts na üõírede para usar destaque novamente."
    
    return True, plano_destacar

def registrar_post(user_id: int, canal_tipo: str, tem_destaque: bool = False):
    """Registra um post do usu√°rio"""
    posts_db = load_posts_db()
    user_posts = posts_db.get(str(user_id), {})
    agora = int(time.time())
    
    # Registrar √∫ltimo post por tipo
    if canal_tipo == "vendedor":
        user_posts["ultimo_post_vendedor"] = agora
        user_posts["posts_rede"] = user_posts.get("posts_rede", 0) + 1
    elif canal_tipo == "comprador":
        user_posts["ultimo_post_comprador"] = agora
        
        # Para comprador verde, atualizar contador do per√≠odo
        db = load_planos_db()
        for plano in db:
            if (plano["user_id"] == user_id and 
                plano["tipo"] == "comprador" and 
                plano.get("pago", False) and
                plano.get("data_fim", 0) > agora):
                
                plano_info = next((p for p in PLANOS if p["id_plano"] == plano["id_plano"]), None)
                if plano_info and plano_info["id_plano"] == 8:  # Comprador Verde
                    posts_no_periodo = user_posts.get("posts_periodo_comprador", {"inicio": 0, "count": 0})
                    posts_no_periodo["count"] += 1
                    user_posts["posts_periodo_comprador"] = posts_no_periodo
                break
    
    # Registrar uso de destaque
    if tem_destaque:
        user_posts["destaques_usados"] = user_posts.get("destaques_usados", 0) + 1
    
    posts_db[str(user_id)] = user_posts
    save_posts_db(posts_db)

async def mover_para_destaques(message: discord.Message):
    """Move uma mensagem com tag de destaque para o canal de destaques"""
    try:
        guild = message.guild
        canal_destaques = discord.utils.get(guild.channels, name=CHANNEL_CONFIG["destaques"])
        
        if not canal_destaques:
            print(f"Canal {CHANNEL_CONFIG['destaques']} n√£o encontrado")
            return
        
        embed = discord.Embed(
            title="üíØ Post em Destaque",
            description=message.content,
            color=discord.Color.gold()
        )
        embed.set_author(name=message.author.display_name, icon_url=message.author.avatar.url if message.author.avatar else None)
        embed.set_footer(text=f"Original em #{message.channel.name}")
        embed.timestamp = message.created_at
        
        if message.attachments:
            embed.set_image(url=message.attachments[0].url)
        
        await canal_destaques.send(embed=embed)
        print(f"Post de {message.author.display_name} movido para destaques")
        
    except Exception as e:
        print(f"Erro ao mover para destaques: {e}")

# ================== MERCADO PAGO CART√ÉO ==================
def criar_preferencia_pagamento(plano: dict, user_id: int, username: str, modalidade: str = "mensal"):
    try:
        tz_brasil = pytz.timezone('America/Sao_Paulo')
        agora = datetime.now(tz_brasil)
        
        # Calcular pre√ßo baseado na modalidade
        preco_final = plano["preco"]
        if modalidade == "unico":
            preco_final = plano["preco"] * 1.5  # 50% a mais
        
        referencia = f"plano_{plano['id_plano']}_user_{user_id}_{int(time.time())}_{modalidade}"
        nome_usuario = username[:50] if username else "Usuario Discord"
        
        preference_data = {
            "items": [
                {
                    "title": f"Plano {plano['descricao']} - {modalidade.capitalize()}",
                    "quantity": 1,
                    "unit_price": preco_final,
                    "currency_id": "BRL",
                    "description": f"Plano {plano['tipo']} - Discord Bot - {modalidade}"
                }
            ],
            "payer": {
                "name": nome_usuario,
                "surname": "Discord User"
            },
            "payment_methods": {
                "excluded_payment_methods": [],
                "excluded_payment_types": [],
                "installments": 12
            },
            "back_urls": {
                "success": "https://www.cleitodiscord.com/success",
                "failure": "https://www.cleitodiscord.com/failure", 
                "pending": "https://www.cleitodiscord.com/pending"
            },
            "auto_return": "approved",
            "external_reference": referencia,
            "statement_descriptor": "DISCORD_BOT",
            "expires": True,
            "expiration_date_from": agora.isoformat(),
            "expiration_date_to": (agora + timedelta(hours=24)).isoformat()
        }
        
        preference_response = sdk.preference().create(preference_data)
        
        if preference_response["status"] == 201:
            return preference_response["response"]
        else:
            print(f"Erro ao criar prefer√™ncia: {preference_response}")
            return None
    except Exception as e:
        print(f"Erro ao criar prefer√™ncia de pagamento: {e}")
        return None

def verificar_pagamento_por_referencia(external_reference):
    try:
        filters = {"external_reference": external_reference}
        search_response = sdk.payment().search(filters)
        
        if search_response["status"] == 200:
            results = search_response["response"]["results"]
            if results:
                return results[0]
        elif search_response["status"] == 429:
            print("Rate limit atingido - aguardando...")
            time.sleep(5)
            return None
        else:
            print(f"Erro na busca de pagamento: {search_response}")
        return None
    except Exception as e:
        print(f"Erro ao buscar pagamento: {e}")
        return None

def ativar_plano_apos_pagamento(user_id: int, plano: dict, modalidade: str = "mensal"):
    try:
        db = load_planos_db()
        
        timestamp = int(time.time())
        
        # Definir dura√ß√£o baseada na modalidade
        if modalidade == "unico":
            duracao = 30 * 86400  # 30 dias para pagamento √∫nico
        else:
            duracao = 30 * 86400  # 30 dias para mensal (seria recorrente em produ√ß√£o)
        
        plano_registro = {
            "user_id": user_id,
            "id_plano": plano["id_plano"],
            "descricao": plano["descricao"],
            "tipo": plano["tipo"],
            "pago": True,
            "modalidade": modalidade,
            "data_inicio": timestamp,
            "data_fim": timestamp + duracao
        }
        
        db.append(plano_registro)
        save_planos_db(db)
        return plano_registro
    except Exception as e:
        print(f"Erro ao ativar plano: {e}")
        return None

# ================== ROLES DISCORD ==================
async def ensure_role(guild: discord.Guild, name: str):
    role = discord.utils.get(guild.roles, name=name)
    if not role:
        try:
            role = await guild.create_role(name=name, color=discord.Color.blue())
            print(f"Cargo '{name}' criado no servidor {guild.name}")
        except discord.Forbidden:
            print(f"Sem permiss√£o para criar cargo: {name}")
            return None
        except Exception as e:
            print(f"Erro ao criar cargo {name}: {e}")
            return None
    return role

async def assign_role_to_member(member: discord.Member, tipo: str):
    try:
        role_name = tipo.capitalize()
        role = await ensure_role(member.guild, role_name)
        if role and role not in member.roles:
            await member.add_roles(role)
            print(f"Cargo '{role_name}' atribu√≠do a {member.display_name}")
            return True
        return True
    except discord.Forbidden:
        print(f"Sem permiss√£o para adicionar cargo a {member.display_name}")
        return False
    except Exception as e:
        print(f"Erro ao atribuir cargo: {e}")
        return False


class EscolherPagamentoView(View):
    def __init__(self, plano, modalidade):
        super().__init__(timeout=300)
        self.plano = plano
        self.modalidade = modalidade

    @discord.ui.button(label="üí≥ Cart√£o/D√©bito", style=discord.ButtonStyle.primary)
    async def pagamento_cartao(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.defer(ephemeral=True)
        
        try:
            preferencia = criar_preferencia_pagamento(self.plano, interaction.user.id, interaction.user.display_name, self.modalidade)
            
            if not preferencia:
                await interaction.followup.send("‚ùå Erro ao criar link de pagamento. Tente novamente em alguns minutos.", ephemeral=True)
                return
            
            preco_final = self.plano['preco'] if self.modalidade == "mensal" else self.plano['preco'] * 1.5
            
            embed = discord.Embed(
                title="üí≥ Pagamento com Cart√£o",
                description=f"**Plano:** {self.plano['descricao']}\n**Modalidade:** {self.modalidade.capitalize()}\n**Valor:** R$ {preco_final:.2f}",
                color=discord.Color.blue()
            )
            
            embed.add_field(
                name="üí∞ Formas de Pagamento Dispon√≠veis:",
                value="‚Ä¢ Cart√£o de Cr√©dito (at√© 12x)\n‚Ä¢ Cart√£o de D√©bito",
                inline=False
            )
            
            embed.add_field(
                name="üîó Link para Pagamento:",
                value=f"[**CLIQUE AQUI PARA PAGAR**]({preferencia['init_point']})",
                inline=False
            )
            
            embed.set_footer(text=f"ID: {preferencia['id']} - V√°lido por 24h")
            
            verificar_view = VerificarPagamentoView(preferencia["external_reference"], interaction.user.id, self.plano, self.modalidade)
            
            await interaction.followup.send(embed=embed, view=verificar_view, ephemeral=True)
            
        except Exception as e:
            print(f"Erro no pagamento cart√£o: {e}")
            await interaction.followup.send("‚ùå Erro interno. Tente novamente mais tarde.", ephemeral=True)

    @discord.ui.button(label="üì± PIX", style=discord.ButtonStyle.success)
    async def pagamento_pix(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.defer(ephemeral=True)
        
        try:
            payment_info, pix_record = criar_pagamento_pix(self.plano, interaction.user.id, interaction.user.display_name, self.modalidade)
            
            if not payment_info or not pix_record:
                await interaction.followup.send("‚ùå Erro ao criar pagamento PIX. Tente novamente.", ephemeral=True)
                return
            
            embed = discord.Embed(
                title="üì± Pagamento PIX",
                description=f"**Plano:** {self.plano['descricao']}\n**Modalidade:** {self.modalidade.capitalize()}\n**Valor:** R$ {pix_record['amount']:.2f}",
                color=discord.Color.green()
            )
            
            embed.add_field(
                name="üìã Como Pagar:",
                value="1. Copie o c√≥digo PIX abaixo\n2. Cole no seu app banc√°rio\n3. Confirme o pagamento\n4. Clique em 'Verificar Pagamento'",
                inline=False
            )
            
            embed.add_field(
                name="üîó C√≥digo PIX:",
                value=f"```{pix_record['qr_code']}```",
                inline=False
            )
            
            embed.add_field(name="‚è∞ Validade", value="30 minutos", inline=True)
            embed.add_field(name="üîç Status", value="Aguardando pagamento", inline=True)
            
            embed.set_footer(text=f"Payment ID: {payment_info['id']}")
            
            verificar_view = VerificarPagamentoPIXView(str(payment_info['id']), interaction.user.id, self.plano, self.modalidade)
            
            await interaction.followup.send(embed=embed, view=verificar_view, ephemeral=True)
            
        except Exception as e:
            print(f"Erro no pagamento PIX: {e}")
            await interaction.followup.send("‚ùå Erro interno. Tente novamente mais tarde.", ephemeral=True)

class VerificarPagamentoView(View):
    def __init__(self, external_reference, user_id, plano, modalidade):
        super().__init__(timeout=1800)
        self.external_reference = external_reference
        self.user_id = user_id
        self.plano = plano
        self.modalidade = modalidade

    @discord.ui.button(label="üîÑ Verificar Pagamento", style=discord.ButtonStyle.secondary)
    async def verificar_pagamento_btn(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.defer(ephemeral=True)
        
        try:
            pagamento = verificar_pagamento_por_referencia(self.external_reference)
            
            if not pagamento:
                await interaction.followup.send("‚è≥ Nenhum pagamento encontrado ainda. Se voc√™ acabou de pagar, aguarde alguns minutos.", ephemeral=True)
                return
            
            if pagamento["status"] == "approved":
                plano_ativado = ativar_plano_apos_pagamento(self.user_id, self.plano, self.modalidade)
                
                if not plano_ativado:
                    await interaction.followup.send("‚ùå Erro ao ativar plano. Contate o suporte.", ephemeral=True)
                    return
                
                guild_member = interaction.guild.get_member(self.user_id)
                if guild_member:
                    await assign_role_to_member(guild_member, self.plano["tipo"])
                
                preco_pago = self.plano['preco'] if self.modalidade == "mensal" else self.plano['preco'] * 1.5
                
                embed = discord.Embed(
                    title="‚úÖ PAGAMENTO APROVADO!",
                    description=f"Seu plano **{self.plano['descricao']}** foi ativado com sucesso!",
                    color=discord.Color.green()
                )
                embed.add_field(name="üìÖ Validade", value="30 dias", inline=True)
                embed.add_field(name="üí∞ Valor Pago", value=f"R$ {preco_pago:.2f}", inline=True)
                embed.add_field(name="üéØ Modalidade", value=self.modalidade.capitalize(), inline=True)
                
                for item in self.children:
                    item.disabled = True
                
                await interaction.followup.send(embed=embed, view=self)
                
            elif pagamento["status"] == "pending":
                await interaction.followup.send("‚è≥ Pagamento ainda processando. Aguarde alguns minutos e tente novamente.", ephemeral=True)
                
            elif pagamento["status"] == "rejected":
                embed = discord.Embed(
                    title="‚ùå Pagamento Rejeitado",
                    description="Seu pagamento foi rejeitado. Tente novamente ou use outro m√©todo.",
                    color=discord.Color.red()
                )
                await interaction.followup.send(embed=embed, ephemeral=True)
                
            else:
                await interaction.followup.send(f"Status: {pagamento['status']}. Continue aguardando ou tente novamente.", ephemeral=True)
        
        except Exception as e:
            print(f"Erro ao verificar pagamento: {e}")
            await interaction.followup.send("‚ùå Erro ao verificar pagamento. Tente novamente.", ephemeral=True)

class VerificarPagamentoPIXView(View):
    def __init__(self, payment_id, user_id, plano, modalidade):
        super().__init__(timeout=1800)
        self.payment_id = payment_id
        self.user_id = user_id
        self.plano = plano
        self.modalidade = modalidade

    @discord.ui.button(label="üîÑ Verificar PIX", style=discord.ButtonStyle.secondary)
    async def verificar_pix_btn(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.defer(ephemeral=True)
        
        try:
            pagamento = verificar_pagamento_pix(self.payment_id)
            
            if not pagamento:
                await interaction.followup.send("‚è≥ Erro ao verificar pagamento. Tente novamente.", ephemeral=True)
                return
            
            if pagamento["status"] == "approved":
                plano_ativado = ativar_plano_apos_pagamento(self.user_id, self.plano, self.modalidade)
                
                if not plano_ativado:
                    await interaction.followup.send("‚ùå Erro ao ativar plano. Contate o suporte.", ephemeral=True)
                    return
                
                guild_member = interaction.guild.get_member(self.user_id)
                if guild_member:
                    await assign_role_to_member(guild_member, self.plano["tipo"])
                
                # Atualizar status no banco PIX
                pix_db = load_pix_db()
                if self.payment_id in pix_db:
                    pix_db[self.payment_id]["status"] = "approved"
                    save_pix_db(pix_db)
                
                embed = discord.Embed(
                    title="‚úÖ PIX CONFIRMADO!",
                    description=f"Seu plano **{self.plano['descricao']}** foi ativado!",
                    color=discord.Color.green()
                )
                embed.add_field(name="üìÖ Validade", value="30 dias", inline=True)
                embed.add_field(name="üí∞ Valor", value=f"R$ {pix_db[self.payment_id]['amount']:.2f}", inline=True)
                embed.add_field(name="üéØ Modalidade", value=self.modalidade.capitalize(), inline=True)
                
                for item in self.children:
                    item.disabled = True
                
                await interaction.followup.send(embed=embed, view=self)
                
            elif pagamento["status"] == "pending":
                await interaction.followup.send("‚è≥ PIX ainda n√£o confirmado. Aguarde alguns minutos ap√≥s o pagamento.", ephemeral=True)
                
            else:
                await interaction.followup.send(f"Status PIX: {pagamento['status']}. Continue aguardando.", ephemeral=True)
        
        except Exception as e:
            print(f"Erro ao verificar PIX: {e}")
            await interaction.followup.send("‚ùå Erro ao verificar PIX. Tente novamente.", ephemeral=True)

class CancelarPlanoView(View):
    def __init__(self, planos_ativos):
        super().__init__(timeout=300)
        self.planos_ativos = planos_ativos
        
        options = []
        for i, plano in enumerate(planos_ativos):
            modalidade = plano.get("modalidade", "mensal")
            dias_restantes = (plano.get("data_fim", 0) - int(time.time())) // 86400
            
            taxa = calcular_taxa_cancelamento(plano.get("data_inicio", 0), modalidade == "unico")
            taxa_texto = f"Taxa: {int(taxa*100)}%" if taxa > 0 else "Sem taxa"
            
            options.append(discord.SelectOption(
                label=f"{plano['descricao']} ({modalidade})",
                value=str(i),
                description=f"{dias_restantes} dias restantes - {taxa_texto}",
                emoji="üî¥" if taxa > 0 else "üü¢"
            ))
        
        if options:
            self.select = discord.ui.Select(
                placeholder="Escolha o plano para cancelar...",
                options=options[:25],
                min_values=1,
                max_values=1
            )
            self.select.callback = self.select_callback
            self.add_item(self.select)
    
    async def select_callback(self, interaction: discord.Interaction):
        selected_index = int(self.select.values[0])
        plano_selecionado = self.planos_ativos[selected_index]
        
        modalidade = plano_selecionado.get("modalidade", "mensal")
        taxa = calcular_taxa_cancelamento(plano_selecionado.get("data_inicio", 0), modalidade == "unico")
        dias_desde_compra = (int(time.time()) - plano_selecionado.get("data_inicio", 0)) // 86400
        
        embed = discord.Embed(
            title="‚ö†Ô∏è Confirma√ß√£o de Cancelamento",
            description=f"**Plano:** {plano_selecionado['descricao']}\n**Modalidade:** {modalidade.capitalize()}",
            color=discord.Color.orange()
        )
        
        if taxa > 0:
            embed.add_field(
                name="üí∞ Taxa de Cancelamento",
                value=f"**{int(taxa*100)}%** do valor pago\n*Comprado h√° {dias_desde_compra} dias*",
                inline=False
            )
            embed.add_field(
                name="üìã Motivo da Taxa:",
                value="‚Ä¢ Cancelamento antes de 2 meses" + (" (Pagamento √∫nico)" if modalidade == "unico" else ""),
                inline=False
            )
        else:
            embed.add_field(
                name="‚úÖ Sem Taxa",
                value="Cancelamento ap√≥s 2 meses da compra",
                inline=False
            )
        
        embed.add_field(
            name="‚ö†Ô∏è ATEN√á√ÉO:",
            value="‚Ä¢ Plano ser√° cancelado imediatamente\n‚Ä¢ Acesso ser√° removido\n‚Ä¢ N√£o h√° reembolso al√©m da taxa",
            inline=False
        )
        
        view = ConfirmarCancelamentoView(plano_selecionado)
        await interaction.response.send_message(embed=embed, view=view, ephemeral=True)

class ConfirmarCancelamentoView(View):
    def __init__(self, plano):
        super().__init__(timeout=300)
        self.plano = plano

    @discord.ui.button(label="‚úÖ Confirmar Cancelamento", style=discord.ButtonStyle.danger)
    async def confirmar_cancelamento(self, interaction: discord.Interaction, button: discord.ui.Button):
        try:
            db = load_planos_db()
            
            # Remover o plano do banco de dados
            db = [p for p in db if not (p["user_id"] == self.plano["user_id"] and p["id_plano"] == self.plano["id_plano"])]
            save_planos_db(db)
            
            # Remover cargo do usu√°rio
            guild_member = interaction.guild.get_member(self.plano["user_id"])
            if guild_member:
                role_name = self.plano["tipo"].capitalize()
                role = discord.utils.get(guild_member.guild.roles, name=role_name)
                if role and role in guild_member.roles:
                    await guild_member.remove_roles(role)
            
            modalidade = self.plano.get("modalidade", "mensal")
            taxa = calcular_taxa_cancelamento(self.plano.get("data_inicio", 0), modalidade == "unico")
            
            embed = discord.Embed(
                title="‚úÖ Plano Cancelado",
                description=f"Seu plano **{self.plano['descricao']}** foi cancelado com sucesso.",
                color=discord.Color.red()
            )
            
            if taxa > 0:
                embed.add_field(
                    name="üí∞ Taxa Aplicada",
                    value=f"{int(taxa*100)}% conforme pol√≠tica de cancelamento",
                    inline=False
                )
            
            embed.add_field(
                name="üìã Informa√ß√µes:",
                value="‚Ä¢ Acesso removido imediatamente\n‚Ä¢ Cargo Discord removido\n‚Ä¢ Para reativar, fa√ßa uma nova compra",
                inline=False
            )
            
            for item in self.children:
                item.disabled = True
            
            await interaction.response.send_message(embed=embed, view=self, ephemeral=True)
            
        except Exception as e:
            print(f"Erro ao cancelar plano: {e}")
            await interaction.response.send_message("‚ùå Erro ao cancelar plano. Tente novamente.", ephemeral=True)

    @discord.ui.button(label="‚ùå Manter Plano", style=discord.ButtonStyle.secondary)
    async def manter_plano(self, interaction: discord.Interaction, button: discord.ui.Button):
        embed = discord.Embed(
            title="‚úÖ Cancelamento Abortado",
            description="Seu plano foi mantido e continua ativo.",
            color=discord.Color.green()
        )
        
        for item in self.children:
            item.disabled = True
        
        await interaction.response.send_message(embed=embed, view=self, ephemeral=True)

class ComprarViewCompleta(View):
    def __init__(self, plano):
        super().__init__(timeout=300)
        self.plano = plano

    @discord.ui.button(label="üí∞ Comprar Plano", style=discord.ButtonStyle.green)
    async def comprar_plano(self, interaction: discord.Interaction, button: discord.ui.Button):
        user_id = interaction.user.id
        
        try:
            db = load_planos_db()
            agora = int(time.time())
            
            for plano_ativo in db:
                if (plano_ativo["user_id"] == user_id and 
                    plano_ativo["tipo"] == self.plano["tipo"] and 
                    plano_ativo.get("pago", False) and
                    plano_ativo.get("data_fim", 0) > agora):
                    await interaction.response.send_message(
                        f"‚ùå Voc√™ j√° possui um plano ativo do tipo **{self.plano['tipo']}**!", 
                        ephemeral=True
                    )
                    return
            
            embed = discord.Embed(
                title="üõçÔ∏è Escolha a Modalidade",
                description=f"**Plano:** {self.plano['descricao']}\n**Tipo:** {self.plano['tipo'].capitalize()}",
                color=discord.Color.blue()
            )
            
            embed.add_field(
                name="üí∞ Mensal",
                value=f"R$ {self.plano['preco']:.2f}/m√™s\n‚úÖ Cancelamento flex√≠vel",
                inline=True
            )
            
            embed.add_field(
                name="üíé Pagar 1 Vez",
                value=f"R$ {self.plano['preco'] * 1.5:.2f} (+50%)\n‚ö†Ô∏è Taxa de cancelamento",
                inline=True
            )
            
            view = EscolherModalidadeView(self.plano)
            await interaction.response.send_message(embed=embed, view=view, ephemeral=True)
        
        except Exception as e:
            print(f"Erro na compra: {e}")
            await interaction.response.send_message("‚ùå Erro interno. Tente novamente.", ephemeral=True)

class SelecionarPlanoView(View):
    def __init__(self):
        super().__init__(timeout=300)
        
        options = []
        for plano in PLANOS:
            emoji = "üî¥" if "Vermelho" in plano["descricao"] else "üü¢" if "Verde" in plano["descricao"] else "üîµ"
            
            desc = f"Tipo: {plano['tipo'].capitalize()}"
            if plano["id_plano"] == 2:
                desc += " - Alternado"
            elif plano["id_plano"] == 4:
                desc += " - Ilimitado"
            elif plano["id_plano"] == 8:
                desc += " - 2 posts/2 dias"
            
            options.append(discord.SelectOption(
                label=f"{plano['descricao']} - R$ {plano['preco']:.2f}",
                value=str(plano["id_plano"]),
                emoji=emoji,
                description=desc
            ))
        
        self.select = discord.ui.Select(
            placeholder="Escolha um plano...",
            options=options[:25],
            min_values=1,
            max_values=1
        )
        self.select.callback = self.select_callback
        self.add_item(self.select)
    
    async def select_callback(self, interaction: discord.Interaction):
        selected_id = int(self.select.values[0])
        plano = next((p for p in PLANOS if p["id_plano"] == selected_id), None)
        
        if plano:
            embed = discord.Embed(
                title=f"üí∞ {plano['descricao']}",
                description=f"**Pre√ßo:** R$ {plano['preco']:.2f} (mensal)\n**Tipo:** {plano['tipo'].capitalize()}",
                color=discord.Color.green()
            )
            
            if plano["id_plano"] == 2:
                embed.add_field(name="üìÖ Postagem", value="Alternada (hoje n√£o, amanh√£ sim)", inline=True)
            elif plano["id_plano"] == 8:
                embed.add_field(name="üìÖ Postagem", value="2 posts a cada 2 dias", inline=True)
            elif "dias_post" in plano:
                if plano["dias_post"] == 1:
                    embed.add_field(name="üìÖ Postagem", value="Di√°ria", inline=True)
                else:
                    embed.add_field(name="üìÖ Postagem", value=f"A cada {plano['dias_post']} dias", inline=True)
            
            if "tags" in plano:
                if plano["tags"] == "ilimitado":
                    embed.add_field(name="üè∑Ô∏è Destaques", value="Ilimitados", inline=True)
                elif "posts_necessarios" in plano:
                    embed.add_field(name="üè∑Ô∏è Destaques", value=f"{plano['tags']} a cada {plano['posts_necessarios']} posts", inline=True)
                else:
                    embed.add_field(name="üè∑Ô∏è Tags", value=str(plano["tags"]), inline=True)
            
            embed.add_field(name="‚è∞ Dura√ß√£o", value="30 dias", inline=True)
            embed.set_footer(text="Escolha entre modalidade mensal ou pagamento √∫nico")
            
            view = ComprarViewCompleta(plano)
            await interaction.response.send_message(embed=embed, view=view, ephemeral=True)

        # ================== CORRE√á√ïES - ADICIONAR ESTAS FUN√á√ïES ==================

# 1. CORRIGIR FUN√á√ÉO DE CARGOS - SUBSTITUIR A EXISTENTE
async def assign_role_to_member(member: discord.Member, tipo: str):
    """VERS√ÉO CORRIGIDA - USA CARGOS EXISTENTES"""
    try:
        role_name = tipo.capitalize()  # vendedor -> Vendedor
        
        # BUSCAR cargo existente no servidor
        role = discord.utils.get(member.guild.roles, name=role_name)
        
        if not role:
            print(f"‚ùå Cargo '{role_name}' n√£o encontrado no servidor")
            return False
        
        if role not in member.roles:
            await member.add_roles(role)
            print(f"‚úÖ Cargo '{role_name}' atribu√≠do a {member.display_name}")
        
        return True
        
    except Exception as e:
        print(f"‚ùå Erro ao atribuir cargo: {e}")
        return False

# 2. NOVA VIEW PARA MODALIDADES (CORRIGIR BOT√ÉO "PAGAR 1 VEZ")
# ================== CORRE√á√ïES PRINCIPAIS ==================

# 1. ERRO NO BOT√ÉO "PAGAR 1 VEZ" - Typo no ephemeral
class EscolherModalidadeView(View):
    def __init__(self, plano):
        super().__init__(timeout=300)
        self.plano = plano

    @discord.ui.button(label="üí∞ Mensal", style=discord.ButtonStyle.green)
    async def modalidade_mensal(self, interaction: discord.Interaction, button: discord.ui.Button):
        embed = discord.Embed(
            title=f"üí∞ Plano Mensal",
            description=f"**Plano:** {self.plano['descricao']}\n**Pre√ßo:** R$ {self.plano['preco']:.2f}/m√™s",
            color=discord.Color.green()
        )
        embed.add_field(name="‚úÖ Vantagens", value="‚Ä¢ Cancelamento ap√≥s 2 meses sem taxa", inline=False)
        
        view = EscolherPagamentoView(self.plano, "mensal")
        await interaction.response.send_message(embed=embed, view=view, ephemeral=True)

    @discord.ui.button(label="üíé Pagar 1 Vez (+50%)", style=discord.ButtonStyle.blurple)
    async def modalidade_unica(self, interaction: discord.Interaction, button: discord.ui.Button):
        preco_unico = self.plano['preco'] * 1.5
        embed = discord.Embed(
            title=f"üíé Pagamento √önico",
            description=f"**Plano:** {self.plano['descricao']}\n**Pre√ßo:** R$ {preco_unico:.2f} (√∫nica vez)",
            color=discord.Color.purple()
        )
        embed.add_field(
            name="‚ö†Ô∏è Taxa de Cancelamento",
            value="‚Ä¢ Antes de 2 meses: **100% de taxa**\n‚Ä¢ V√°lido por 30 dias",
            inline=False
        )
        
        view = EscolherPagamentoView(self.plano, "unico")
        # ERRO ESTAVA AQUI: ephemeal -> ephemeral
        await interaction.response.send_message(embed=embed, view=view, ephemeral=True)

# 2. FUN√á√ÉO DE SALVAR PAGAMENTO CART√ÉO CORRIGIDA
def salvar_preferencia_pendente(preference_data, user_id, plano, modalidade="mensal"):
    try:
        payments_db = load_payments_db()
        
        # Calcular pre√ßo final baseado na modalidade
        preco_final = plano["preco"]
        if modalidade == "unico":
            preco_final = plano["preco"] * 1.5
        
        payment_record = {
            "preference_id": preference_data["id"],
            "user_id": user_id,
            "plano": plano,
            "modalidade": modalidade,  # ADICIONAR modalidade
            "amount": preco_final,     # USAR pre√ßo correto
            "status": "pending",
            "created_date": preference_data["date_created"],
            "checkout_link": preference_data["init_point"],
            "external_reference": preference_data.get("external_reference")
        }
        
        payments_db[str(preference_data["id"])] = payment_record
        save_payments_db(payments_db)
        return payment_record
    except Exception as e:
        print(f"Erro ao salvar prefer√™ncia pendente: {e}")
        return None

# 3. VIEW DE PAGAMENTO CORRIGIDA
class EscolherPagamentoView(View):
    def __init__(self, plano, modalidade):
        super().__init__(timeout=300)
        self.plano = plano
        self.modalidade = modalidade

    @discord.ui.button(label="üí≥ Cart√£o/D√©bito", style=discord.ButtonStyle.primary)
    async def pagamento_cartao(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.defer(ephemeral=True)
        
        try:
            preferencia = criar_preferencia_pagamento(self.plano, interaction.user.id, interaction.user.display_name, self.modalidade)
            
            if not preferencia:
                await interaction.followup.send("‚ùå Erro ao criar link de pagamento.", ephemeral=True)
                return
            
            # SALVAR COM MODALIDADE
            payment_record = salvar_preferencia_pendente(preferencia, interaction.user.id, self.plano, self.modalidade)
            
            preco_final = self.plano['preco'] if self.modalidade == "mensal" else self.plano['preco'] * 1.5
            
            embed = discord.Embed(
                title="üí≥ Pagamento com Cart√£o",
                description=f"**Plano:** {self.plano['descricao']}\n**Modalidade:** {self.modalidade.capitalize()}\n**Valor:** R$ {preco_final:.2f}",
                color=discord.Color.blue()
            )
            
            embed.add_field(
                name="üîó Link para Pagamento:",
                value=f"[**CLIQUE AQUI PARA PAGAR**]({preferencia['init_point']})",
                inline=False
            )
            
            verificar_view = VerificarPagamentoView(preferencia["external_reference"], interaction.user.id, self.plano, self.modalidade)
            await interaction.followup.send(embed=embed, view=verificar_view, ephemeral=True)
            
        except Exception as e:
            print(f"Erro no pagamento cart√£o: {e}")
            await interaction.followup.send("‚ùå Erro interno.", ephemeral=True)

    @discord.ui.button(label="üì± PIX", style=discord.ButtonStyle.success)
    async def pagamento_pix(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.defer(ephemeral=True)
        
        try:
            payment_info, pix_record = criar_pagamento_pix(self.plano, interaction.user.id, interaction.user.display_name, self.modalidade)
            
            if not payment_info or not pix_record:
                await interaction.followup.send("‚ùå Erro ao criar pagamento PIX.", ephemeral=True)
                return
            
            embed = discord.Embed(
                title="üì± Pagamento PIX",
                description=f"**Plano:** {self.plano['descricao']}\n**Modalidade:** {self.modalidade.capitalize()}\n**Valor:** R$ {pix_record['amount']:.2f}",
                color=discord.Color.green()
            )
            
            embed.add_field(
                name="üîó C√≥digo PIX:",
                value=f"```{pix_record['qr_code']}```",
                inline=False
            )
            
            verificar_view = VerificarPagamentoPIXView(str(payment_info['id']), interaction.user.id, self.plano, self.modalidade)
            await interaction.followup.send(embed=embed, view=verificar_view, ephemeral=True)
            
        except Exception as e:
            print(f"Erro no pagamento PIX: {e}")
            await interaction.followup.send("‚ùå Erro interno PIX.", ephemeral=True)

# 4. VERIFICA√á√ÉO DE PAGAMENTO CORRIGIDA
class VerificarPagamentoView(View):
    def __init__(self, external_reference, user_id, plano, modalidade):
        super().__init__(timeout=1800)
        self.external_reference = external_reference
        self.user_id = user_id
        self.plano = plano
        self.modalidade = modalidade

    @discord.ui.button(label="üîÑ Verificar Pagamento", style=discord.ButtonStyle.secondary)
    async def verificar_pagamento_btn(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.defer(ephemeral=True)
        
        try:
            pagamento = verificar_pagamento_por_referencia(self.external_reference)
            
            if not pagamento:
                await interaction.followup.send("‚è≥ Nenhum pagamento encontrado ainda.", ephemeral=True)
                return
            
            if pagamento["status"] == "approved":
                plano_ativado = ativar_plano_apos_pagamento(self.user_id, self.plano, self.modalidade)
                
                if not plano_ativado:
                    await interaction.followup.send("‚ùå Erro ao ativar plano.", ephemeral=True)
                    return
                
                guild_member = interaction.guild.get_member(self.user_id)
                if guild_member:
                    await assign_role_to_member(guild_member, self.plano["tipo"])
                
                # ATUALIZAR STATUS NO BANCO
                payments_db = load_payments_db()
                for payment_id, payment_data in payments_db.items():
                    if payment_data.get("external_reference") == self.external_reference:
                        payment_data["status"] = "approved"
                        save_payments_db(payments_db)
                        break
                
                preco_pago = self.plano['preco'] if self.modalidade == "mensal" else self.plano['preco'] * 1.5
                
                embed = discord.Embed(
                    title="‚úÖ PAGAMENTO APROVADO!",
                    description=f"Seu plano **{self.plano['descricao']}** foi ativado!",
                    color=discord.Color.green()
                )
                embed.add_field(name="üí∞ Valor", value=f"R$ {preco_pago:.2f}", inline=True)
                embed.add_field(name="üéØ Modalidade", value=self.modalidade.capitalize(), inline=True)
                
                for item in self.children:
                    item.disabled = True
                
                await interaction.followup.send(embed=embed, view=self, ephemeral=True)
                
            elif pagamento["status"] == "pending":
                await interaction.followup.send("‚è≥ Pagamento ainda processando.", ephemeral=True)
            else:
                await interaction.followup.send(f"Status: {pagamento['status']}", ephemeral=True)
        
        except Exception as e:
            print(f"Erro ao verificar pagamento: {e}")
            await interaction.followup.send("‚ùå Erro ao verificar pagamento.", ephemeral=True)

# 5. SISTEMA DE CANCELAMENTO CORRIGIDO
class CancelarPlanoView(View):
    def __init__(self, planos_ativos):
        super().__init__(timeout=300)
        self.planos_ativos = planos_ativos
        
        if not planos_ativos:
            return
        
        options = []
        for i, plano in enumerate(planos_ativos):
            modalidade = plano.get("modalidade", "mensal")
            dias_restantes = (plano.get("data_fim", 0) - int(time.time())) // 86400
            
            taxa = calcular_taxa_cancelamento(plano.get("data_inicio", 0), modalidade == "unico")
            taxa_texto = f"Taxa: {int(taxa*100)}%" if taxa > 0 else "Sem taxa"
            
            options.append(discord.SelectOption(
                label=f"{plano['descricao']} ({modalidade})",
                value=str(i),
                description=f"{dias_restantes} dias - {taxa_texto}",
                emoji="üî¥" if taxa > 0 else "üü¢"
            ))
        
        if options:
            self.select = discord.ui.Select(
                placeholder="Escolha o plano para cancelar...",
                options=options[:25]
            )
            self.select.callback = self.select_callback
            self.add_item(self.select)
    
    async def select_callback(self, interaction: discord.Interaction):
        try:
            selected_index = int(self.select.values[0])
            plano_selecionado = self.planos_ativos[selected_index]
            
            modalidade = plano_selecionado.get("modalidade", "mensal")
            taxa = calcular_taxa_cancelamento(plano_selecionado.get("data_inicio", 0), modalidade == "unico")
            
            embed = discord.Embed(
                title="‚ö†Ô∏è Confirma√ß√£o de Cancelamento",
                description=f"**Plano:** {plano_selecionado['descricao']}\n**Modalidade:** {modalidade.capitalize()}",
                color=discord.Color.orange()
            )
            
            if taxa > 0:
                embed.add_field(
                    name="üí∞ Taxa de Cancelamento",
                    value=f"**{int(taxa*100)}%** do valor pago",
                    inline=False
                )
            else:
                embed.add_field(
                    name="‚úÖ Sem Taxa",
                    value="Cancelamento ap√≥s 2 meses da compra",
                    inline=False
                )
            
            view = ConfirmarCancelamentoView(plano_selecionado)
            await interaction.response.send_message(embed=embed, view=view, ephemeral=True)
            
        except Exception as e:
            print(f"Erro no select callback: {e}")
            await interaction.response.send_message("‚ùå Erro ao processar sele√ß√£o.", ephemeral=True)

class ConfirmarCancelamentoView(View):
    def __init__(self, plano):
        super().__init__(timeout=300)
        self.plano = plano

    @discord.ui.button(label="‚úÖ Confirmar Cancelamento", style=discord.ButtonStyle.danger)
    async def confirmar_cancelamento(self, interaction: discord.Interaction, button: discord.ui.Button):
        try:
            db = load_planos_db()
            
            # REMOVER PLANO CORRETAMENTE
            db_filtrado = []
            plano_removido = False
            
            for p in db:
                if (p["user_id"] == self.plano["user_id"] and 
                    p["id_plano"] == self.plano["id_plano"] and
                    p.get("data_inicio") == self.plano.get("data_inicio")):
                    plano_removido = True
                    continue
                db_filtrado.append(p)
            
            if not plano_removido:
                await interaction.response.send_message("‚ùå Plano n√£o encontrado.", ephemeral=True)
                return
            
            save_planos_db(db_filtrado)
            
            # REMOVER CARGO
            guild_member = interaction.guild.get_member(self.plano["user_id"])
            if guild_member:
                role_name = self.plano["tipo"].capitalize()
                role = discord.utils.get(guild_member.guild.roles, name=role_name)
                if role and role in guild_member.roles:
                    await guild_member.remove_roles(role)
            
            embed = discord.Embed(
                title="‚úÖ Plano Cancelado",
                description=f"Seu plano **{self.plano['descricao']}** foi cancelado.",
                color=discord.Color.red()
            )
            
            for item in self.children:
                item.disabled = True
            
            await interaction.response.send_message(embed=embed, view=self, ephemeral=True)
            
        except Exception as e:
            print(f"Erro ao cancelar plano: {e}")
            await interaction.response.send_message("‚ùå Erro ao cancelar plano.", ephemeral=True)

    @discord.ui.button(label="‚ùå Manter Plano", style=discord.ButtonStyle.secondary)
    async def manter_plano(self, interaction: discord.Interaction, button: discord.ui.Button):
        embed = discord.Embed(
            title="‚úÖ Cancelamento Abortado",
            description="Seu plano foi mantido e continua ativo.",
            color=discord.Color.green()
        )
        
        for item in self.children:
            item.disabled = True
        
        await interaction.response.send_message(embed=embed, view=self, ephemeral=True)

# 6. VERIFICA√á√ÉO AUTOM√ÅTICA CORRIGIDA
@tasks.loop(minutes=5)
async def verificar_pagamentos_automatico():
    """Verifica pagamentos pendentes automaticamente"""
    await bot.wait_until_ready()
    
    try:
        # Verificar pagamentos de cart√£o
        payments_db = load_payments_db()
        if payments_db:
            for payment_id, payment_data in payments_db.items():
                if payment_data["status"] == "pending":
                    external_ref = payment_data.get("external_reference")
                    if external_ref:
                        pagamento_atual = verificar_pagamento_por_referencia(external_ref)
                        
                        if pagamento_atual and pagamento_atual["status"] == "approved":
                            user_id = payment_data["user_id"]
                            plano = payment_data["plano"]
                            modalidade = payment_data.get("modalidade", "mensal")  # PEGAR MODALIDADE
                            
                            plano_ativado = ativar_plano_apos_pagamento(user_id, plano, modalidade)
                            
                            if plano_ativado:
                                # NOTIFICAR USU√ÅRIO E ATRIBUIR CARGO
                                for guild in bot.guilds:
                                    member = guild.get_member(user_id)
                                    if member:
                                        await assign_role_to_member(member, plano["tipo"])
                                        break
                                
                                payments_db[payment_id]["status"] = "approved"
                                save_payments_db(payments_db)
                                
                                print(f"‚úÖ Plano {plano['descricao']} ativado automaticamente para usu√°rio {user_id}")
        
        # Verificar pagamentos PIX
        pix_db = load_pix_db()
        if pix_db:
            for payment_id, pix_data in pix_db.items():
                if pix_data["status"] == "pending":
                    pagamento_pix = verificar_pagamento_pix(payment_id)
                    
                    if pagamento_pix and pagamento_pix["status"] == "approved":
                        user_id = pix_data["user_id"]
                        plano = pix_data["plano"]
                        modalidade = pix_data["modalidade"]
                        
                        plano_ativado = ativar_plano_apos_pagamento(user_id, plano, modalidade)
                        
                        if plano_ativado:
                            for guild in bot.guilds:
                                member = guild.get_member(user_id)
                                if member:
                                    await assign_role_to_member(member, plano["tipo"])
                                    break
                            
                            pix_db[payment_id]["status"] = "approved"
                            save_pix_db(pix_db)
                            
                            print(f"‚úÖ Plano PIX {plano['descricao']} ativado automaticamente")
    
    except Exception as e:
        print(f"Erro na verifica√ß√£o autom√°tica: {e}")

# 7. COMANDO STATUS COM CANCELAMENTO
@bot.command(name="status")
async def status_usuario(ctx):
    """Mostra status dos planos do usu√°rio com op√ß√£o de cancelamento"""
    try:
        user_id = ctx.author.id
        db = load_planos_db()
        
        embed = discord.Embed(
            title=f"üìä Meus Planos - {ctx.author.display_name}",
            color=discord.Color.blue()
        )
        
        agora = int(time.time())
        planos_ativos = []
        
        for plano in db:
            if plano["user_id"] == user_id and plano.get("pago", False):
                fim = plano.get("data_fim", agora)
                if fim > agora:
                    planos_ativos.append(plano)
        
        if planos_ativos:
            ativo_text = ""
            for plano in planos_ativos:
                fim = plano.get("data_fim", agora)
                dias_restantes = (fim - agora) // 86400
                modalidade = plano.get("modalidade", "mensal")
                ativo_text += f"‚Ä¢ **{plano['descricao']}** ({modalidade})\n  üìÖ {dias_restantes} dias restantes\n\n"
            
            embed.add_field(name="‚úÖ Planos Ativos", value=ativo_text, inline=False)
            
            # BOT√ÉO DE CANCELAMENTO
            view = View(timeout=300)
            cancelar_btn = discord.ui.Button(label="üóëÔ∏è Cancelar Plano", style=discord.ButtonStyle.danger)
            
            async def cancelar_callback(interaction):
                if interaction.user.id != user_id:
                    await interaction.response.send_message("‚ùå Voc√™ n√£o pode usar este bot√£o.", ephemeral=True)
                    return
                
                view_cancelar = CancelarPlanoView(planos_ativos)
                embed_cancelar = discord.Embed(
                    title="üóëÔ∏è Cancelar Plano",
                    description="Escolha o plano que deseja cancelar:",
                    color=discord.Color.orange()
                )
                await interaction.response.send_message(embed=embed_cancelar, view=view_cancelar, ephemeral=True)
            
            cancelar_btn.callback = cancelar_callback
            view.add_item(cancelar_btn)
        else:
            embed.description = "Nenhum plano ativo encontrado."
            view = None
        
        await ctx.send(embed=embed, view=view)
        
    except Exception as e:
        print(f"Erro ao mostrar status: {e}")
        await ctx.send("‚ùå Erro ao verificar status.")

# 3. CORRIGIR VIEW DE COMPRA PARA MOSTRAR MODALIDADES
class ComprarViewCompleta(View):
    def __init__(self, plano):
        super().__init__(timeout=300)
        self.plano = plano

    @discord.ui.button(label="üí∞ Comprar Plano", style=discord.ButtonStyle.green)
    async def comprar_plano(self, interaction: discord.Interaction, button: discord.ui.Button):
        user_id = interaction.user.id
        db = load_planos_db()
        agora = int(time.time())
        
        # Verificar se j√° tem plano ativo do mesmo tipo
        for plano_ativo in db:
            if (plano_ativo["user_id"] == user_id and 
                plano_ativo["tipo"] == self.plano["tipo"] and 
                plano_ativo.get("pago", False) and
                plano_ativo.get("data_fim", 0) > agora):
                await interaction.response.send_message(
                    f"‚ùå Voc√™ j√° possui um plano **{self.plano['tipo']}** ativo!", 
                    ephemeral=True
                )
                return
        
        # Mostrar op√ß√µes de modalidade
        embed = discord.Embed(
            title="üõçÔ∏è Escolha a Modalidade",
            description=f"**Plano:** {self.plano['descricao']}",
            color=discord.Color.blue()
        )
        embed.add_field(
            name="üí∞ Mensal",
            value=f"R$ {self.plano['preco']:.2f}/m√™s",
            inline=True
        )
        embed.add_field(
            name="üíé √önica (+50%)",
            value=f"R$ {self.plano['preco'] * 1.5:.2f}",
            inline=True
        )
        
        view = EscolherModalidadeView(self.plano)
        await interaction.response.send_message(embed=embed, view=view, ephemeral=True)

# 4. STATUS AUTOM√ÅTICO EM CANAL ESPEC√çFICO
async def enviar_status_automatico(guild: discord.Guild):
    """Envia status em canal espec√≠fico automaticamente"""
    try:
        canal_status = discord.utils.get(guild.channels, name="status-de-plano")
        
        if not canal_status:
            print("Canal 'status-de-plano' n√£o encontrado")
            return
        
        # Limpar mensagens antigas
        try:
            async for message in canal_status.history(limit=100):
                if message.author == bot.user:
                    await message.delete()
        except:
            pass
        
        db = load_planos_db()
        agora = int(time.time())
        
        embed = discord.Embed(
            title="üìä Status Geral de Planos",
            description="Atualiza√ß√µes autom√°ticas dos planos ativos",
            color=discord.Color.blue()
        )
        
        planos_ativos = 0
        usuarios_ativos = set()
        
        for plano in db:
            if plano.get("pago", False) and plano.get("data_fim", 0) > agora:
                planos_ativos += 1
                usuarios_ativos.add(plano["user_id"])
        
        embed.add_field(name="üìà Planos Ativos", value=str(planos_ativos), inline=True)
        embed.add_field(name="üë• Usu√°rios com Plano", value=str(len(usuarios_ativos)), inline=True)
        embed.add_field(name="üîÑ √öltima Atualiza√ß√£o", value="Agora", inline=True)
        
        embed.set_footer(text="Use !status para ver seus planos individuais")
        
        await canal_status.send(embed=embed)
        
    except Exception as e:
        print(f"Erro no status autom√°tico: {e}")

# 5. COMANDO STATUS INTEGRADO
@bot.command(name="status")
async def status_integrado(ctx):
    """Status com integra√ß√£o ao canal espec√≠fico"""
    try:
        user_id = ctx.author.id
        db = load_planos_db()
        
        embed = discord.Embed(
            title=f"üìä Seus Planos - {ctx.author.display_name}",
            color=discord.Color.blue()
        )
        
        agora = int(time.time())
        planos_ativos = []
        
        for plano in db:
            if plano["user_id"] == user_id and plano.get("pago", False):
                fim = plano.get("data_fim", agora)
                if fim > agora:
                    planos_ativos.append(plano)
        
        if planos_ativos:
            texto_planos = ""
            for plano in planos_ativos:
                fim = plano.get("data_fim", agora)
                dias_restantes = (fim - agora) // 86400
                modalidade = plano.get("modalidade", "mensal")
                texto_planos += f"‚Ä¢ **{plano['descricao']}** ({modalidade})\n  üìÖ {dias_restantes} dias restantes\n\n"
            
            embed.add_field(name="‚úÖ Planos Ativos", value=texto_planos, inline=False)
            
            # Bot√£o cancelar s√≥ se tem planos
            view = View(timeout=300)
            btn_cancelar = discord.ui.Button(label="üóëÔ∏è Cancelar Plano", style=discord.ButtonStyle.danger)
            
            async def cancelar_callback(interaction):
                if interaction.user.id != user_id:
                    await interaction.response.send_message("‚ùå N√£o √© seu plano.", ephemeral=True)
                    return
                
                view_cancelar = CancelarPlanoView(planos_ativos)
                embed_cancelar = discord.Embed(
                    title="üóëÔ∏è Cancelar Plano",
                    description="Escolha qual plano cancelar:",
                    color=discord.Color.orange()
                )
                await interaction.response.send_message(embed=embed_cancelar, view=view_cancelar, ephemeral=True)
            
            btn_cancelar.callback = cancelar_callback
            view.add_item(btn_cancelar)
        else:
            embed.description = "Nenhum plano ativo."
            view = None
        
        # Tentar enviar no canal status-de-plano tamb√©m
        try:
            canal_status = discord.utils.get(ctx.guild.channels, name="status-de-plano")
            if canal_status:
                embed_canal = embed.copy()
                embed_canal.set_footer(text=f"Status solicitado por {ctx.author.display_name}")
                await canal_status.send(embed=embed_canal)
        except:
            pass
        
        await ctx.send(embed=embed, view=view)
        
    except Exception as e:
        await ctx.send("‚ùå Erro ao verificar status.")

# 6. TASK PARA ATUALIZAR STATUS AUTOM√ÅTICO
@tasks.loop(hours=6)  # Atualiza a cada 6 horas
async def atualizar_status_automatico():
    """Atualiza status no canal automaticamente"""
    await bot.wait_until_ready()
    
    for guild in bot.guilds:
        await enviar_status_automatico(guild)

# 7. INICIAR TASK QUANDO BOT FICAR ONLINE
@bot.event
async def on_ready():
    print(f"ü§ñ {bot.user} online!")
    
    if not verificar_pagamentos_automatico.is_running():
        verificar_pagamentos_automatico.start()
    
    if not atualizar_status_automatico.is_running():
        atualizar_status_automatico.start()
    
    # Enviar status inicial em todos os servidores
    for guild in bot.guilds:
        await enviar_status_automatico(guild)
def carregar_modulos():
    pasta_modulos = "modulos"
    
    if not os.path.exists(pasta_modulos):
        os.makedirs(pasta_modulos)
        return
    
    import builtins
    builtins.bot = bot
    builtins.load_planos_db = load_planos_db
    builtins.save_planos_db = save_planos_db
    builtins.PLANOS = PLANOS
    builtins.discord = discord
    builtins.commands = commands
    builtins.time = time
    
    for arquivo in os.listdir(pasta_modulos):
        if arquivo.endswith('.py'):
            nome_modulo = arquivo[:-3]
            try:
                spec = importlib.util.spec_from_file_location(
                    nome_modulo, 
                    os.path.join(pasta_modulos, arquivo)
                )
                modulo = importlib.util.module_from_spec(spec)
                spec.loader.exec_module(modulo)
                print(f"M√≥dulo '{nome_modulo}' carregado")
            except Exception as e:
                print(f"Erro no m√≥dulo '{nome_modulo}': {e}")
def carregar_modulos():
    pasta_modulos = "modulos"
    
    if not os.path.exists(pasta_modulos):
        os.makedirs(pasta_modulos)
        return
    
    import builtins
    builtins.bot = bot
    builtins.load_planos_db = load_planos_db
    builtins.save_planos_db = save_planos_db
    builtins.PLANOS = PLANOS
    builtins.discord = discord
    builtins.commands = commands
    builtins.time = time
    
    for arquivo in os.listdir(pasta_modulos):
        if arquivo.endswith('.py'):
            nome_modulo = arquivo[:-3]
            try:
                spec = importlib.util.spec_from_file_location(
                    nome_modulo, 
                    os.path.join(pasta_modulos, arquivo)
                )
                modulo = importlib.util.module_from_spec(spec)
                spec.loader.exec_module(modulo)
                print(f"‚úÖ M√≥dulo '{nome_modulo}' carregado")
            except Exception as e:
                print(f"‚ùå Erro no m√≥dulo '{nome_modulo}': {e}")
@bot.command(name="modulo_teste")
async def teste_modulo(ctx):
    await ctx.send("M√≥dulo funcionando!")
 # 7. INICIAR TASK QUANDO BOT FICAR ONLINE

@bot.event
async def on_ready():
    print(f"ü§ñ {bot.user} online!")
    
    if not verificar_pagamentos_automatico.is_running():
        verificar_pagamentos_automatico.start()
    
    if not atualizar_status_automatico.is_running():
        atualizar_status_automatico.start()
    
    # Enviar status inicial em todos os servidores
    for guild in bot.guilds:
        await enviar_status_automatico(guild)

def carregar_modulos():
    "Carrega automaticamente todos os m√≥dulos da pasta 'modulos'"""
    pasta_modulos = "modulos"
    
    if not os.path.exists(pasta_modulos):
        os.makedirs(pasta_modulos)
        print(f"Pasta '{pasta_modulos}' criada")
        return
    
    # Fazer as fun√ß√µes e vari√°veis principais dispon√≠veis globalmente
    import builtins
    builtins.bot = bot
    builtins.PLANOS = PLANOS
    builtins.CHANNEL_CONFIG = CHANNEL_CONFIG
    builtins.load_planos_db = load_planos_db
    builtins.save_planos_db = save_planos_db
    builtins.load_posts_db = load_posts_db
    builtins.save_posts_db = save_posts_db
    builtins.load_payments_db = load_payments_db
    builtins.save_payments_db = save_payments_db
    builtins.load_pix_db = load_pix_db
    builtins.save_pix_db = save_pix_db
    builtins.assign_role_to_member = assign_role_to_member
    builtins.ativar_plano_apos_pagamento = ativar_plano_apos_pagamento
    builtins.time = time
    builtins.discord = discord
    builtins.commands = commands
    
    # Carregar todos os arquivos .py da pasta modulos
    for arquivo in os.listdir(pasta_modulos):
        if arquivo.endswith('.py') and not arquivo.startswith('_'):
            nome_modulo = arquivo[:-3]  # Remove .py
            try:
                spec = importlib.util.spec_from_file_location(
                    nome_modulo, 
                    os.path.join(pasta_modulos, arquivo)
                )
                modulo = importlib.util.module_from_spec(spec)
                spec.loader.exec_module(modulo)
                print(f"‚úÖ M√≥dulo '{nome_modulo}' carregado com sucesso")
                
            except Exception as e:
                print(f"‚ùå Erro ao carregar m√≥dulo '{nome_modulo}': {e}")
import codigo2bot.py   # importa o outro arquivo

print("bot principal iniciou")

codigo2bot.ola()    # chama fun√ß√£o do codigo2bot
